# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Oleksandr Miroshkin <miroshkinan@gmail.com>, 2023.
# Olexandr Konovalov, 2023.
# Sofiia Matios, 2023.
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2023-02-12 19:32:08+0000\n"
"PO-Revision-Date: 2023-02-12 19:38+0000\n"
"Last-Translator: Oleksandr Miroshkin <miroshkinan@gmail.com>, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/carpentries-i18n/teams/98915/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

# Front Matter
#: shell-novice/404.md:1
msgid ""
"---\n"
"layout: base\n"
"root: .\n"
"permalink: 404.html\n"
"title: \"Page not found\"\n"
"---"
msgstr ""
"---\n"
"layout: base\n"
"root: .\n"
"permalink: 404.html\n"
"title: \"Сторінка не знайдена\"\n"
"---"

# header
#: shell-novice/404.md:8
msgid "# Oops! We cannot find that page."
msgstr "# Ой! Ми не можемо знайти цю сторінку."

#: shell-novice/404.md:9
msgid "{: style=\"text-align: center;\"}"
msgstr "{: style=\"text-align: center;\"}"

# blockquote, which can be cascaded
#: shell-novice/404.md:11
msgid "> ## Our apologies!"
msgstr "> ## Перепрошуємо!"

#: shell-novice/404.md:12
msgid ""
">\n"
"> We cannot seem to find the page you are looking for.\n"
"> Try going back to the <a href=\"javascript:history.back()\">previous page</a> or\n"
"> navigate to any other page using the navigation bar above\n"
"> {%- if site.kind == \"lesson\" -%} or the schedule below {%- endif -%}.\n"
"> If you got here by clicking on a link in the\n"
"> {%- if site.kind == \"lesson\" -%} lesson {%- else -%} workshop {%- endif -%},\n"
"> please report this link to the\n"
"> {%- if site.kind == \"lesson\" -%} lesson developers {%- else -%} workshop organizers {%- endif -%}."
msgstr ""
">\n"
"> Здається, ми не можемо знайти сторінку, яку ви шукаєте.\n"
"> Спробуйте повернутися на <a href=\"javascript:history.back()\">попередню сторінку</a> або\n"
"> перейти на будь-яку іншу сторінку за допомогою панелі навігації вище\n"
"> {%- if site.kind == \"lesson\" -%} або за розкладом нижче {%- endif -%}.\n"
"> Якщо ви потрапили сюди, перейшовши за посиланням у\n"
"> {%- if site.kind == \"lesson\" -%} уроці {%- else -%} семінарі {%- endif -%},\n"
"> будь ласка, повідомте про це посилання\n"
"> {%- if site.kind == \"lesson\" -%} розробникам уроку {%- else -%} організаторам семінару {%- endif -%}."

# SC/DC Template label
#: shell-novice/404.md:21
msgid "{: .caution}"
msgstr "{: .caution}"

#: shell-novice/404.md:23
msgid ""
"{% if site.kind == \"lesson\" %}\n"
"  {% include syllabus.html %}\n"
"{% endif%}"
msgstr ""
"{% if site.kind == \"lesson\" %}\n"
"  {% include syllabus.html %}\n"
"{% endif%}"

# Front Matter
#: shell-novice/CODE_OF_CONDUCT.md:1
msgid ""
"---\n"
"layout: page\n"
"title: \"Contributor Code of Conduct\"\n"
"---"
msgstr ""
"---\n"
"layout: page\n"
"title: \"Кодекс поведінки учасника проекту\"\n"
"---"

#: shell-novice/CODE_OF_CONDUCT.md:5
msgid ""
"As contributors and maintainers of this project,\n"
"we pledge to follow the [Carpentry Code of Conduct][coc]."
msgstr ""
"Як учасники та супровідники цього проєкту,\n"
"ми зобов'язуємося дотримуватися [Кодексу поведінки Carpentry][coc]."

#: shell-novice/CODE_OF_CONDUCT.md:8
msgid ""
"Instances of abusive, harassing, or otherwise unacceptable behavior\n"
"may be reported by following our [reporting guidelines][coc-reporting]."
msgstr ""
"Про випадки образливої, агресивної або іншої неприйнятної поведінки\n"
"можна повідомити, дотримуючись наших [інструкцій щодо звітування][coc-reporting]."

#: shell-novice/CODE_OF_CONDUCT.md:11
msgid ""
"[coc]: https://docs.carpentries.org/topic_folders/policies/code-of-conduct.html\n"
"[coc-reporting]: https://docs.carpentries.org/topic_folders/policies/incident-reporting.html"
msgstr ""
"[coc]: https://docs.carpentries.org/topic_folders/policies/code-of-conduct.html\n"
"[coc-reporting]: https://docs.carpentries.org/topic_folders/policies/incident-reporting.html"

# header
#: shell-novice/CONTRIBUTING.md:1
msgid "# Contributing"
msgstr "# Внески до проєкту"

#: shell-novice/CONTRIBUTING.md:3
msgid ""
"[Software Carpentry][swc-site] and [Data Carpentry][dc-site] are open source projects,\n"
"and we welcome contributions of all kinds:\n"
"new lessons,\n"
"fixes to existing material,\n"
"bug reports,\n"
"and reviews of proposed changes are all welcome."
msgstr ""
"[Software Carpentry][swc-site] та [Data Carpentry][dc-site] є проєктами з відкритим вихідним кодом,\n"
"і ми вітаємо будь-які внески:\n"
"нові уроки,\n"
"виправлення наявного матеріалу,\n"
"повідомлення про помилки\n"
"та рецензування запропонованих змін - все це вітається."

# header
#: shell-novice/CONTRIBUTING.md:10
msgid "## Contributor Agreement"
msgstr "## Угода про участь у проєкті"

#: shell-novice/CONTRIBUTING.md:12
msgid ""
"By contributing,\n"
"you agree that we may redistribute your work under [our license](LICENSE.md).\n"
"In exchange,\n"
"we will address your issues and/or assess your change proposal as promptly as we can,\n"
"and help you become a member of our community.\n"
"Everyone involved in [Software Carpentry][swc-site] and [Data Carpentry][dc-site]\n"
"agrees to abide by our [code of conduct](CONDUCT.md)."
msgstr ""
"Роблячи свій внесок,\n"
"ви погоджуєтеся, що ми можемо розповсюджувати вашу роботу на умовах [нашої ліцензії] (LICENSE.md).\n"
"В обмін на це\n"
"ми розглянемо ваші зауваження та/або оцінимо вашу пропозицію щодо змін настільки швидко, наскільки це буде можливо,\n"
"і допоможемо вам стати членом нашої спільноти.\n"
"Кожен, хто бере участь у [Software Carpentry][swc-site] та [Data Carpentry][dc-site],\n"
"погоджується дотримуватися нашого [кодексу поведінки](CONDUCT.md)."

# header
#: shell-novice/CONTRIBUTING.md:20
msgid "## How to Contribute"
msgstr "## Як зробити внесок"

#: shell-novice/CONTRIBUTING.md:22
msgid ""
"The easiest way to get started is to file an issue\n"
"to tell us about a spelling mistake,\n"
"some awkward wording,\n"
"or a factual error.\n"
"This is a good way to introduce yourself\n"
"and to meet some of our community members."
msgstr ""
"Найпростіший спосіб почати - це подати заявку про проблему,\n"
"щоб повідомити нам про орфографічну помилку,\n"
"певне некоректне формулювання\n"
"або фактичну помилку.\n"
"Це хороший спосіб заявити про себе\n"
"і познайомитися з деякими членами нашої спільноти."

# ordered list
#: shell-novice/CONTRIBUTING.md:29
msgid "1.  If you do not have a [GitHub][github] account,"
msgstr "1.  Якщо у вас немає облікового запису [GitHub][github],"

#: shell-novice/CONTRIBUTING.md:30
msgid ""
"    you can [send us comments by email][contact].\n"
"    However,\n"
"    we will be able to respond more quickly if you use one of the other methods described below."
msgstr ""
"    ви можете [надіслати нам коментарі електронною поштою][contact].\n"
"    Однак,\n"
"    ми зможемо відповісти швидше, якщо ви скористаєтеся одним з інших способів, описаних нижче."

# ordered list
#: shell-novice/CONTRIBUTING.md:34
msgid "2.  If you have a [GitHub][github] account,"
msgstr "2.  Якщо у вас є обліковий запис [GitHub][github],"

#: shell-novice/CONTRIBUTING.md:35
msgid ""
"    or are willing to [create one][github-join],\n"
"    but do not know how to use Git,\n"
"    you can report problems or suggest improvements by [creating an issue][issues].\n"
"    This allows us to assign the item to someone\n"
"    and to respond to it in a threaded discussion."
msgstr ""
"    або ви хочете [створити його][github-join],\n"
"    але не знаєте, як користуватися Git'ом,\n"
"    ви можете повідомити про проблеми або запропонувати покращення, [створивши запит][issues].\n"
"    Це дозволяє нам призначити цей запит комусь\n"
"    і відповісти на нього в потоковому обговоренні."

# ordered list
#: shell-novice/CONTRIBUTING.md:41
msgid "3.  If you are comfortable with Git,"
msgstr "3.  Якщо вам зручно працювати з Git'ом,"

#: shell-novice/CONTRIBUTING.md:42
msgid ""
"    and would like to add or change material,\n"
"    you can submit a pull request (PR).\n"
"    Instructions for doing this are [included below](#using-github)."
msgstr ""
"    і ви хотіли б додати або змінити матеріал,\n"
"    ви можете подати запит на зміни (англ. pull request, PR).\n"
"    Інструкції, як це зробити, [наведені нижче](#використання-github)."

# header
#: shell-novice/CONTRIBUTING.md:46
msgid "## Where to Contribute"
msgstr "## Де робити внески"

# ordered list
#: shell-novice/CONTRIBUTING.md:48
msgid "1.  If you wish to change this lesson,"
msgstr "1.  Якщо ви хочете змінити цей урок,"

#: shell-novice/CONTRIBUTING.md:49
msgid ""
"    please work in <https://github.com/swcarpentry/shell-novice>,\n"
"    which can be viewed at <https://swcarpentry.github.io/shell-novice>."
msgstr ""
"    будь ласка, працюйте в <https://github.com/swcarpentry/shell-novice>,\n"
"    який можна переглянути на <https://swcarpentry.github.io/shell-novice>."

# ordered list
#: shell-novice/CONTRIBUTING.md:52
msgid "2.  If you wish to change the example lesson,"
msgstr "2.  Якщо ви бажаєте змінити шаблон уроку,"

#: shell-novice/CONTRIBUTING.md:53
msgid ""
"    please work in <https://github.com/carpentries/lesson-example>,\n"
"    which documents the format of our lessons\n"
"    and can be viewed at <https://carpentries.github.io/lesson-example>."
msgstr ""
"    будь ласка, працюйте в <https://github.com/carpentries/lesson-example>,\n"
"    який документує формат наших уроків,\n"
"    і з яким можна ознайомитись за посиланням <https://carpentries.github.io/lesson-example>."

# ordered list
#: shell-novice/CONTRIBUTING.md:57
msgid "3.  If you wish to change the template used for workshop websites,"
msgstr ""
"3.  Якщо ви бажаєте змінити шаблон, який використовується для веб-сайтів "
"семінарів,"

#: shell-novice/CONTRIBUTING.md:58
msgid ""
"    please work in <https://github.com/carpentries/workshop-template>.\n"
"    The home page of that repository explains how to set up workshop websites,\n"
"    while the extra pages in <https://carpentries.github.io/workshop-template>\n"
"    provide more background on our design choices."
msgstr ""
"    будь ласка, працюйте в <https://github.com/carpentries/workshop-template>.\n"
"    На головній сторінці цього репозиторію пояснюється, як налаштувати веб-сайти семінарів,\n"
"    а додаткові сторінки у <https://carpentries.github.io/workshop-template>\n"
"    надають більше інформації про наш вибір дизайну."

# ordered list
#: shell-novice/CONTRIBUTING.md:63
msgid "4.  If you wish to change CSS style files, tools,"
msgstr "4. Якщо ви хочете змінити файли стилів CSS, інструменти,"

#: shell-novice/CONTRIBUTING.md:64
msgid ""
"    or HTML boilerplate for lessons or workshops stored in `_includes` or `_layouts`,\n"
"    please work in <https://github.com/carpentries/styles>."
msgstr ""
"    або HTML-шаблон для уроків чи семінарів, що зберігаються в `_includes` або `_layouts`,\n"
"    будь ласка, працюйте в <https://github.com/carpentries/styles>."

# header
#: shell-novice/CONTRIBUTING.md:67
msgid "## What to Contribute"
msgstr "## Які внески робити"

#: shell-novice/CONTRIBUTING.md:69
msgid ""
"There are many ways to contribute,\n"
"from writing new exercises and improving existing ones\n"
"to updating or filling in the documentation\n"
"and submitting [bug reports][issues]\n"
"about things that don't work, aren't clear, or are missing.\n"
"If you are looking for ideas,\n"
"please see [the list of issues for this repository][issues],\n"
"or the issues for [Data Carpentry][dc-issues]\n"
"and [Software Carpentry][swc-issues] projects."
msgstr ""
"Існує багато способів зробити свій внесок,\n"
"від написання нових вправ та покращення тих, що вже існують,\n"
"до оновлення або додавання документації\n"
"та подання [звітів про помилки][issues]\n"
"про речі, які не працюють, незрозумілі або відсутні.\n"
"Якщо ви шукаєте ідеї,\n"
"будь ласка, перегляньте [перелік проблем для цього репозиторію][issues],\n"
"або перелік проблем для проєктів [Data Carpentry][dc-issues]\n"
"та [Software Carpentry][swc-issues]."

#: shell-novice/CONTRIBUTING.md:79
msgid ""
"Comments on issues and reviews of pull requests are just as welcome:\n"
"we are smarter together than we are on our own.\n"
"Reviews from novices and newcomers are particularly valuable:\n"
"it's easy for people who have been using these lessons for a while\n"
"to forget how impenetrable some of this material can be,\n"
"so fresh eyes are always welcome."
msgstr ""
"Також вітаються коментарі щодо проблем та рецензування запитів на зміни:\n"
"разом ми розумніші, ніж поодинці.\n"
"Особливо цінні відгуки від початковців і новоприбулих:\n"
"людям, які користуються цими уроками вже деякий час, легко\n"
"забути, наскільки непроникним може бути деякий матеріал,\n"
"тому свіжий погляд завжди вітається."

# header
#: shell-novice/CONTRIBUTING.md:86
msgid "## What *Not* to Contribute"
msgstr "## Які внески *не слід* робити"

#: shell-novice/CONTRIBUTING.md:88
msgid ""
"Our lessons already contain more material than we can cover in a typical workshop,\n"
"so we are usually *not* looking for more concepts or tools to add to them.\n"
"As a rule,\n"
"if you want to introduce a new idea,\n"
"you must (a) estimate how long it will take to teach\n"
"and (b) explain what you would take out to make room for it.\n"
"The first encourages contributors to be honest about requirements;\n"
"the second, to think hard about priorities."
msgstr ""
"Наші уроки вже містять більше матеріалу, ніж ми можемо охопити на типовому семінарі,\n"
"тому ми зазвичай *не* шукаємо більше понять чи інструментів, щоб додати до уроків.\n"
"Як правило,\n"
"якщо ви хочете представити нову ідею,\n"
"ви повинні (а) оцінити, скільки часу знадобиться на викладання\n"
"і (б) пояснити, що ви вилучите, щоб звільнити місце для цього.\n"
"Перше заохочує авторів бути чесними щодо вимог;\n"
"друге - добре подумати про пріоритети."

#: shell-novice/CONTRIBUTING.md:97
msgid ""
"We are also not looking for exercises or other material that only run on one platform.\n"
"Our workshops typically contain a mixture of Windows, macOS, and Linux users;\n"
"in order to be usable,\n"
"our lessons must run equally well on all three."
msgstr ""
"Ми також не шукаємо завдання чи інші матеріали, які працюють лише на одній платформі.\n"
"На наших семінарах зазвичай присутні користувачі Windows, macOS та Linux;\n"
"для того, щоб бути корисними,\n"
"наші уроки повинні однаково добре працювати на всіх трьох платформах."

# header
#: shell-novice/CONTRIBUTING.md:102
msgid "## Using GitHub"
msgstr "## Використання GitHub"

#: shell-novice/CONTRIBUTING.md:104
msgid ""
"If you choose to contribute via GitHub,\n"
"you may want to look at\n"
"[How to Contribute to an Open Source Project on GitHub][how-contribute].\n"
"In brief:"
msgstr ""
"Якщо ви вирішили зробити свій внесок через GitHub,\n"
"вам варто ознайомитися зі статтею\n"
"[Як зробити внесок у проект з відкритим вихідним кодом на GitHub][how-contribute].\n"
"Якщо коротко:"

# ordered list
#: shell-novice/CONTRIBUTING.md:109
msgid ""
"1.  The published copy of the lesson is in the `gh-pages` branch of the "
"repository"
msgstr ""
"1.  Опублікована копія уроку знаходиться у гілці `gh-pages` репозиторію"

#: shell-novice/CONTRIBUTING.md:110
msgid ""
"    (so that GitHub will regenerate it automatically).\n"
"    Please create all branches from that,\n"
"    and merge the [master repository][repo]'s `gh-pages` branch into your `gh-pages` branch\n"
"    before starting work.\n"
"    Please do *not* work directly in your `gh-pages` branch,\n"
"    since that will make it difficult for you to work on other contributions."
msgstr ""
"    (для того, щоб GitHub автоматично згенерував урок).\n"
"    Будь ласка, створюйте всі гілки звідти,\n"
"    і об'єднайте гілку `gh-pages` [головного репозиторію][repo] з вашою гілкою `gh-pages`\n"
"    перед початком роботи.\n"
"    Будь ласка, *не* працюйте безпосередньо у вашій гілці `gh-pages`,\n"
"    оскільки це може ускладнити вашу роботу над іншими внесками."

# ordered list
#: shell-novice/CONTRIBUTING.md:117
msgid "2.  We use [GitHub flow][github-flow] to manage changes:"
msgstr ""
"2.  Ми використовуємо [GitHub flow][github-flow] для керування змінами:"

#: shell-novice/CONTRIBUTING.md:118
msgid ""
"    1.  Create a new branch in your desktop copy of this repository for each significant change.\n"
"    2.  Commit the change in that branch.\n"
"    3.  Push that branch to your fork of this repository on GitHub.\n"
"    4.  Submit a pull request from that branch to the [master repository][repo].\n"
"    5.  If you receive feedback,\n"
"        make changes on your desktop and push to your branch on GitHub:\n"
"        the pull request will update automatically."
msgstr ""
"    1.  Створюйте нову гілку у вашій копії цього репозиторію для кожної значної зміни.\n"
"    2.  Зафіксуйте зміни у цій гілці.\n"
"    3.  Перенесіть цю гілку до вашого розгалуження цього репозиторію на GitHub.\n"
"    4.  Надішліть запит на зміни з цієї гілки до [головного репозиторію][repo].\n"
"    5.  Якщо ви отримаєте зворотній зв'язок,\n"
"        внесіть зміни в локальній копії та перенесіть до своєї гілки на GitHub:\n"
"        запит на зміни буде оновлено автоматично."

#: shell-novice/CONTRIBUTING.md:126
msgid ""
"Each lesson has two maintainers who review issues and pull requests\n"
"or encourage others to do so.\n"
"The maintainers are community volunteers,\n"
"and have final say over what gets merged into the lesson."
msgstr ""
"За кожний урок відповідають два супровідника, які переглядають проблеми і задовільняють запити на зміни\n"
"або заохочують до цього інших.\n"
"Супровідники є волонтерами спільноти,\n"
"і мають вирішальне слово щодо того, що буде додано до уроку."

# header
#: shell-novice/CONTRIBUTING.md:131
msgid "## Other Resources"
msgstr "## Інші ресурси"

#: shell-novice/CONTRIBUTING.md:133
msgid ""
"General discussion of [Software Carpentry][swc-site] and [Data Carpentry][dc-site]\n"
"happens on the [discussion mailing list][discuss-list],\n"
"which everyone is welcome to join.\n"
"You can also [reach us by email][contact]."
msgstr ""
"Загальне обговорення [Software Carpentry][swc-site] та [Data Carpentry][dc-site]\n"
"відбувається у [дискусійному списку розсилки][discuss-list],\n"
"до якого може приєднатися кожен охочий.\n"
"Ви також можете [зв'язатися з нами електронною поштою][contact]."

#: shell-novice/CONTRIBUTING.md:138
msgid ""
"[contact]: mailto:admin@software-carpentry.org\n"
"[dc-issues]: https://github.com/issues?q=user%3Adatacarpentry\n"
"[dc-lessons]: http://datacarpentry.org/lessons/\n"
"[dc-site]: http://datacarpentry.org/\n"
"[discuss-list]: https://carpentries.topicbox.com/groups/discuss\n"
"[github]: http://github.com\n"
"[github-flow]: https://guides.github.com/introduction/flow/\n"
"[github-join]: https://github.com/join\n"
"[how-contribute]: https://egghead.io/series/how-to-contribute-to-an-open-source-project-on-github\n"
"[issues]: https://github.com/swcarpentry/shell-novice/issues/\n"
"[repo]: https://github.com/swcarpentry/shell-novice/\n"
"[swc-issues]: https://github.com/issues?q=user%3Aswcarpentry\n"
"[swc-lessons]: http://software-carpentry.org/lessons/\n"
"[swc-site]: http://software-carpentry.org/"
msgstr ""
"[contact]: mailto:admin@software-carpentry.org\n"
"[dc-issues]: https://github.com/issues?q=user%3Adatacarpentry\n"
"[dc-lessons]: http://datacarpentry.org/lessons/\n"
"[dc-site]: http://datacarpentry.org/\n"
"[discuss-list]: https://carpentries.topicbox.com/groups/discuss\n"
"[github]: http://github.com\n"
"[github-flow]: https://guides.github.com/introduction/flow/\n"
"[github-join]: https://github.com/join\n"
"[how-contribute]: https://egghead.io/series/how-to-contribute-to-an-open-source-project-on-github\n"
"[issues]: https://github.com/swcarpentry/shell-novice/issues/\n"
"[repo]: https://github.com/swcarpentry/shell-novice/\n"
"[swc-issues]: https://github.com/issues?q=user%3Aswcarpentry\n"
"[swc-lessons]: http://software-carpentry.org/lessons/\n"
"[swc-site]: http://software-carpentry.org/"

# Front Matter
#: shell-novice/LICENSE.md:1
msgid ""
"---\n"
"layout: page\n"
"title: \"Licenses\"\n"
"root: .\n"
"---"
msgstr ""
"---\n"
"layout: page\n"
"title: \"Ліцензії\"\n"
"root: .\n"
"---"

# header
#: shell-novice/LICENSE.md:6
msgid "## Instructional Material"
msgstr "## Навчальні матеріали"

#: shell-novice/LICENSE.md:8
msgid ""
"All Software Carpentry, Data Carpentry, and Library Carpentry instructional material is\n"
"made available under the [Creative Commons Attribution\n"
"license][cc-by-human]. The following is a human-readable summary of\n"
"(and not a substitute for) the [full legal text of the CC BY 4.0\n"
"license][cc-by-legal]."
msgstr ""
"Усі навчальні матеріали Software Carpentry, Data Carpentry та Library Carpentry\n"
"доступні на умовах [Creative Commons Attribution\n"
"ліцензії][cc-by-human]. Нижче наведено придатний для читання людиною короткий виклад\n"
"(а не заміна) [повного юридичного тексту ліцензії CC BY 4.0][cc-by-legal]."

#: shell-novice/LICENSE.md:14
msgid "You are free:"
msgstr "Ви можете вільно:"

# unordered list
#: shell-novice/LICENSE.md:16
msgid ""
"* to **Share**---copy and redistribute the material in any medium or format"
msgstr ""
"* **Поширювати**---копіювати і розповсюджувати матеріал у будь-якому вигляді"
" чи форматі"

# unordered list
#: shell-novice/LICENSE.md:17
msgid "* to **Adapt**---remix, transform, and build upon the material"
msgstr ""
"* **Змінювати**---реміксувати, трансформувати, і брати матеріал за основу"

#: shell-novice/LICENSE.md:19
msgid "for any purpose, even commercially."
msgstr "для будь-яких цілей, навіть комерційних."

#: shell-novice/LICENSE.md:21
msgid ""
"The licensor cannot revoke these freedoms as long as you follow the\n"
"license terms."
msgstr ""
"Ліцензіар не може відкликати ці дозволи поки ви дотримуєтесь\n"
"умов ліцензії."

#: shell-novice/LICENSE.md:24
msgid "Under the following terms:"
msgstr "На наступних умовах:"

# unordered list
#: shell-novice/LICENSE.md:26
msgid "* **Attribution**---You must give appropriate credit (mentioning that"
msgstr "* **Зазначення Авторства**---Ви маєте вказати автора (зазначивши, що"

#: shell-novice/LICENSE.md:27
msgid ""
"  your work is derived from work that is Copyright © Software\n"
"  Carpentry and, where practical, linking to\n"
"  http://software-carpentry.org/), provide a [link to the\n"
"  license][cc-by-human], and indicate if changes were made. You may do\n"
"  so in any reasonable manner, but not in any way that suggests the\n"
"  licensor endorses you or your use."
msgstr ""
"  ваша робота є похідною від роботи, захищеної авторським правом © Software\n"
"  Carpentry, та, де це можливо, зробити посилання на\n"
"  http://software-carpentry.org/), розмістити [посилання на\n"
"  ліцензію][cc-by-human] і вказати чи було внесено зміни. Ви можете зробити\n"
"  це у будь-який розумний спосіб, але так, щоб не створювати враження стосовно того,\n"
"  що ліцензіар підтримує чи схвалює вас або ваше використання твору."

#: shell-novice/LICENSE.md:34
msgid ""
"**No additional restrictions**---You may not apply legal terms or\n"
"technological measures that legally restrict others from doing\n"
"anything the license permits.  With the understanding that:"
msgstr ""
"**Без додаткових обмежень**---Ви не можете висувати додаткові умови або\n"
"застосовувати технологічні засоби захисту, що обмежують права інших\n"
"на дії, дозволені ліцензією. З розумінням того, що:"

#: shell-novice/LICENSE.md:38
msgid "Notices:"
msgstr "Примітки:"

# unordered list
#: shell-novice/LICENSE.md:40
msgid "* You do not have to comply with the license for elements of the"
msgstr "* Ви можете не дотримуватись умов ліцензії в частині,"

#: shell-novice/LICENSE.md:41
msgid ""
"  material in the public domain or where your use is permitted by an\n"
"  applicable exception or limitation.\n"
"* No warranties are given. The license may not give you all of the\n"
"  permissions necessary for your intended use. For example, other\n"
"  rights such as publicity, privacy, or moral rights may limit how you\n"
"  use the material."
msgstr ""
"  що стосується частин матеріалу, котрі знаходяться у суспільному надбанні, або коли ваше використання дозволене\n"
"  застосовними виключеннями та обмеженнями авторського права.\n"
"* Не надається жодних гарантій. Ліцензія може не надавати всіх\n"
"  необхідних дозволів, необхідних для вашого використання матеріалу. Наприклад, інші\n"
"  права, такі як право на зображення особи, на приватне життя або особисті немайнові права можуть обмежувати ваші\n"
"  можливості використовувати матеріал."

# header
#: shell-novice/LICENSE.md:48
msgid "## Software"
msgstr "## Програмне забезпечення"

#: shell-novice/LICENSE.md:50
msgid ""
"Except where otherwise noted, the example programs and other software\n"
"provided by Software Carpentry and Data Carpentry are made available under the\n"
"[OSI][osi]-approved\n"
"[MIT license][mit-license]."
msgstr ""
"Якщо не зазначено інше, приклади програм та інше програмне забезпечення\n"
"надані Software Carpentry та Data Carpentry, доступні відповідно до\n"
"[OSI][osi]-затвердженої\n"
"[ліцензії MIT][mit-license]."

#: shell-novice/LICENSE.md:55
msgid ""
"Permission is hereby granted, free of charge, to any person obtaining\n"
"a copy of this software and associated documentation files (the\n"
"\"Software\"), to deal in the Software without restriction, including\n"
"without limitation the rights to use, copy, modify, merge, publish,\n"
"distribute, sublicense, and/or sell copies of the Software, and to\n"
"permit persons to whom the Software is furnished to do so, subject to\n"
"the following conditions:"
msgstr ""
"Дозвіл надається безкоштовно будь-якій особі, яка отримує\n"
"копію цього програмного забезпечення та пов'язаних з ним файлів документації\n"
"(\"Програмне забезпечення\"), мати справу з Програмним забезпеченням без обмежень, включаючи\n"
"відсутність обмежень прав на використання, копіювання, модифікацію, об'єднання, публікацію,\n"
"розповсюдження, субліцензування та/або продаж копії Програмного забезпечення, а також\n"
"дозволяти особам, яким надається Програмне забезпечення, робити це, відповідно до\n"
"наступних умов:"

#: shell-novice/LICENSE.md:63
msgid ""
"The above copyright notice and this permission notice shall be\n"
"included in all copies or substantial portions of the Software."
msgstr ""
"Наведене вище повідомлення про авторські права і це повідомлення про дозвіл повинні бути\n"
"включені до всіх копій або значних частин Програми."

#: shell-novice/LICENSE.md:66
msgid ""
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
"EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
"MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
"NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n"
"LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n"
"OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n"
"WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
msgstr ""
"ПРОГРАМНЕ ЗАБЕЗПЕЧЕННЯ НАДАЄТЬСЯ \"ЯК Є\", БЕЗ БУДЬ-ЯКИХ ГАРАНТІЙ,\n"
"ЯВНИХ АБО НЕЯВНИХ, ВКЛЮЧАЮЧИ, АЛЕ НЕ ОБМЕЖУЮЧИСЬ ГАРАНТІЯМИ\n"
"ПРИДАТНОСТІ ДЛЯ ПРОДАЖУ, ПРИДАТНОСТІ ДЛЯ ПЕВНОЇ МЕТИ ТА\n"
"НЕПОРУШЕННЯ АВТОРСЬКИХ ПРАВ. ЗА ЖОДНИХ ОБСТАВИН АВТОРИ АБО ВЛАСНИКИ АВТОРСЬКИХ ПРАВ\n"
"НЕ НЕСУТЬ ВІДПОВІДАЛЬНОСТІ ЗА БУДЬ-ЯКІ ПРЕТЕНЗІЇ, ЗБИТКИ АБО ІНШУ ВІДПОВІДАЛЬНІСТЬ, ЧИ ТО В РАМКАХ,\n"
"ДОГОВОРУ, ДЕЛІКТУ АБО ІНШИМ ЧИНОМ, ЩО ВИНИКАЮТЬ З, ВНАСЛІДОК АБО У ЗВ'ЯЗКУ З\n"
"ПРОГРАМНИМ ЗАБЕЗПЕЧЕННЯМ, ЙОГО ВИКОРИСТАННЯМ АБО ІНШИМИ ОПЕРАЦІЯМИ З ПРОГРАМНИМ ЗАБЕЗПЕЧЕННЯМ."

# header
#: shell-novice/LICENSE.md:74
msgid "## Trademark"
msgstr "## Торговельна марка"

#: shell-novice/LICENSE.md:76
msgid ""
"\"Software Carpentry\" and \"Data Carpentry\" and their respective logos\n"
"are registered trademarks of [Community Initiatives][CI]."
msgstr ""
"«Software Carpentry» та «Data Carpentry» та їхні відповідні логотипи\n"
"є зареєстрованими торговими марками [Community Initiatives][CI]."

#: shell-novice/LICENSE.md:79
msgid ""
"[cc-by-human]: https://creativecommons.org/licenses/by/4.0/\n"
"[cc-by-legal]: https://creativecommons.org/licenses/by/4.0/legalcode\n"
"[mit-license]: https://opensource.org/licenses/mit-license.html\n"
"[ci]: http://communityin.org/\n"
"[osi]: https://opensource.org"
msgstr ""
"[cc-by-human]: https://creativecommons.org/licenses/by/4.0/\n"
"[cc-by-legal]: https://creativecommons.org/licenses/by/4.0/legalcode\n"
"[mit-license]: https://opensource.org/licenses/mit-license.html\n"
"[ci]: http://communityin.org/\n"
"[osi]: https://opensource.org"

#: shell-novice/README.md:1
msgid ""
"[![Create a Slack Account with us][create_slack_svg]][slack_invite]\n"
"[![Slack Status][slack_status_svg]][slack_status]\n"
"[![DOI][doi_svg]][doi]"
msgstr ""
"[![Create a Slack Account with us][create_slack_svg]][slack_invite]\n"
"[![Slack Status][slack_status_svg]][slack_status]\n"
"[![DOI][doi_svg]][doi]"

#: shell-novice/README.md:5
msgid ""
"shell-novice\n"
"============"
msgstr ""
"shell-novice\n"
"============"

#: shell-novice/README.md:8
msgid ""
"An introduction to the Unix shell for people who have never used the command line before.\n"
"Please see <https://swcarpentry.github.io/shell-novice/> for a rendered version of this material,\n"
"[the lesson template documentation][lesson-example]\n"
"for instructions on formatting, building, and submitting material,\n"
"or run `make` in this directory for a list of helpful commands."
msgstr ""
"Знайомство з терміналом Unix для тих, хто ніколи раніше не користувався командним рядком.\n"
"Будь ласка, зверніться до <https://swcarpentry.github.io/shell-novice/>, щоб переглянути візаулізовану версію цього матеріалу,\n"
"[документацію до шаблону уроків][lesson-example]\n"
"для отримання інструкцій щодо форматування, створення та надсилання матеріалу,\n"
"або виконайте `make` у цьому каталозі для отримання списку корисних команд."

# header
#: shell-novice/README.md:14
msgid "## Maintainers"
msgstr "## Супровідники"

# unordered list
#: shell-novice/README.md:16
msgid "* [Gerard Capes][gerard_capes]"
msgstr "* [Gerard Capes][gerard_capes]"

# unordered list
#: shell-novice/README.md:17
msgid "* [Jacob Deppen][jacob_deppen]"
msgstr "* [Jacob Deppen][jacob_deppen]"

# unordered list
#: shell-novice/README.md:18
msgid "* [Benson Muite][benson_muite]"
msgstr "* [Benson Muite][benson_muite]"

# header
#: shell-novice/README.md:20
msgid "## Contributing"
msgstr "## Внески до проєкту"

#: shell-novice/README.md:22
msgid ""
"If you would like to contribute to the development of the lesson, you can find details in our\n"
"[CONTRIBUTING guide](https://github.com/swcarpentry/shell-novice/blob/gh-pages/CONTRIBUTING.md).\n"
"Contributions can come in many different forms: typo and formatting fixes, additions or subtractions\n"
"of content, suggestions, clarifications, and more."
msgstr ""
"Якщо ви хочете зробити свій внесок у розробку уроку, ви можете знайти деталі в нашому\n"
"[Посібник для виконання внесків] (https://github.com/swcarpentry/shell-novice/blob/gh-pages/CONTRIBUTING.md).\n"
"Внесок може бути у різних формах: виправлення помилок і форматування, додавання або вилучення\n"
"змісту, пропозиції, роз'яснення тощо."

#: shell-novice/README.md:27
msgid ""
"[gerard_capes]: https://carpentries.org/instructors/#capes_gerard\n"
"[jacob_deppen]: https://deppen8.github.io/\n"
"[benson_muite]: https://carpentries.org/instructors/#benson_muite\n"
"[lesson-example]: https://carpentries.github.io/lesson-example/\n"
"[create_slack_svg]: https://img.shields.io/badge/Create_Slack_Account-The_Carpentries-071159.svg\n"
"[slack_invite]: https://swc-slack-invite.herokuapp.com/\n"
"[slack_status]: https://swcarpentry.slack.com/messages/C9X3XTHJ8\n"
"[slack_status_svg]: https://img.shields.io/badge/Slack_Channel-swc--shell-E01563.svg\n"
"[doi]: https://doi.org/10.5281/zenodo.3266823\n"
"[doi_svg]: https://zenodo.org/badge/DOI/10.5281/zenodo.3266823.svg"
msgstr ""
"[gerard_capes]: https://carpentries.org/instructors/#capes_gerard\n"
"[jacob_deppen]: https://deppen8.github.io/\n"
"[benson_muite]: https://carpentries.org/instructors/#benson_muite\n"
"[lesson-example]: https://carpentries.github.io/lesson-example/\n"
"[create_slack_svg]: https://img.shields.io/badge/Create_Slack_Account-The_Carpentries-071159.svg\n"
"[slack_invite]: https://swc-slack-invite.herokuapp.com/\n"
"[slack_status]: https://swcarpentry.slack.com/messages/C9X3XTHJ8\n"
"[slack_status_svg]: https://img.shields.io/badge/Slack_Channel-swc--shell-E01563.svg\n"
"[doi]: https://doi.org/10.5281/zenodo.3266823\n"
"[doi_svg]: https://zenodo.org/badge/DOI/10.5281/zenodo.3266823.svg"

# Front Matter
#: shell-novice/_episodes/01-intro.md:1
msgid ""
"---\n"
"title: \"Introducing the Shell\"\n"
"teaching: 5\n"
"exercises: 0\n"
"questions:\n"
"- \"What is a command shell and why would I use one?\"\n"
"objectives:\n"
"- \"Explain how the shell relates to the keyboard, the screen, the operating system, and users' programs.\"\n"
"- \"Explain when and why command-line interfaces should be used instead of graphical interfaces.\"\n"
"keypoints:\n"
"- \"A shell is a program whose primary purpose is to read commands and run other programs.\"\n"
"-  \"This lesson uses Bash, the default shell in many implementations of Unix.\"\n"
"-  \"Programs can be run in Bash by entering commands at the command-line prompt.\"\n"
"- \"The shell's main advantages are its high action-to-keystroke ratio, its support for\n"
"automating repetitive tasks, and its capacity to access networked machines.\"\n"
"- \"The shell's main disadvantages are its primarily textual nature and how\n"
"cryptic its commands and operation can be.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Знайомство з терміналом\"\n"
"teaching: 5\n"
"exercises: 0\n"
"questions:\n"
"- \"Що таке командний термінал і навіщо його використовувати?\"\n"
"objectives:\n"
"- \"Пояснити, як термінал пов'язаний з клавіатурою, екраном, операційною системою та програмами користувача\".\n"
"- \"Пояснити, коли і чому інтерфейси командного рядка слід використовувати замість графічних інтерфейсів\".\n"
"keypoints:\n"
"- \"Термінал - це програма, основним призначенням якої є читання команд і запуск інших програм\".\n"
"- \"У цьому уроці використовується Bash, термінал за замовчуванням у багатьох реалізаціях Unix\".\n"
"- \"Програми можна запускати у Bash, вводячи команди у вікні командного рядка\".\n"
"- \"Основними перевагами терміналу є високе співвідношення кількості дій до кількості натискань клавіш, підтримка автоматизації повторюваних завдань\n"
"а також можливість доступу до мережевих машин\".\n"
"- \"Основними недоліками терміналу є його переважно текстова природа, а також\n"
"наскільки складними можуть бути її команди та робота\".\n"
"---"

# header
#: shell-novice/_episodes/01-intro.md:19
msgid "### Background"
msgstr "### Попередні знання"

#: shell-novice/_episodes/01-intro.md:21
msgid ""
"Humans and computers commonly interact in many different ways, such as through a keyboard and mouse,\n"
"touch screen interfaces, or using speech recognition systems.\n"
"The most widely used way to interact with personal computers is called a\n"
"**graphical user interface** (GUI).\n"
"With a GUI, we give instructions by clicking a mouse and using menu-driven interactions."
msgstr ""
"Люди та комп’ютери зазвичай взаємодіють багатьма різними способами, наприклад за допомогою клавіатури та миші,\n"
"сенсорного екрану або системи розпізнавання мови.\n"
"Найбільш поширений спосіб взаємодії з персональними комп’ютерами називається \n"
"**графічний інтерфейс користувача** (GUI - graphical user interface).\n"
"За допомогою такого інтерфейсу ми надаємо комп’ютеру інструкції, обираючи дію у меню за допомогою миші."

#: shell-novice/_episodes/01-intro.md:27
msgid ""
"While the visual aid of a GUI makes it intuitive to learn,\n"
"this way of delivering instructions to a computer scales very poorly.\n"
"Imagine the following task:\n"
"for a literature search, you have to copy the third line of one thousand text files in one thousand\n"
"different directories and paste it into a single file.\n"
"Using a GUI, you would not only be clicking at your desk for several hours,\n"
"but you could potentially also commit an error in the process of completing this repetitive task.\n"
"This is where we take advantage of the Unix shell.\n"
"The Unix shell is both a **command-line interface** (CLI) and a scripting language,\n"
"allowing such repetitive tasks to be done automatically and fast.\n"
"With the proper commands, the shell can repeat tasks with or without some modification\n"
"as many times as we want.\n"
"Using the shell, the task in the literature example can be accomplished in seconds."
msgstr ""
"Хоча візуальна допомога графічного інтерфейсу користувача робить інтуітивним його вивчення,\n"
"такий спосіб надсилання інструкцій до комп'ютера дуже погано масштабується.\n"
"Уявіть наступну задачу:\n"
"для бібліографічного пошуку вам необхідно скопіювати третю строку з тисячі вхідних файлів з тисячі\n"
"різних директорій та вставити в один файл.\n"
"Використовуючи графічний інтерфейс, ви б не тільки клікали на свому робочому місці декілька годин,\n"
"але й могли б потенційно також внести помилку в процесі виконання монотоної задачі.\n"
"Ось де ми скористаємося перевагами терміналу Unix.\n"
"Термінал Unix - це одночасно **інтерфейс командного рядка** (англ. \"Command-Line Interface\", CLI) та  скриптова мова програмування,\n"
"яка дозволяє подібні повторювальні задачі виконувати автоматично та швидко.\n"
"За допомогою відповідних команд термінал може повторювати задачі із певними змінами або без них\n"
"стільки разів, скільки ми бажаємо.\n"
"Із використанням терміналу приклад задачі з бібліографічним пошуком може бути вирішений за секунди."

# header
#: shell-novice/_episodes/01-intro.md:42
msgid "### The Shell"
msgstr "### Термінал"

#: shell-novice/_episodes/01-intro.md:45
msgid ""
"The shell is a program where users can type commands.\n"
"With the shell, it's possible to invoke complicated programs like climate modeling software\n"
"or simple commands that create an empty directory with only one line of code.\n"
"The most popular Unix shell is Bash (the Bourne Again SHell ---\n"
"so-called because it's derived from a shell written by Stephen Bourne).\n"
"Bash is the default shell on most modern implementations of Unix and in most packages that provide\n"
"Unix-like tools for Windows."
msgstr ""
"Термінал - це програма, де користувач може вводити команди.\n"
"За допомогою терміналу можна запускати як складні програми, такі як програмне забезпечення для моделювання клімату,\n"
"так і прості команди, які створюють пустий каталог, лише одним рядком коду.\n"
"Найбільш популярним терміналом є Bash (the Bourne Again SHell, \n"
"який отримав таку назву, тому що був розроблений на основі терміналу, написаного Стівеном Борном).\n"
"Bash є терміналом за замовчуванням в більшості сучасних реалізацій Unix та в більшості пакетів, що надають\n"
"Unix-подібні інструменти для Windows."

#: shell-novice/_episodes/01-intro.md:53
msgid ""
"Using the shell will take some effort and some time to learn.\n"
"While a GUI presents you with choices to select, CLI choices are not automatically presented to you,\n"
"so you must learn a few commands like new vocabulary in a language you're studying.\n"
"However, unlike a spoken language, a small number of \"words\" (i.e. commands) gets you a long way,\n"
"and we'll cover those essential few today."
msgstr ""
"Використання оболонки потребує певних зусиль і часу для вивчення.\n"
"У той час як графічний інтерфейс надає вам можливість вибору, команди терміналу не надаються автоматично,\n"
"тому вам доведеться вивчити кілька команд, як нову лексику у мові, яку ви вивчаєте.\n"
"Однак, на відміну від розмовної мови, невелика кількість \"слів\" (тобто команд) допоможе вам пройти довгий шлях,\n"
"і сьогодні ми розглянемо кілька найважливіших з них."

#: shell-novice/_episodes/01-intro.md:59
msgid ""
"The grammar of a shell allows you to combine existing tools into powerful\n"
"pipelines and handle large volumes of data automatically. Sequences of\n"
"commands can be written into a *script*, improving the reproducibility of\n"
"workflows."
msgstr ""
"Граматика терміналу дозволяє комбінувати наявні інструменти у потужні\n"
"конвеєри та автоматично обробляти великі обсяги даних. Послідовності\n"
"команд можуть бути записані у \"скрипт\", покращуючи відтворюваність\n"
"послідовностей дій."

#: shell-novice/_episodes/01-intro.md:64
msgid ""
"In addition, the command line is often the easiest way to interact with remote machines\n"
"and supercomputers.\n"
"Familiarity with the shell is near essential to run a variety of specialized tools and resources\n"
"including high-performance computing systems.\n"
"As clusters and cloud computing systems become more popular for scientific data crunching,\n"
"being able to interact with the shell is becoming a necessary skill.\n"
"We can build on the command-line skills covered here\n"
"to tackle a wide range of scientific questions and computational challenges."
msgstr ""
"На додаток, командний рядок часто є найпростішим способом взаємодії з віддаленими машинами\n"
"та суперкомп'ютерами.\n"
"Ознайомлення з терміналом є майже необхідним для запуску різноманітних спеціалізованих інструментів і ресурсів\n"
"в тому числі надпродуктивних комп'ютерних систем.\n"
"Оскільки кластери та хмарні обчислювальні системи стають все більш популярними для обробки наукових даних,\n"
"вміння взаємодіяти з терміналом стає необхідною навичкою.\n"
"Ми можемо розвивати навички роботи з командним рядком, описані тут,\n"
"для вирішення широкого кола наукових питань і обчислювальних проблем."

#: shell-novice/_episodes/01-intro.md:73
msgid "Let's get started."
msgstr "Отже, почнемо."

#: shell-novice/_episodes/01-intro.md:75
msgid ""
"When the shell is first opened, you are presented with a **prompt**,\n"
"indicating that the shell is waiting for input."
msgstr ""
"Коли термінал тільки відкрито, вам пропонується **запрошення** (англ. \"prompt\"),\n"
"яке вказує на те, що термінал очікує на введення команд."

# code block
#: shell-novice/_episodes/01-intro.md:78
#: shell-novice/_episodes/03-create.md:376
msgid ""
"~~~\n"
"$\n"
"~~~"
msgstr ""
"~~~\n"
"$\n"
"~~~"

#: shell-novice/_episodes/01-intro.md:81
#: shell-novice/_episodes/01-intro.md:101
#: shell-novice/_episodes/02-filedir.md:50
#: shell-novice/_episodes/02-filedir.md:137
#: shell-novice/_episodes/02-filedir.md:163
#: shell-novice/_episodes/02-filedir.md:212
#: shell-novice/_episodes/02-filedir.md:342
#: shell-novice/_episodes/02-filedir.md:376
#: shell-novice/_episodes/02-filedir.md:404
#: shell-novice/_episodes/02-filedir.md:420
#: shell-novice/_episodes/02-filedir.md:430
#: shell-novice/_episodes/02-filedir.md:444
#: shell-novice/_episodes/02-filedir.md:464
#: shell-novice/_episodes/02-filedir.md:476
#: shell-novice/_episodes/02-filedir.md:489
#: shell-novice/_episodes/02-filedir.md:528
#: shell-novice/_episodes/02-filedir.md:535
#: shell-novice/_episodes/02-filedir.md:552
#: shell-novice/_episodes/02-filedir.md:579
#: shell-novice/_episodes/02-filedir.md:589
#: shell-novice/_episodes/02-filedir.md:729
#: shell-novice/_episodes/02-filedir.md:757
#: shell-novice/_episodes/02-filedir.md:772
#: shell-novice/_episodes/02-filedir.md:786
#: shell-novice/_episodes/02-filedir.md:824
#: shell-novice/_episodes/02-filedir.md:833
#: shell-novice/_episodes/02-filedir.md:841
#: shell-novice/_episodes/02-filedir.md:854
#: shell-novice/_episodes/03-create.md:38
#: shell-novice/_episodes/03-create.md:54
#: shell-novice/_episodes/03-create.md:69
#: shell-novice/_episodes/03-create.md:80
#: shell-novice/_episodes/03-create.md:92
#: shell-novice/_episodes/03-create.md:101
#: shell-novice/_episodes/03-create.md:110
#: shell-novice/_episodes/03-create.md:168
#: shell-novice/_episodes/03-create.md:232
#: shell-novice/_episodes/03-create.md:317
#: shell-novice/_episodes/03-create.md:327
#: shell-novice/_episodes/03-create.md:340
#: shell-novice/_episodes/03-create.md:366
#: shell-novice/_episodes/03-create.md:374
#: shell-novice/_episodes/03-create.md:387
#: shell-novice/_episodes/03-create.md:401
#: shell-novice/_episodes/03-create.md:452
#: shell-novice/_episodes/03-create.md:466
#: shell-novice/_episodes/03-create.md:473
#: shell-novice/_episodes/03-create.md:571
#: shell-novice/_episodes/03-create.md:578
#: shell-novice/_episodes/03-create.md:622
#: shell-novice/_episodes/03-create.md:637
#: shell-novice/_episodes/04-pipefilter.md:35
#: shell-novice/_episodes/04-pipefilter.md:48
#: shell-novice/_episodes/04-pipefilter.md:64
#: shell-novice/_episodes/04-pipefilter.md:85
#: shell-novice/_episodes/04-pipefilter.md:134
#: shell-novice/_episodes/04-pipefilter.md:148
#: shell-novice/_episodes/04-pipefilter.md:164
#: shell-novice/_episodes/04-pipefilter.md:244
#: shell-novice/_episodes/04-pipefilter.md:268
#: shell-novice/_episodes/04-pipefilter.md:382
#: shell-novice/_episodes/04-pipefilter.md:407
#: shell-novice/_episodes/04-pipefilter.md:425
#: shell-novice/_episodes/04-pipefilter.md:614
#: shell-novice/_episodes/04-pipefilter.md:634
#: shell-novice/_episodes/04-pipefilter.md:656
#: shell-novice/_episodes/04-pipefilter.md:676
#: shell-novice/_episodes/05-loop.md:44 shell-novice/_episodes/05-loop.md:58
#: shell-novice/_episodes/05-loop.md:68 shell-novice/_episodes/05-loop.md:144
#: shell-novice/_episodes/05-loop.md:154 shell-novice/_episodes/05-loop.md:384
#: shell-novice/_episodes/05-loop.md:395 shell-novice/_episodes/05-loop.md:416
#: shell-novice/_episodes/05-loop.md:486 shell-novice/_episodes/05-loop.md:493
#: shell-novice/_episodes/05-loop.md:524 shell-novice/_episodes/05-loop.md:531
#: shell-novice/_episodes/05-loop.md:538 shell-novice/_episodes/05-loop.md:581
#: shell-novice/_episodes/05-loop.md:604 shell-novice/_episodes/05-loop.md:631
#: shell-novice/_episodes/05-loop.md:639 shell-novice/_episodes/05-loop.md:654
#: shell-novice/_episodes/06-script.md:43
#: shell-novice/_episodes/06-script.md:71
#: shell-novice/_episodes/06-script.md:107
#: shell-novice/_episodes/06-script.md:123
#: shell-novice/_episodes/06-script.md:139
#: shell-novice/_episodes/06-script.md:170
#: shell-novice/_episodes/06-script.md:182
#: shell-novice/_episodes/06-script.md:199
#: shell-novice/_episodes/06-script.md:217
#: shell-novice/_episodes/06-script.md:239
#: shell-novice/_episodes/06-script.md:262
#: shell-novice/_episodes/06-script.md:274
#: shell-novice/_episodes/06-script.md:348
#: shell-novice/_episodes/06-script.md:412
#: shell-novice/_episodes/06-script.md:424
#: shell-novice/_episodes/06-script.md:432
#: shell-novice/_episodes/06-script.md:439
#: shell-novice/_episodes/06-script.md:456
#: shell-novice/_episodes/07-find.md:46 shell-novice/_episodes/07-find.md:68
#: shell-novice/_episodes/07-find.md:93 shell-novice/_episodes/07-find.md:114
#: shell-novice/_episodes/07-find.md:130 shell-novice/_episodes/07-find.md:148
#: shell-novice/_episodes/07-find.md:167 shell-novice/_episodes/07-find.md:180
#: shell-novice/_episodes/07-find.md:195 shell-novice/_episodes/07-find.md:219
#: shell-novice/_episodes/07-find.md:234 shell-novice/_episodes/07-find.md:467
#: shell-novice/_episodes/07-find.md:507 shell-novice/_episodes/07-find.md:525
#: shell-novice/_episodes/07-find.md:549 shell-novice/_episodes/07-find.md:565
#: shell-novice/_episodes/07-find.md:578 shell-novice/_episodes/07-find.md:608
#: shell-novice/_episodes/07-find.md:627 shell-novice/_episodes/07-find.md:642
msgid "{: .language-bash}"
msgstr "{: .language-bash}"

#: shell-novice/_episodes/01-intro.md:83
msgid ""
"The shell typically uses `$ ` as the prompt, but may use a different symbol.\n"
"In the examples for this lesson, we'll show the prompt as `$ `.\n"
"Most importantly:\n"
"when typing commands, either from these lessons or from other sources,\n"
"*do not type the prompt*, only the commands that follow it.\n"
"Also note that after you type a command, you have to press the <kbd>Enter</kbd> key to execute it."
msgstr ""
"Термінал зазвичай використовує символ `$ ` як запрошення, але може використовувати й інші символи.\n"
"У прикладах до цього уроку ми використовуватимемо запрошення `$ `.\n"
"Найважливіше:\n"
"під час введення команд з цих уроків або з інших джерел,\n"
"*запрошення вводити не треба*, а треба вводити тільки команди, що йдуть за ним.\n"
"Також зауважте, що після введення команди вам потрібно натиснути клавішу <kbd>Enter</kbd> для її виконання."

#: shell-novice/_episodes/01-intro.md:90
msgid ""
"The prompt is followed by a **text cursor**, a character that indicates the position where your\n"
"typing will appear.\n"
"The cursor is usually a flashing or solid block, but it can also be an underscore or a pipe.\n"
"You may have seen it in a text editor program, for example."
msgstr ""
"За запрошенням йде **текстовий курсор** - символ, який позначає позицію, де\n"
"з'являться наступні введені вами символи.\n"
"Курсор зазвичай блимає або є суцільним блоком, але він також може бути підкресленням або вертикальною рискою.\n"
"Ви могли його бачити, наприклад, в текстових редакторах."

#: shell-novice/_episodes/01-intro.md:95
msgid ""
"So let's try our first command, `ls` which is short for listing.\n"
"This command will list the contents of the current directory:"
msgstr ""
"Давайте спробуємо нашу першу команду, `ls` (походить від англійського слова \"listing\"). \n"
"Ця команда покаже зміст поточного каталогу:"

# code block
#: shell-novice/_episodes/01-intro.md:98
#: shell-novice/_episodes/02-filedir.md:134
#: shell-novice/_episodes/03-create.md:229
#: shell-novice/_episodes/04-pipefilter.md:32
msgid ""
"~~~\n"
"$ ls\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls\n"
"~~~"

# code block
#: shell-novice/_episodes/01-intro.md:103
msgid ""
"~~~\n"
"Desktop     Downloads   Movies      Pictures\n"
"Documents   Library     Music       Public\n"
"~~~"
msgstr ""
"~~~\n"
"Desktop     Downloads   Movies      Pictures\n"
"Documents   Library     Music       Public\n"
"~~~"

# SC/DC Template label
#: shell-novice/_episodes/01-intro.md:107
#: shell-novice/_episodes/02-filedir.md:55
#: shell-novice/_episodes/02-filedir.md:143
#: shell-novice/_episodes/02-filedir.md:169
#: shell-novice/_episodes/02-filedir.md:241
#: shell-novice/_episodes/02-filedir.md:347
#: shell-novice/_episodes/02-filedir.md:381
#: shell-novice/_episodes/02-filedir.md:425
#: shell-novice/_episodes/02-filedir.md:435
#: shell-novice/_episodes/02-filedir.md:481
#: shell-novice/_episodes/02-filedir.md:494
#: shell-novice/_episodes/02-filedir.md:540
#: shell-novice/_episodes/02-filedir.md:584
#: shell-novice/_episodes/02-filedir.md:763
#: shell-novice/_episodes/02-filedir.md:777
#: shell-novice/_episodes/02-filedir.md:793
#: shell-novice/_episodes/03-create.md:43
#: shell-novice/_episodes/03-create.md:59
#: shell-novice/_episodes/03-create.md:85
#: shell-novice/_episodes/03-create.md:120
#: shell-novice/_episodes/03-create.md:237
#: shell-novice/_episodes/03-create.md:345
#: shell-novice/_episodes/03-create.md:379
#: shell-novice/_episodes/03-create.md:406
#: shell-novice/_episodes/03-create.md:457
#: shell-novice/_episodes/03-create.md:482
#: shell-novice/_episodes/04-pipefilter.md:41
#: shell-novice/_episodes/04-pipefilter.md:53
#: shell-novice/_episodes/04-pipefilter.md:75
#: shell-novice/_episodes/04-pipefilter.md:96
#: shell-novice/_episodes/04-pipefilter.md:153
#: shell-novice/_episodes/04-pipefilter.md:175
#: shell-novice/_episodes/04-pipefilter.md:255
#: shell-novice/_episodes/04-pipefilter.md:273
#: shell-novice/_episodes/04-pipefilter.md:387
#: shell-novice/_episodes/04-pipefilter.md:418
#: shell-novice/_episodes/04-pipefilter.md:430
#: shell-novice/_episodes/04-pipefilter.md:627
#: shell-novice/_episodes/04-pipefilter.md:643
#: shell-novice/_episodes/04-pipefilter.md:665
#: shell-novice/_episodes/04-pipefilter.md:681
#: shell-novice/_episodes/05-loop.md:75 shell-novice/_episodes/05-loop.md:402
#: shell-novice/_episodes/05-loop.md:591 shell-novice/_episodes/05-loop.md:614
#: shell-novice/_episodes/05-loop.md:671
#: shell-novice/_episodes/06-script.md:80
#: shell-novice/_episodes/06-script.md:132
#: shell-novice/_episodes/06-script.md:148
#: shell-novice/_episodes/06-script.md:191
#: shell-novice/_episodes/06-script.md:208
#: shell-novice/_episodes/06-script.md:288
#: shell-novice/_episodes/07-find.md:61 shell-novice/_episodes/07-find.md:75
#: shell-novice/_episodes/07-find.md:99 shell-novice/_episodes/07-find.md:119
#: shell-novice/_episodes/07-find.md:135 shell-novice/_episodes/07-find.md:155
#: shell-novice/_episodes/07-find.md:173 shell-novice/_episodes/07-find.md:187
#: shell-novice/_episodes/07-find.md:208 shell-novice/_episodes/07-find.md:227
#: shell-novice/_episodes/07-find.md:257 shell-novice/_episodes/07-find.md:455
#: shell-novice/_episodes/07-find.md:489 shell-novice/_episodes/07-find.md:516
#: shell-novice/_episodes/07-find.md:542 shell-novice/_episodes/07-find.md:554
#: shell-novice/_episodes/07-find.md:585 shell-novice/_episodes/07-find.md:616
#: shell-novice/_episodes/07-find.md:648
msgid "{: .output}"
msgstr "{: .output}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/01-intro.md:109
msgid "> ## Command not found"
msgstr "> ## Команду не знайдено"

# blockquote, which can be cascaded
#: shell-novice/_episodes/01-intro.md:110
msgid ""
"> If the shell can't find a program whose name is the command you typed, it"
msgstr "> Якщо термінал не може знайти програму, назву якої ви ввели, він"

# blockquote, which can be cascaded
#: shell-novice/_episodes/01-intro.md:111
msgid "> will print an error message such as:"
msgstr "> виведе на екран наступну помилку:"

#: shell-novice/_episodes/01-intro.md:112
msgid ""
">\n"
"> ~~~\n"
"> $ ks\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> ks: command not found\n"
"> ~~~"
msgstr ""
">\n"
"> ~~~\n"
"> $ ks\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> ks: command not found\n"
"> ~~~"

# SC/DC Template label
#: shell-novice/_episodes/01-intro.md:120
#: shell-novice/_episodes/02-filedir.md:698
#: shell-novice/_episodes/03-create.md:522
#: shell-novice/_episodes/03-create.md:530
#: shell-novice/_episodes/03-create.md:671
#: shell-novice/_episodes/03-create.md:867
#: shell-novice/_episodes/03-create.md:880
#: shell-novice/_episodes/03-create.md:888
#: shell-novice/_episodes/03-create.md:918
#: shell-novice/_episodes/04-pipefilter.md:216
#: shell-novice/_episodes/04-pipefilter.md:227
#: shell-novice/_episodes/04-pipefilter.md:312
#: shell-novice/_episodes/04-pipefilter.md:556
#: shell-novice/_episodes/04-pipefilter.md:582
#: shell-novice/_episodes/05-loop.md:207 shell-novice/_episodes/05-loop.md:475
#: shell-novice/_episodes/05-loop.md:702 shell-novice/_episodes/07-find.md:266
#: shell-novice/_episodes/07-find.md:299
msgid "> {: .output}"
msgstr "> {: .output}"

#: shell-novice/_episodes/01-intro.md:121
msgid ""
">\n"
"> This might happen if the command was mis-typed or if the program corresponding to that command\n"
"> is not installed."
msgstr ""
">\n"
"> Це може трапитися, якщо при наборі команди була допущена помилка або якщо програма, що відповідає набраній команді,\n"
"> не встановлена."

# SC/DC Template label
#: shell-novice/_episodes/01-intro.md:124
#: shell-novice/_episodes/02-filedir.md:76
#: shell-novice/_episodes/02-filedir.md:114
#: shell-novice/_episodes/02-filedir.md:181
#: shell-novice/_episodes/02-filedir.md:257
#: shell-novice/_episodes/02-filedir.md:292
#: shell-novice/_episodes/02-filedir.md:518
#: shell-novice/_episodes/02-filedir.md:631
#: shell-novice/_episodes/03-create.md:128
#: shell-novice/_episodes/03-create.md:158
#: shell-novice/_episodes/03-create.md:192
#: shell-novice/_episodes/03-create.md:224
#: shell-novice/_episodes/03-create.md:309
#: shell-novice/_episodes/03-create.md:594
#: shell-novice/_episodes/03-create.md:722
#: shell-novice/_episodes/04-pipefilter.md:121
#: shell-novice/_episodes/04-pipefilter.md:186
#: shell-novice/_episodes/04-pipefilter.md:296
#: shell-novice/_episodes/05-loop.md:84 shell-novice/_episodes/05-loop.md:126
#: shell-novice/_episodes/05-loop.md:476 shell-novice/_episodes/05-loop.md:660
#: shell-novice/_episodes/05-loop.md:706 shell-novice/_episodes/05-loop.md:724
#: shell-novice/_episodes/06-script.md:96
#: shell-novice/_episodes/06-script.md:155
#: shell-novice/_episodes/07-find.md:307 shell-novice/_episodes/07-find.md:593
#: shell-novice/_episodes/07-find.md:698 shell-novice/setup.md:41
msgid "{: .callout}"
msgstr "{: .callout}"

# header
#: shell-novice/_episodes/01-intro.md:127
msgid "## Nelle's Pipeline: A Typical Problem"
msgstr "## Конвеєр Неллі: Типова Проблема"

#: shell-novice/_episodes/01-intro.md:129
msgid ""
"Nelle Nemo, a marine biologist,\n"
"has just returned from a six-month survey of the\n"
"[North Pacific Gyre](http://en.wikipedia.org/wiki/North_Pacific_Gyre),\n"
"where she has been sampling gelatinous marine life in the\n"
"[Great Pacific Garbage Patch](http://en.wikipedia.org/wiki/Great_Pacific_Garbage_Patch).\n"
"She has 1520 samples that she's run through an assay machine to measure the relative abundance\n"
"of 300 proteins.\n"
"She needs to run these 1520 files through an imaginary program called `goostats.sh` she inherited.\n"
"On top of this huge task, she has to write up results by the end of the month so her paper\n"
"can appear in a special issue of *Aquatic Goo Letters*."
msgstr ""
"Неллі Немо (Nelle Nemo), морський біолог,\n"
"тільки повернулась з шостимісячного дослідження\n"
"[Північнотихоокеанської течії (North Pacific Gyre)](https://uk.wikipedia.org/wiki/Північнотихоокеанська_течія),\n"
"де вона брала зразки желатинового морського життя у\n"
"[Великій тихоокеанській сміттєвій плямі](https://uk.wikipedia.org/wiki/Велика_тихоокеанська_сміттєва_пляма).\n"
"Вона має 1520 зразків, які вона пропускає через аналізатор, щоб виміряти відносну кількість\n"
"300 білків.\n"
"Їй потрібно запустити ці 1520 файлів через уявну програму `goostats.sh`, яку вона успадкувала.\n"
"Окрім цього величезного завдання, вона має написати результати до кінця місяця, щоб її робота\n"
"могла з’явитися у спеціальному випуску *Aquatic Goo Letters*."

#: shell-novice/_episodes/01-intro.md:140
msgid ""
"The bad news is that if she has to run `goostats.sh` by hand using a GUI,\n"
"she'll have to select and open a file 1520 times.\n"
"If `goostats.sh` takes 30 seconds to run each file, the whole process will take more than 12 hours\n"
"of Nelle's attention.\n"
"With the shell, Nelle can instead assign her computer this mundane task while she focuses\n"
"her attention on writing her paper."
msgstr ""
"Погані новини полягають у тому, що якщо вона має запускати `goostats.sh` вручну за допомогою графічного інтерфейсу користувача,\n"
"вона буде змущена обирати та відкривати файли 1520 разів.\n"
"Якщо обробка одного файлу програмою `goostats.sh` триватиме 30 секунд, загальний процес вимагатиме більше ніж 12 годин\n"
"уваги Неллі.\n"
"За допомогою терміналу Неллі може замість цього доручити своєму комп’ютеру це буденне завдання в той час, коли вона фокусує\n"
"свою увагу на написанні статті."

#: shell-novice/_episodes/01-intro.md:147
msgid ""
"The next few lessons will explore the ways Nelle can achieve this.\n"
"More specifically,\n"
"they explain how she can use a command shell to run the `goostats.sh` program,\n"
"using loops to automate the repetitive steps of entering file names,\n"
"so that her computer can work while she writes her paper."
msgstr ""
"У наступних кількох уроках будуть розглянуті шляхи, яким чином Неллі може цього досягти.\n"
"Більш конкретно,\n"
"ці шляхи пояснюють, як вона може використовувати термінал для запуску програми `goostats.sh`,\n"
"використовуючи цикли для автоматизації повторюваних кроків введення імен,\n"
"отже її комп'ютер може працювати в той час, коли вона пише свою статтю."

#: shell-novice/_episodes/01-intro.md:153
msgid ""
"As a bonus,\n"
"once she has put a processing pipeline together,\n"
"she will be able to use it again whenever she collects more data."
msgstr ""
"В якості бонуса,\n"
"як тільки вона налаштує конвеєр,\n"
"вона буде взмозі використати його повторно в будь-який час, коли вона збере більше даних."

#: shell-novice/_episodes/01-intro.md:157
msgid ""
"In order to achieve her task, Nelle needs to know how to:\n"
"- navigate to a file/directory\n"
"- create a file/directory\n"
"- check the length of a file\n"
"- chain commands together\n"
"- retrieve a set of files\n"
"- iterate over files\n"
"- run a shell script containing her pipeline"
msgstr ""
"Для того, щоб досягти своєї мети, Неллі необхідно знати, як:\n"
"- перейти до файла/каталогу\n"
"- створити файл/каталог\n"
"- перевірити довжину файлу\n"
"- з'єднати команди разом\n"
"- отримати множину файлів\n"
"- перебрати файли\n"
"- запустити скрипт, що містить розроблений нею конвеєр"

#: shell-novice/_episodes/01-intro.md:166
#: shell-novice/_episodes/02-filedir.md:868
#: shell-novice/_episodes/03-create.md:974
#: shell-novice/_episodes/04-pipefilter.md:718
#: shell-novice/_episodes/05-loop.md:808
#: shell-novice/_episodes/06-script.md:649
#: shell-novice/_episodes/07-find.md:728
msgid "{% include links.md %}"
msgstr "{% include links.md %}"

# Front Matter
#: shell-novice/_episodes/02-filedir.md:1
msgid ""
"---\n"
"title: \"Navigating Files and Directories\"\n"
"teaching: 30\n"
"exercises: 10\n"
"questions:\n"
"- \"How can I move around on my computer?\"\n"
"- \"How can I see what files and directories I have?\"\n"
"- \"How can I specify the location of a file or directory on my computer?\"\n"
"objectives:\n"
"- \"Explain the similarities and differences between a file and a directory.\"\n"
"- \"Translate an absolute path into a relative path and vice versa.\"\n"
"- \"Construct absolute and relative paths that identify specific files and directories.\"\n"
"- \"Use options and arguments to change the behaviour of a shell command.\"\n"
"- \"Demonstrate the use of tab completion and explain its advantages.\"\n"
"keypoints:\n"
"- \"The file system is responsible for managing information on the disk.\"\n"
"- \"Information is stored in files, which are stored in directories (folders).\"\n"
"- \"Directories can also store other directories, which then form a directory tree.\"\n"
"- \"`pwd` prints the user's current working directory.\"\n"
"- \"`ls [path]` prints a listing of a specific file or directory; `ls` on its own lists the current working directory.\"\n"
"- \"`cd [path]` changes the current working directory.\"\n"
"- \"Most commands take options that begin with a single `-`.\"\n"
"- \"Directory names in a path are separated with `/` on Unix, but `\\\\` on Windows.\"\n"
"- \"`/` on its own is the root directory of the whole file system.\"\n"
"- \"An absolute path specifies a location from the root of the file system.\"\n"
"- \"A relative path specifies a location starting from the current location.\"\n"
"- \"`.` on its own means 'the current directory'; `..` means 'the directory above the current one'.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Навігація файлами та каталогами\"\n"
"teaching: 30\n"
"exercises: 10\n"
"questions:\n"
"- \"Як я можу переміщатися на моєму комп'ютері?\"\n"
"- \"Як я можу побачити, які файли та каталоги у мене є?\"\n"
"- \"Як вказати місцезнаходження файлу або каталогу на комп'ютері?\"\n"
"objectives:\n"
"- \"Пояснити подібності та відмінності між файлом і каталогом\".\n"
"- \"Перетворити абсолютний шлях у відносний і навпаки\".\n"
"- \"Створити абсолютні та відносні шляхи, які ідентифікують певні файли та каталоги\".\n"
"- \"Використати опції та аргументи для зміни поведінки команди оболонки\".\n"
"- \"Продемонструвати використання завершення вкладки та пояснити його переваги\".\n"
"keypoints:\n"
"- \"Файлова система відповідає за керування інформацією на диску\".\n"
"- \"Інформація зберігається у файлах, які зберігаються в каталогах (папках)\".\n"
"- \"У каталогах також можуть зберігатися інші каталоги, які потім утворюють дерево каталогів\".\n"
"- \"Команда `pwd` виводить поточний робочий каталог користувача.\"\n"
"- \"Команда `ls [шлях]` виводить список певного файлу або каталогу; Команда `ls` сама по собі виводить список поточного робочого каталогу.\"\n"
"- \"Команда `cd [шлях]` змінює поточний робочий каталог.\"\n"
"- \"Більшість команд приймають параметри, які починаються з одного символу `-`.\"\n"
"- \"Назви каталогів у шляху розділяються символами `/` у Unix, але `\\\\` у Windows.\"\n"
"- \"Символ `/` сам по собі є кореневим каталогом усієї файлової системи.\"\n"
"- \"Абсолютний шлях вказує на розташування від кореня файлової системи.\"\n"
"- \"Відносний шлях вказує на розташування, починаючи з поточного розташування.\"\n"
"- \"Символ `.` сам по собі означає \"поточний каталог\"; `..` означає \"каталог вище поточного\", \"батьківський каталог\".\n"
"---"

#: shell-novice/_episodes/02-filedir.md:30
msgid ""
"The part of the operating system responsible for managing files and directories\n"
"is called the **file system**.\n"
"It organizes our data into files,\n"
"which hold information,\n"
"and directories (also called 'folders'),\n"
"which hold files or other directories."
msgstr ""
"Частина операційної системи, яка відповідає за роботу з файлами та директоріями,\n"
"називається **файлова система**.\n"
"Вона організує наші дані у вигляді файлів,\n"
"які містять інформацію,\n"
"та директорій (їх ще називають 'каталогами'),\n"
"які містять файли або інші директорії."

#: shell-novice/_episodes/02-filedir.md:37
msgid ""
"Several commands are frequently used to create, inspect, rename, and delete files and directories.\n"
"To start exploring them, we'll go to our open shell window."
msgstr ""
"Декілька команд часто використовуються для створення, перевірки, перейменування та видалення файлів та директорій.\n"
"Для початку їх огляду, перейдемо до нашого відкритого вікна терміналу."

#: shell-novice/_episodes/02-filedir.md:40
msgid ""
"First, let's find out where we are by running a command called `pwd`\n"
"(which stands for 'print working directory'). Directories are like *places* — at any time\n"
"while we are using the shell, we are in exactly one place called\n"
"our **current working directory**. Commands mostly read and write files in the\n"
"current working directory, i.e. 'here', so knowing where you are before running\n"
"a command is important. `pwd` shows you where you are:"
msgstr ""
"По-перше, давайте дізнаємося, де ми знаходимося, шляхом виконання команди `pwd`\n"
"(англ. 'print working directory' - надрукувати робочу директорію). Директорії — це немов *місця* — будь-коли\n"
"під час використання терміналу ми знаходимось в якомусь одному конкретному місці, яке називається\n"
"нашою **поточною робочою директорією**. Команди здебільшого читають вміст файлів та пишуть до них в\n"
"поточній робочій директорії, тобто 'тут', отже розуміння того, де ви знаходитесь, перед запуском\n"
"команди є важливим. Команда `pwd` покаже вам, де ви знаходитесь:"

# code block
#: shell-novice/_episodes/02-filedir.md:47
#: shell-novice/_episodes/02-filedir.md:417
#: shell-novice/_episodes/02-filedir.md:473
#: shell-novice/_episodes/02-filedir.md:532
#: shell-novice/_episodes/02-filedir.md:576
#: shell-novice/_episodes/03-create.md:35
msgid ""
"~~~\n"
"$ pwd\n"
"~~~"
msgstr ""
"~~~\n"
"$ pwd\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:52
#: shell-novice/_episodes/02-filedir.md:537
msgid ""
"~~~\n"
"/Users/nelle\n"
"~~~"
msgstr ""
"~~~\n"
"/Users/nelle\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:57
msgid ""
"Here,\n"
"the computer's response is `/Users/nelle`,\n"
"which is Nelle's **home directory**:"
msgstr ""
"У наведеному прикладі\n"
"комп'ютер відповів `/Users/nelle`,\n"
"що є **домашньою директорією** Неллі:"

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:61
msgid "> ## Home Directory Variation"
msgstr "> ## Варіації домашнього каталогу"

#: shell-novice/_episodes/02-filedir.md:62
msgid ""
">\n"
"> The home directory path will look different on different operating systems.\n"
"> On Linux, it may look like `/home/nelle`,\n"
"> and on Windows, it will be similar to `C:\\Documents and Settings\\nelle` or\n"
"> `C:\\Users\\nelle`.\n"
"> (Note that it may look slightly different for different versions of Windows.)\n"
"> In future examples, we've used Mac output as the default - Linux and Windows\n"
"> output may differ slightly but should be generally similar.\n"
">\n"
"> We will also assume that your `pwd` command returns your user's home directory.\n"
"> If `pwd` returns something different, you may need to navigate there using `cd`\n"
"> or some commands in this lesson will not work as written.\n"
"> See [Exploring Other Directories](#exploring-other-directories) for more details\n"
"> on the `cd` command."
msgstr ""
"> \n"
"> Розташування домашньої директорії виглядає по-різному в різних операційних системах.\n"
"> В Linux воно може виглядати як `/home/nelle`,\n"
"> а у Windows воно буде схоже на `C:\\Documents and Settings\\nelle` чи\n"
"> `C:\\Users\\nelle`.\n"
"> (Зауважте, що воно може виглядати дещо інакше для різних версій Windows.)\n"
"> У майбутніх прикладах ми використовували формат виводу Mac як стандартний – формати виводу Linux та Windows\n"
"> можуть дещо відрізнятися, але загалом мають бути подібними.\n"
"> Ми також припустимо, що ваша команда `pwd` повертає вашу домашню директорію користувача.\n"
"> Якщо команда `pwd` повертає щось інше, вам може знадобитися перейти туди за допомогою команди `cd`,\n"
"> інакше деякі команди в цьому уроці не будуть працювати як описано.\n"
"> Дивись [Огляд інших каталогів](#exploring-other-directories), щоб дізнатися більше\n"
"> про команду `cd`."

#: shell-novice/_episodes/02-filedir.md:78
msgid ""
"To understand what a 'home directory' is,\n"
"let's have a look at how the file system as a whole is organized.  For the\n"
"sake of this example, we'll be\n"
"illustrating the filesystem on our scientist Nelle's computer.  After this\n"
"illustration, you'll be learning commands to explore your own filesystem,\n"
"which will be constructed in a similar way, but not be exactly identical."
msgstr ""
"Для того, щоб зрозуміти, що таке 'домашній каталог',\n"
"давайте подивимось, як організована файлова система в цілому. Для\n"
"цього прикладу ми\n"
"проілюструємо файлову систему на комп’ютері нашої вченої Неллі. Після цієї\n"
"ілюстрації ви вивчатимете команди для дослідження власної файлової системи,\n"
"яка буде побудовані подібним чином, але не буде абсолютно ідентичною."

#: shell-novice/_episodes/02-filedir.md:85
msgid "On Nelle's computer, the filesystem looks like this:"
msgstr "На комп’ютері Неллі файлова система виглядає так:"

#: shell-novice/_episodes/02-filedir.md:87
msgid ""
"![The file system is made up of a root directory that contains sub-directories\n"
"titled bin, data, users, and tmp](../fig/filesystem.svg)"
msgstr ""
"![Файлова система складається з кореневого каталогу, який містить підкаталоги\n"
"під назвами bin, data, users та tmp](../fig/filesystem.svg)"

#: shell-novice/_episodes/02-filedir.md:90
msgid ""
"At the top is the **root directory**\n"
"that holds everything else.\n"
"We refer to it using a slash character, `/`, on its own;\n"
"this character is the leading slash in `/Users/nelle`."
msgstr ""
"У верхній частині знаходиться **кореневий каталог**,\n"
"який містить усе інше.\n"
"Ми виконуємо посилання на нього за допомогою символу косої риски, `/`;\n"
"цей символ - це перший (лівий) символ у рядку `/Users/nelle`."

#: shell-novice/_episodes/02-filedir.md:95
msgid ""
"Inside that directory are several other directories:\n"
"`bin` (which is where some built-in programs are stored),\n"
"`data` (for miscellaneous data files),\n"
"`Users` (where users' personal directories are located),\n"
"`tmp` (for temporary files that don't need to be stored long-term),\n"
"and so on."
msgstr ""
"Усередині цього каталогу є кілька інших каталогів:\n"
"`bin` (в якому зберігаються певні вбудовані програми),\n"
"`data` (для різноманітних файлів даних),\n"
"`Users` (де знаходяться особисті директорії користувачів),\n"
"`tmp` (для файлів тимчасового зберігання)\n"
"та інші."

#: shell-novice/_episodes/02-filedir.md:102
msgid ""
"We know that our current working directory `/Users/nelle` is stored inside `/Users`\n"
"because `/Users` is the first part of its name.\n"
"Similarly,\n"
"we know that `/Users` is stored inside the root directory `/`\n"
"because its name begins with `/`."
msgstr ""
"Ми знаємо, що наш поточний робочий каталог `/Users/nelle` зберігається всередині каталогу `/Users`,\n"
"тому що `/Users` є першою частиною його імені.\n"
"Відповідно,\n"
"ми знаємо, що каталог `/Users` зберігається всередині кореневої директорії `/`,\n"
"бо його ім'я розпочинається з `/`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:108
msgid "> ## Slashes"
msgstr "> ## Символи скісної риски"

#: shell-novice/_episodes/02-filedir.md:109
msgid ""
">\n"
"> Notice that there are two meanings for the `/` character.\n"
"> When it appears at the front of a file or directory name,\n"
"> it refers to the root directory. When it appears *inside* a path,\n"
"> it's just a separator."
msgstr ""
"> \n"
"> Зверніть увагу, що символ `/` має два значення.\n"
"> Коли він з’являється на початку назви файлу чи каталогу,\n"
"> це посилання на кореневу директорію. Коли він використовується *всередині* шляху,\n"
"> це лише роздільник."

#: shell-novice/_episodes/02-filedir.md:116
msgid ""
"Underneath `/Users`,\n"
"we find one directory for each user with an account on Nelle's machine,\n"
"her colleagues *imhotep* and *larry*."
msgstr ""
"Під `/Users`\n"
"ми знайдемо по одній директорії для кожного користувача на машині Неллі:\n"
"її колег *imhotep* та *larry*."

#: shell-novice/_episodes/02-filedir.md:120
msgid ""
"![Like other directories, home directories are sub-directories underneath\n"
"\"/Users\" like \"/Users/imhotep\", \"/Users/larry\" or\n"
"\"/Users/nelle\"](../fig/home-directories.svg)"
msgstr ""
"![Як і інші каталоги, домашні каталоги є підкаталогами\n"
"\"/Users\", наприклад \"/Users/imhotep\", \"/Users/larry\" або\n"
"\"/Users/nelle\"](../fig/home-directories.svg)"

#: shell-novice/_episodes/02-filedir.md:124
msgid ""
"The user *imhotep*'s files are stored in `/Users/imhotep`,\n"
"user *larry*'s in `/Users/larry`,\n"
"and Nelle's in `/Users/nelle`. Nelle is the user in our\n"
"examples here, therefore we get `/Users/nelle` as our home directory.\n"
"Typically, when you open a new command prompt, you will be in\n"
"your home directory to start."
msgstr ""
"Файли користувача *imhotep* зберігаються в директорії `/Users/imhotep`,\n"
"користувача *larry* - в `/Users/larry`,\n"
"і Неллі - в `/Users/nelle`. Оскільки саме Неллі є користувачем у наших\n"
"прикладах, тому ми отримуємо `/Users/nelle` як наш домашній каталог.\n"
"Як правило, коли ви відкриваєте новий командний рядок, ви опиняєтесь в\n"
"вашому домашньому каталозі."

#: shell-novice/_episodes/02-filedir.md:131
msgid ""
"Now let's learn the command that will let us see the contents of our\n"
"own filesystem.  We can see what's in our home directory by running `ls`:"
msgstr ""
"Тепер давайте вивчимо команду, яка дозволить нам бачити вміст нашої\n"
"власної файлової системи. Ми можемо побачити, що знаходиться в нашому домашньому каталозі, запустивши `ls`:"

# code block
#: shell-novice/_episodes/02-filedir.md:139
msgid ""
"~~~\n"
"Applications Documents    Library      Music        Public\n"
"Desktop      Downloads    Movies       Pictures\n"
"~~~"
msgstr ""
"~~~\n"
"Applications Documents    Library      Music        Public\n"
"Desktop      Downloads    Movies       Pictures\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:145
msgid ""
"(Again, your results may be slightly different depending on your operating\n"
"system and how you have customized your filesystem.)"
msgstr ""
"(Знову ж таки, ваші результати можуть дещо відрізнятися залежно від вашої операційної\n"
"системи та того, як ви налаштували свою файлову систему.)"

#: shell-novice/_episodes/02-filedir.md:148
msgid ""
"`ls` prints the names of the files and directories in the current directory.\n"
"We can make its output more comprehensible by using the `-F` **option**\n"
"which tells `ls` to classify the output\n"
"by adding a marker to file and directory names to indicate what they are:\n"
"- a trailing `/` indicates that this is a directory\n"
"- `@` indicates a link\n"
"- `*` indicates an executable"
msgstr ""
"`ls` друкує назви файлів і каталогів у поточному каталозі.\n"
"Ми можемо зробити його вивід більш зрозумілим, використовуючи **опцію** `-F`\n"
"який повідомляє `ls` про необхідність класифікації виводу\n"
"шляхом додавання маркера до імен файлів і каталогів, щоб вказати, що вони собою представляють:\n"
"- символ `/` наприкінці назви вказує на те, що це каталог\n"
"- `@` вказує на посилання\n"
"- `*` вказує на виконуваний файл"

#: shell-novice/_episodes/02-filedir.md:156
msgid ""
"Depending on your shell's default settings,\n"
"the shell might also use colors to indicate whether each entry is a file or\n"
"directory."
msgstr ""
"Залежно від налаштувань терміналу за замовчуванням,\n"
"в терміналі також можуть бути використані кольори, щоб вказати, чи є кожен елемент файлом або\n"
"каталогом."

# code block
#: shell-novice/_episodes/02-filedir.md:160
#: shell-novice/_episodes/02-filedir.md:427
#: shell-novice/_episodes/03-create.md:51
#: shell-novice/_episodes/03-create.md:77
msgid ""
"~~~\n"
"$ ls -F\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls -F\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:165
msgid ""
"~~~\n"
"Applications/ Documents/    Library/      Music/        Public/\n"
"Desktop/      Downloads/    Movies/       Pictures/\n"
"~~~"
msgstr ""
"~~~\n"
"Applications/ Documents/    Library/      Music/        Public/\n"
"Desktop/      Downloads/    Movies/       Pictures/\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:171
msgid ""
"Here,\n"
"we can see that our home directory contains only **sub-directories**.\n"
"Any names in our output that don't have a classification symbol\n"
"are plain old **files**."
msgstr ""
"В наведеному прикладі\n"
"ми бачимо, що наш домашній каталог містить лише **підкаталоги**.\n"
"Будь-які імена в наших результатах, які не мають символу класифікації\n"
"відповідають звичайним старим **файлам**."

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:176
msgid "> ## Clearing your terminal"
msgstr "> ## Очищення терміналу"

#: shell-novice/_episodes/02-filedir.md:177
msgid ""
">\n"
"> If your screen gets too cluttered, you can clear your terminal using the\n"
"> `clear` command. You can still access previous commands using <kbd>↑</kbd>\n"
"> and <kbd>↓</kbd> to move line-by-line, or by scrolling in your terminal."
msgstr ""
">\n"
"> Якщо екран стає занадто захаращеним, ви можете очистити термінал за допомогою\n"
"> команди `clear`. Ви все ще можете отримати доступ до попередніх команд за допомогою клавіш <kbd>↑</kbd>\n"
"> та <kbd>↓</kbd> щоб переміщатися рядок за рядком, або за допомогою прокрутки у вашому терміналі."

# header
#: shell-novice/_episodes/02-filedir.md:183
msgid "### Getting help"
msgstr "### Отримання допомоги"

#: shell-novice/_episodes/02-filedir.md:185
msgid ""
"`ls` has lots of other **options**. There are two common ways to find out how\n"
"to use a command and what options it accepts ---\n"
"**depending on your environment, you might find that only one of these ways works:**"
msgstr ""
"У `ls` є багато інших **опцій**. Існує два поширених способи дізнатися, як\n"
"використовувати команду і які параметри вона приймає ---\n"
"**залежно від вашого середовища, ви можете виявити, що працює лише один із цих способів:**."

# ordered list
#: shell-novice/_episodes/02-filedir.md:189
msgid ""
"1. We can pass a `--help` option to the command (available on Linux and Git "
"Bash), such as:"
msgstr ""
"1. Ми можемо передати команді опцію `--help` (доступну в Linux і Git Bash), "
"наприклад:"

#: shell-novice/_episodes/02-filedir.md:190
msgid ""
"    ~~~\n"
"    $ ls --help\n"
"    ~~~\n"
"    {: .language-bash}"
msgstr ""
"    ~~~\n"
"    $ ls --help\n"
"    ~~~\n"
"    {: .language-bash}"

# ordered list
#: shell-novice/_episodes/02-filedir.md:195
msgid ""
"2. We can read its manual with `man` (available on Linux and macOS), such "
"as:"
msgstr ""
"2. Ми можемо прочитати інструкцію до використання команди за допомогою `man`"
" (доступно на Linux і macOS), наприклад:"

#: shell-novice/_episodes/02-filedir.md:196
msgid ""
"    ~~~\n"
"    $ man ls\n"
"    ~~~\n"
"    {: .language-bash}"
msgstr ""
"    ~~~\n"
"    $ man ls\n"
"    ~~~\n"
"    {: .language-bash}"

#: shell-novice/_episodes/02-filedir.md:201
msgid "We'll describe both ways next."
msgstr "Далі ми опишемо обидва способи."

# header
#: shell-novice/_episodes/02-filedir.md:203
msgid "#### The `--help` option"
msgstr "#### Опція `--help'"

#: shell-novice/_episodes/02-filedir.md:205
msgid ""
"Most bash commands and programs that people have written to be\n"
"run from within bash, support a `--help` option that displays more\n"
"information on how to use the command or program."
msgstr ""
"Більшість команд bash і програм, які люди написали для того, щоб їх можна було\n"
"запускати з bash, підтримують опцію `--help`, яка виводить додаткову\n"
"інформацію про те, як користуватися відповідною командою або програмою."

# code block
#: shell-novice/_episodes/02-filedir.md:209
msgid ""
"~~~\n"
"$ ls --help\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls --help\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:214
msgid ""
"~~~\n"
"Usage: ls [OPTION]... [FILE]...\n"
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if neither -cftuvSUX nor --sort is specified.\n"
"\n"
"Mandatory arguments to long options are mandatory for short options, too.\n"
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic characters\n"
"      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n"
"                               '--block-size=M' prints sizes in units of\n"
"                               1,048,576 bytes; see SIZE format below\n"
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of last\n"
"                               modification of file status information);\n"
"                               with -l: show ctime and sort by name;\n"
"                               otherwise: sort by ctime, newest first\n"
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\n"
"                               if omitted), 'auto', or 'never'; more info below\n"
"  -d, --directory            list directories themselves, not their contents\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"...        ...        ...\n"
"~~~"
msgstr ""
"~~~\n"
"Використання: ls [ПАРАМЕТР]... [ФАЙЛ]...\n"
"Виводить дані щодо ФАЙЛів (типово у поточному каталозі).\n"
"Впорядковує у алфавітному порядку, якщо не вказано ні --sort, ні один з\n"
"параметрів -cftuSUX.\n"
"\n"
"Обов'язкові аргументи для довгих форм запису параметрів є обов'язковими і для ск орочених форм.\n"
"  -a, --all                  не ігнорувати записи, що починаються з .\n"
"  A, --almost-all           не виводити неявні . і ..\n"
"      --author               разом з -l, виводити автора кожного файла\n"
"  -b, --escape               виводити вісімкові керівні послідовності\n"
"                             замість неграфічних знаків\n"
"      --block-size=РОЗМІР    якщо вкзаано -l, використовувати блоки розміром РОЗМІР.\n"
"\n"
"                               Наприклад, «--block-size=M». Формат РОЗМІРу наведено\n"
"                               нижче.\n"
"  -B, --ignore-backups       не виводити файли, що закінчуються на ~\n"
"  -c                         з -lt: сортувати за часом зміни; з -l:\n"
"                              виводити час зміни та впорядкувати за назвою,\n"
"                              у іншому випадку впорядкувати за часом зміни,\n"
"                              найновіші — перші\n"
"  -C                     виводити список у декілька колонок\n"
"      --color[=КОЛИ]                     вказує, чи позначати типи файлів кольором.\n"
"                               КОЛИ може бути «never», «auto» або\n"
"                               «always» (типовий, якщо не вказано)\n"
"  -d, --directory            виводити назви каталогів, а не їх зміст, а\n"
"                              також не слідувати за символічним посиланням\n"
"  -D, --dired                 створити виведені дані у режимі Emacs dired\n"
"  -f                         не сортувати, вмикає -aU, вимикає -lst\n"
"  -F, --classify             додавати до назви індикатор (один з */=>@|)...        ...        ...\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:243
msgid "> ## Unsupported command-line options"
msgstr "> ## Непідтримувані параметри командного рядка"

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:244
msgid ""
"> If you try to use an option that is not supported, `ls` and other commands"
msgstr ""
"> Якщо ви спробуєте використати параметр, який не підтримується, `ls` та "
"інші команди"

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:245
msgid "> will usually print an error message similar to:"
msgstr "> зазвичай виводитимуть повідомлення про помилку, схоже на:"

#: shell-novice/_episodes/02-filedir.md:246
msgid ""
">\n"
"> ~~~\n"
"> $ ls -j\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> ls: invalid option -- 'j'\n"
"> Try 'ls --help' for more information.\n"
"> ~~~"
msgstr ""
">\n"
"> ~~~\n"
"> $ ls -j\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> ls: invalid option -- 'j'\n"
"> Try 'ls --help' for more information.\n"
"> ~~~"

# SC/DC Template label
#: shell-novice/_episodes/02-filedir.md:256
#: shell-novice/_episodes/05-loop.md:460
msgid "> {: .error}"
msgstr "> {: .error}"

# header
#: shell-novice/_episodes/02-filedir.md:259
msgid "#### The `man` command"
msgstr "#### Команда `man`"

#: shell-novice/_episodes/02-filedir.md:261
msgid ""
"The other way to learn about `ls` is to type\n"
"~~~\n"
"$ man ls\n"
"~~~\n"
"{: .language-bash}"
msgstr ""
"Інший спосіб дізнатися про `ls` -- це ввести\n"
"~~~\n"
"$ man ls\n"
"~~~\n"
"{: .language-bash}"

#: shell-novice/_episodes/02-filedir.md:267
msgid ""
"This command will turn your terminal into a page with a description\n"
"of the `ls` command and its options."
msgstr ""
"Ця команда перетворить ваш термінал на сторінку з описом\n"
"команди `ls` та її параметрів."

#: shell-novice/_episodes/02-filedir.md:270
msgid ""
"To navigate through the `man` pages,\n"
"you may use <kbd>↑</kbd> and <kbd>↓</kbd> to move line-by-line,\n"
"or try <kbd>B</kbd> and <kbd>Spacebar</kbd> to skip up and down by a full page.\n"
"To search for a character or word in the `man` pages,\n"
"use <kbd>/</kbd> followed by the character or word you are searching for.\n"
"Sometimes a search will result in multiple hits.\n"
"If so, you can move between hits using <kbd>N</kbd> (for moving forward) and\n"
"<kbd>Shift</kbd>+<kbd>N</kbd> (for moving backward)."
msgstr ""
"Для навігації по сторінках `man`,\n"
"ви можете використовувати <kbd>↑</kbd> і <kbd>↓</kbd> для переміщення рядок за рядком,\n"
"або клавіші <kbd>B</kbd> та <kbd>Пробіл</kbd> для переходу вгору і вниз на цілу сторінку.\n"
"Для пошуку символу або слова на сторінках `man`,\n"
"використовуйте клавішу <kbd>/</kbd>, за фкою введіть символ або слово, яке ви шукаєте.\n"
"Іноді пошук може призвести до кількох результатів.\n"
"У такому випадку ви можете переміщатися між результатами за допомогою клавіш <kbd>N</kbd> (для переміщення вперед) та\n"
"<kbd>Shift</kbd>+<kbd>N</kbd> (для переходу назад)."

#: shell-novice/_episodes/02-filedir.md:279
msgid "To **quit** the `man` pages, press <kbd>Q</kbd>."
msgstr "Для **виходу** зі сторінок `man` натисніть <kbd>Q</kbd>."

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:281
msgid "> ## Manual pages on the web"
msgstr "## Сторінки з інструкціями в Інтернеті"

#: shell-novice/_episodes/02-filedir.md:282
msgid ""
">\n"
"> Of course, there is a third way to access help for commands:\n"
"> searching the internet via your web browser.\n"
"> When using internet search, including the phrase `unix man page` in your search\n"
"> query will help to find relevant results.\n"
">\n"
"> GNU provides links to its\n"
"> [manuals](http://www.gnu.org/manual/manual.html) including the\n"
"> [core GNU utilities](http://www.gnu.org/software/coreutils/manual/coreutils.html),\n"
"> which covers many commands introduced within this lesson."
msgstr ""
">\n"
"> Звісно, є й третій спосіб отримати доступ до довідки до команд:\n"
"> пошук в інтернеті за допомогою веб-браузера.\n"
"> Якщо ви скористаєтеся пошуком у Інтернеті, додання до запиту фрази `unix man page`\n"
"> дозволить отримати більш відповідні результати.\n"
">\n"
"GNU надає посилання на свої\n"
"> [посібники].(http://www.gnu.org/manual/manual.html), в тому числі на\n"
"> [основні утиліти GNU](http://www.gnu.org/software/coreutils/manual/coreutils.html),\n"
"> які охоплюють багато команд, представлених у цьому уроці."

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:294
msgid "> ## Exploring More `ls` Flags"
msgstr "> ## Вивчення більше `ls` опцій"

#: shell-novice/_episodes/02-filedir.md:295
msgid ""
">\n"
"> You can also use two options at the same time. What does the command `ls` do when used\n"
"> with the `-l` option? What about if you use both the `-l` and the `-h` option?\n"
">\n"
"> Some of its output is about properties that we do not cover in this lesson (such\n"
"> as file permissions and ownership), but the rest should be useful\n"
"> nevertheless.\n"
">\n"
"> > ## Solution\n"
"> > The `-l` option makes `ls` use a **l**ong listing format, showing not only\n"
"> > the file/directory names but also additional information, such as the file size\n"
"> > and the time of its last modification. If you use both the `-h` option and the `-l` option,\n"
"> > this makes the file size '**h**uman readable', i.e. displaying something like `5.3K`\n"
"> > instead of `5369`."
msgstr ""
">\n"
"> Ви також можете використовувати декілька опцій одночасно. Що робить команда `ls` при використанні\n"
"> з опцією `-l`? А якщо ви використовуєте і `-l`, і `-h`?\n"
">\n"
"> Деякі з результатів виконання команди стосуються властивостей, які ми не розглядаємо у цьому уроці (наприклад,\n"
"> права доступу до файлів і права власності), але решта має бути корисною\n"
"> тим не менш.\n"
">\n"
"> > ## Розв'язання\n"
"> > Опція `-l` змушує `ls` використовувати довгий (англ. **l**ong) формат лістингу, показуючи не лише\n"
"> > назви файлів/директорій, але й додаткову інформацію, таку як розмір файлу\n"
"> > і час його останньої модифікації. Якщо ви використовуєте як `-h`, так і `-l`,\n"
"> > це зробить виведення розміру файлу у більш зрозумілому людині вигляді (\"**h**uman readable\"), тобто покаже щось на кшталт `5.3K`.\n"
"> > замість `5369`."

# SC/DC Template label
#: shell-novice/_episodes/02-filedir.md:309
#: shell-novice/_episodes/02-filedir.md:326
#: shell-novice/_episodes/02-filedir.md:660
#: shell-novice/_episodes/02-filedir.md:685
#: shell-novice/_episodes/02-filedir.md:715
#: shell-novice/_episodes/03-create.md:274
#: shell-novice/_episodes/03-create.md:437
#: shell-novice/_episodes/03-create.md:508
#: shell-novice/_episodes/03-create.md:559
#: shell-novice/_episodes/03-create.md:612
#: shell-novice/_episodes/03-create.md:689
#: shell-novice/_episodes/03-create.md:754
#: shell-novice/_episodes/03-create.md:852
#: shell-novice/_episodes/03-create.md:898
#: shell-novice/_episodes/03-create.md:971
#: shell-novice/_episodes/04-pipefilter.md:233
#: shell-novice/_episodes/04-pipefilter.md:338
#: shell-novice/_episodes/04-pipefilter.md:367
#: shell-novice/_episodes/04-pipefilter.md:463
#: shell-novice/_episodes/04-pipefilter.md:527
#: shell-novice/_episodes/04-pipefilter.md:568
#: shell-novice/_episodes/04-pipefilter.md:601
#: shell-novice/_episodes/04-pipefilter.md:715
#: shell-novice/_episodes/05-loop.md:196 shell-novice/_episodes/05-loop.md:269
#: shell-novice/_episodes/05-loop.md:293 shell-novice/_episodes/05-loop.md:314
#: shell-novice/_episodes/05-loop.md:343 shell-novice/_episodes/05-loop.md:371
#: shell-novice/_episodes/05-loop.md:778 shell-novice/_episodes/05-loop.md:805
#: shell-novice/_episodes/06-script.md:333
#: shell-novice/_episodes/06-script.md:384
#: shell-novice/_episodes/06-script.md:509
#: shell-novice/_episodes/06-script.md:555
#: shell-novice/_episodes/06-script.md:604
#: shell-novice/_episodes/06-script.md:646
#: shell-novice/_episodes/07-find.md:276 shell-novice/_episodes/07-find.md:375
#: shell-novice/_episodes/07-find.md:425 shell-novice/_episodes/07-find.md:676
#: shell-novice/_episodes/07-find.md:724
msgid "> {: .solution}"
msgstr "> {: .solution}"

# SC/DC Template label
#: shell-novice/_episodes/02-filedir.md:310
#: shell-novice/_episodes/02-filedir.md:327
#: shell-novice/_episodes/02-filedir.md:661
#: shell-novice/_episodes/02-filedir.md:686
#: shell-novice/_episodes/02-filedir.md:716
#: shell-novice/_episodes/03-create.md:285
#: shell-novice/_episodes/03-create.md:438
#: shell-novice/_episodes/03-create.md:509
#: shell-novice/_episodes/03-create.md:560
#: shell-novice/_episodes/03-create.md:613
#: shell-novice/_episodes/03-create.md:690
#: shell-novice/_episodes/03-create.md:755
#: shell-novice/_episodes/03-create.md:853
#: shell-novice/_episodes/03-create.md:899
#: shell-novice/_episodes/03-create.md:972
#: shell-novice/_episodes/04-pipefilter.md:234
#: shell-novice/_episodes/04-pipefilter.md:339
#: shell-novice/_episodes/04-pipefilter.md:368
#: shell-novice/_episodes/04-pipefilter.md:464
#: shell-novice/_episodes/04-pipefilter.md:528
#: shell-novice/_episodes/04-pipefilter.md:569
#: shell-novice/_episodes/04-pipefilter.md:602
#: shell-novice/_episodes/04-pipefilter.md:716
#: shell-novice/_episodes/05-loop.md:197 shell-novice/_episodes/05-loop.md:270
#: shell-novice/_episodes/05-loop.md:315 shell-novice/_episodes/05-loop.md:344
#: shell-novice/_episodes/05-loop.md:372 shell-novice/_episodes/05-loop.md:779
#: shell-novice/_episodes/05-loop.md:806
#: shell-novice/_episodes/06-script.md:334
#: shell-novice/_episodes/06-script.md:385
#: shell-novice/_episodes/06-script.md:510
#: shell-novice/_episodes/06-script.md:556
#: shell-novice/_episodes/06-script.md:605
#: shell-novice/_episodes/06-script.md:647
#: shell-novice/_episodes/07-find.md:277 shell-novice/_episodes/07-find.md:376
#: shell-novice/_episodes/07-find.md:426 shell-novice/_episodes/07-find.md:677
#: shell-novice/_episodes/07-find.md:725
msgid "{: .challenge}"
msgstr "{: .challenge}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:312
msgid "> ## Listing in Reverse Chronological Order"
msgstr "> ## Виведення у зворотному хронологічному порядку"

#: shell-novice/_episodes/02-filedir.md:313
msgid ""
">\n"
"> By default, `ls` lists the contents of a directory in alphabetical\n"
"> order by name. The command `ls -t` lists items by time of last\n"
"> change instead of alphabetically. The command `ls -r` lists the\n"
"> contents of a directory in reverse order.\n"
"> Which file is displayed last when you combine the `-t` and `-r` options?\n"
"> Hint: You may need to use the `-l` option to see the\n"
"> last changed dates.\n"
">\n"
"> > ## Solution\n"
"> > The most recently changed file is listed last when using `-rt`. This\n"
"> > can be very useful for finding your most recent edits or checking to\n"
"> > see if a new output file was written."
msgstr ""
">\n"
"> За замовчуванням `ls` виводить вміст каталогу в алфавітному\n"
"> порядку за іменами елементів. Команда `ls -t` перелічує елементи за часом останньої\n"
"> зміни, а не за алфавітом. Команда `ls -r` виводить\n"
"> вміст каталогу у зворотному порядку.\n"
"> Який файл буде показано останнім при комбінації команд `-t` і `-r`?\n"
"> Підказка: Вам може знадобитися скористатися опцією `-l`, щоб переглянути\n"
"> дати останніх змін.\n"
">\n"
"> > ## Рішення\n"
"> > При використанні `-rt` останній змінений файл відображається останнім у списку. Це\n"
"> > може бути дуже корисним для пошуку ваших останніх редагувань або перевірки\n"
"> > чи було створено новий вихідний файл."

# header
#: shell-novice/_episodes/02-filedir.md:329
msgid "### Exploring Other Directories"
msgstr "### Огляд інших каталогів"

#: shell-novice/_episodes/02-filedir.md:331
msgid ""
"Not only can we use `ls` on the current working directory,\n"
"but we can use it to list the contents of a different directory.\n"
"Let's take a look at our `Desktop` directory by running `ls -F Desktop`,\n"
"i.e.,\n"
"the command `ls` with the `-F` **option** and the [**argument**][Arguments]  `Desktop`.\n"
"The argument `Desktop` tells `ls` that\n"
"we want a listing of something other than our current working directory:"
msgstr ""
"Ми можемо використовувати `ls` не лише у поточному робочому каталозі,\n"
"але ми також можемо використовувати його для виведення вмісту іншого каталогу.\n"
"Давайте подивимося на наш каталог `Desktop` (робочий стіл), виконавши `ls -F Desktop`,\n"
"тобто,\n"
"команду `ls` з `-F` **опцією** і [**аргументом**] [Arguments] `Desktop`.\n"
"Аргумент `Desktop` повідомляє `ls`, що\n"
"ми хочемо отримати список чогось іншого, ніж наш поточний робочий каталог:"

# code block
#: shell-novice/_episodes/02-filedir.md:339
msgid ""
"~~~\n"
"$ ls -F Desktop\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls -F Desktop\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:344
msgid ""
"~~~\n"
"shell-lesson-data/\n"
"~~~"
msgstr ""
"~~~\n"
"shell-lesson-data/\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:349
msgid ""
"Note that if a directory named `Desktop` does not exist in your current working directory,\n"
"this command will return an error. Typically, a `Desktop` directory exists in your\n"
"home directory, which we assume is the current working directory of your bash shell."
msgstr ""
"Зауважте, що якщо у вашому поточному робочому каталозі не існує каталогу з назвою `Desktop`,\n"
"ця команда поверне помилку. Зазвичай, каталог `Desktop` існує у вашому\n"
"домашньому каталозі, який ми вважаємо поточним робочим каталогом вашого терміналу bash."

#: shell-novice/_episodes/02-filedir.md:353
msgid ""
"Your output should be a list of all the files and sub-directories in your\n"
"Desktop directory, including the `shell-lesson-data` directory you downloaded at\n"
"the [setup for this lesson]({{ page.root }}{% link setup.md %}).\n"
"On many systems,\n"
"the command line Desktop directory is the same as your GUI Desktop.\n"
"Take a look at your Desktop to confirm that your output is accurate."
msgstr ""
"На виході ви маєте отримати список усіх файлів і підкаталогів у вашому\n"
"каталозі Desktop, включно з каталогом `shell-lesson-data`, який ви завантажили за посиланням\n"
"під час [налаштування цього уроку]({{ page.root }}{% link setup.md %}).\n"
"У багатьох системах\n"
"каталог Desktop командного рядка збігається з каталогом Desktop вашого графічного інтерфейсу.\n"
"Подивіться на свій робочий стіл, щоб переконатися у правильності виведених даних."

#: shell-novice/_episodes/02-filedir.md:360
msgid ""
"As you may now see, using a bash shell is strongly dependent on the idea that\n"
"your files are organized in a hierarchical file system.\n"
"Organizing things hierarchically in this way helps us keep track of our work:\n"
"it's possible to put hundreds of files in our home directory,\n"
"just as it's possible to pile hundreds of printed papers on our desk,\n"
"but it's a self-defeating strategy."
msgstr ""
"Як ви тепер бачите, використання терміналу bash сильно залежить від того, що\n"
"ваші файли організовано в ієрархічній файловій системі.\n"
"Ієрархічна організація речей таким чином допомагає нам відстежувати нашу роботу:\n"
"у нашому домашньому каталозі можуть бути сотні файлів,\n"
"так само, як можна скласти сотні роздрукованих паперів на столі,\n"
"але це самогубна стратегія."

#: shell-novice/_episodes/02-filedir.md:367
msgid ""
"Now that we know the `shell-lesson-data` directory is located in our Desktop directory, we\n"
"can do two things."
msgstr ""
"Тепер, коли ми знаємо, що каталог `shell-lesson-data` розташовано у каталозі Desktop, ми\n"
"можемо зробити дві речі."

#: shell-novice/_episodes/02-filedir.md:370
msgid ""
"First, we can look at its contents, using the same strategy as before, passing\n"
"a directory name to `ls`:"
msgstr ""
"По-перше, ми можемо переглянути його вміст, використовуючи ту ж стратегію, що і раніше, передавши\n"
"ім'я каталогу в `ls`:"

# code block
#: shell-novice/_episodes/02-filedir.md:373
msgid ""
"~~~\n"
"$ ls -F Desktop/shell-lesson-data\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls -F Desktop/shell-lesson-data\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:378
msgid ""
"~~~\n"
"exercise-data/  north-pacific-gyre/\n"
"~~~"
msgstr ""
"~~~\n"
"exercise-data/  north-pacific-gyre/\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:383
msgid ""
"Second, we can actually change our location to a different directory, so\n"
"we are no longer located in\n"
"our home directory."
msgstr ""
"По-друге, ми можемо фактично змінити наше місцезнаходження на інший каталог, щоб\n"
"ми більше не знаходилися в\n"
"в нашому домашньому каталозі."

#: shell-novice/_episodes/02-filedir.md:387
msgid ""
"The command to change locations is `cd` followed by a\n"
"directory name to change our working directory.\n"
"`cd` stands for 'change directory',\n"
"which is a bit misleading:\n"
"the command doesn't change the directory;\n"
"it changes the shell's current working directory.\n"
"In other words it changes the shell's idea of what directory we are in.\n"
"The `cd` command is akin to double-clicking a folder in a graphical interface to get into a folder."
msgstr ""
"Команда зміни розташування в файловій системі має вигляд `cd`, за якою зазначається\n"
"ім'я каталогу, на який треба змінити наш робочий каталог.\n"
"`cd` означає 'змінити каталог' (англ. 'change directory'),\n"
"що трохи вводить в оману:\n"
"команда не змінює каталог;\n"
"вона змінює поточний робочий каталог терміналу.\n"
"Іншими словами, вона змінює уявлення терміналу про те, у якому каталозі ми перебуваємо.\n"
"Команда `cd` подібна до подвійного кліку на каталозі у графічному інтерфейсі, щоб потрапити до нього."

#: shell-novice/_episodes/02-filedir.md:396
msgid ""
"Let's say we want to move into the `exercise-data` directory we saw above. We can\n"
"use the following series of commands to get there:"
msgstr ""
"Припустимо, ми хочемо перейти до каталогу `exercise-data`, який ми бачили вище. Ми можемо\n"
"скористатися наступною серією команд, щоб дістатися туди:"

# code block
#: shell-novice/_episodes/02-filedir.md:399
msgid ""
"~~~\n"
"$ cd Desktop\n"
"$ cd shell-lesson-data\n"
"$ cd exercise-data\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd Desktop\n"
"$ cd shell-lesson-data\n"
"$ cd exercise-data\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:406
msgid ""
"These commands will move us from our home directory into our Desktop directory, then into\n"
"the `shell-lesson-data` directory, then into the `exercise-data` directory.\n"
"You will notice that `cd` doesn't print anything. This is normal.\n"
"Many shell commands will not output anything to the screen when successfully executed.\n"
"But if we run `pwd` after it, we can see that we are now\n"
"in `/Users/nelle/Desktop/shell-lesson-data/exercise-data`."
msgstr ""
"Ці команди перемістять нас з домашнього каталогу до каталогу Desktop, потім до\n"
"каталогу `shell-lesson-data`, а потім до каталогу `exercise-data`.\n"
"Ви помітите, що команда `cd` нічого не виводить. Це нормально.\n"
"Багато команд терміналу нічого не виводять на екран у разі успішного виконання.\n"
"Але якщо ми виконаємо `pwd` після неї, то побачимо, що зараз ми знаходимося\n"
"у `/Users/nelle/Desktop/shell-lesson-data/exercise-data`."

#: shell-novice/_episodes/02-filedir.md:413
msgid ""
"If we run `ls -F` without arguments now,\n"
"it lists the contents of `/Users/nelle/Desktop/shell-lesson-data/exercise-data`,\n"
"because that's where we now are:"
msgstr ""
"Якщо ми зараз виконаємо команду `ls -F` без аргументів,\n"
"вона виведе вміст `/Users/nelle/Desktop/shell-lesson-data/exercise-data`,\n"
"тому що саме там ми зараз знаходимося:"

# code block
#: shell-novice/_episodes/02-filedir.md:422
#: shell-novice/_episodes/02-filedir.md:581
msgid ""
"~~~\n"
"/Users/nelle/Desktop/shell-lesson-data/exercise-data\n"
"~~~"
msgstr ""
"~~~\n"
"/Users/nelle/Desktop/shell-lesson-data/exercise-data\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:432
msgid ""
"~~~\n"
"animal-counts/  creatures/  numbers.txt  proteins/  writing/\n"
"~~~"
msgstr ""
"~~~\n"
"animal-counts/  creatures/  numbers.txt  proteins/  writing/\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:437
msgid ""
"We now know how to go down the directory tree (i.e. how to go into a subdirectory),\n"
"but how do we go up (i.e. how do we leave a directory and go into its parent directory)?\n"
"We might try the following:"
msgstr ""
"Тепер ми знаємо, як спускатися вниз по дереву каталогів (тобто, як увійти до підкаталогу),\n"
"але як піднятися вгору (тобто як вийти з каталогу і перейти до його батьківського каталогу)?\n"
"Ми можемо спробувати наступне:"

# code block
#: shell-novice/_episodes/02-filedir.md:441
msgid ""
"~~~\n"
"$ cd shell-lesson-data\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd shell-lesson-data\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:446
msgid ""
"~~~\n"
"-bash: cd: shell-lesson-data: No such file or directory\n"
"~~~"
msgstr ""
"~~~\n"
"-bash: cd: shell-lesson-data: No such file or directory\n"
"~~~"

# SC/DC Template label
#: shell-novice/_episodes/02-filedir.md:449
#: shell-novice/_episodes/03-create.md:392
#: shell-novice/_episodes/03-create.md:583
#: shell-novice/_episodes/03-create.md:627
#: shell-novice/_episodes/05-loop.md:500
msgid "{: .error}"
msgstr "{: .error}"

#: shell-novice/_episodes/02-filedir.md:451
msgid "But we get an error! Why is this?"
msgstr "Але ми отримуємо помилку! Чому?"

#: shell-novice/_episodes/02-filedir.md:453
msgid ""
"With our methods so far,\n"
"`cd` can only see sub-directories inside your current directory. There are\n"
"different ways to see directories above your current location; we'll start\n"
"with the simplest."
msgstr ""
"За допомогою наших методів, використовуваних до цього,\n"
"`cd` може бачити лише підкаталоги у вашому поточному каталозі. Існують\n"
"різні способи перегляду каталогів над вашим поточним розташуванням; ми почнемо\n"
"з найпростішого."

#: shell-novice/_episodes/02-filedir.md:458
msgid ""
"There is a shortcut in the shell to move up one directory level\n"
"that looks like this:"
msgstr ""
"В терміналі є скорочення для переходу на один рівень каталогу вгору,\n"
"який виглядає так:"

# code block
#: shell-novice/_episodes/02-filedir.md:461
msgid ""
"~~~\n"
"$ cd ..\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd ..\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:466
msgid ""
"`..` is a special directory name meaning\n"
"\"the directory containing this one\",\n"
"or more succinctly,\n"
"the **parent** of the current directory.\n"
"Sure enough,\n"
"if we run `pwd` after running `cd ..`, we're back in `/Users/nelle/Desktop/shell-lesson-data`:"
msgstr ""
"`..` -- це спеціальне ім'я каталогу, що означає\n"
"\"каталог, що містить цей\",\n"
"або більш стисло,\n"
"**батько** поточного каталогу.\n"
"Звичайно,\n"
"якщо ми запустимо `pwd` після виконання `cd ..`, ми знову у `/Users/nelle/Desktop/shell-lesson-data`:"

# code block
#: shell-novice/_episodes/02-filedir.md:478
#: shell-novice/_episodes/03-create.md:40
msgid ""
"~~~\n"
"/Users/nelle/Desktop/shell-lesson-data\n"
"~~~"
msgstr ""
"~~~\n"
"/Users/nelle/Desktop/shell-lesson-data\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:483
msgid ""
"The special directory `..` doesn't usually show up when we run `ls`. If we want\n"
"to display it, we can add the `-a` option to `ls -F`:"
msgstr ""
"Спеціальний каталог `..` зазвичай не з'являється, коли ми запускаємо `ls`. Якщо ми хочемо\n"
"відобразити його, ми можемо додати опцію `-a` до `ls -F`:"

# code block
#: shell-novice/_episodes/02-filedir.md:486
msgid ""
"~~~\n"
"$ ls -F -a\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls -F -a\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:491
msgid ""
"~~~\n"
"./  ../  exercise-data/  north-pacific-gyre/\n"
"~~~"
msgstr ""
"~~~\n"
"./  ../  exercise-data/  north-pacific-gyre/\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:496
msgid ""
"`-a` stands for 'show all' (including hidden files);\n"
"it forces `ls` to show us file and directory names that begin with `.`,\n"
"such as `..` (which, if we're in `/Users/nelle`, refers to the `/Users` directory).\n"
"As you can see,\n"
"it also displays another special directory that's just called `.`,\n"
"which means 'the current working directory'.\n"
"It may seem redundant to have a name for it,\n"
"but we'll see some uses for it soon."
msgstr ""
"`-a` означає 'показати все' (англ. show all) (включно з прихованими файлами);\n"
"опція змушує `ls` показувати нам імена файлів і каталогів, які починаються з `.`,\n"
"наприклад, `..` (яке, якщо ми знаходимося у `/Users/nelle`, вказує на каталог `/Users`).\n"
"Як ви можете бачити,\n"
"команда також показує ще один спеціальний каталог, який називається `.`,\n"
"що означає 'поточний робочий каталог'.\n"
"Може здатися, що це дещо надлишково - мати для нього ім'я,\n"
"але незабаром ми побачимо, як воно може бути використано."

#: shell-novice/_episodes/02-filedir.md:505
msgid ""
"Note that in most command line tools, multiple options can be combined\n"
"with a single `-` and no spaces between the options: `ls -F -a` is\n"
"equivalent to `ls -Fa`."
msgstr ""
"Зауважте, що у більшості інструментів командного рядка можна комбінувати декілька параметрів\n"
"за допомогою одного `-` і без пробілів між параметрами: `ls -F -a` є\n"
"еквівалентним до `ls -Fa`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:509
msgid "> ## Other Hidden Files"
msgstr "> ## Інші приховані файли"

#: shell-novice/_episodes/02-filedir.md:510
msgid ""
">\n"
"> In addition to the hidden directories `..` and `.`, you may also see a file\n"
"> called `.bash_profile`. This file usually contains shell configuration\n"
"> settings. You may also see other files and directories beginning\n"
"> with `.`. These are usually files and directories that are used to configure\n"
"> different programs on your computer. The prefix `.` is used to prevent these\n"
"> configuration files from cluttering the terminal when a standard `ls` command\n"
"> is used."
msgstr ""
">\n"
"> Крім прихованих каталогів `..` і `.`, ви також можете побачити файл\n"
"> який називається `.bash_profile`. Цей файл зазвичай містить конфігурацію терміналу\n"
"> Ви також можете побачити інші файли і каталоги, що починаються\n"
"> з `.`. Зазвичай це файли і каталоги, які використовуються для налаштування\n"
"> різних програм на вашому комп'ютері. Префікс `.` використовується для того, щоб ці\n"
"> конфігураційні файли не захаращували термінал, коли використовується стандартна команда `ls`."

#: shell-novice/_episodes/02-filedir.md:520
msgid ""
"These three commands are the basic commands for navigating the filesystem on your computer:\n"
"`pwd`, `ls`, and `cd`. Let's explore some variations on those commands. What happens\n"
"if you type `cd` on its own, without giving\n"
"a directory?"
msgstr ""
"Ці три команди є основними командами для навігації по файловій системі на вашому комп'ютері:\n"
"`pwd`, `ls` і `cd`. Давайте розглянемо деякі варіації цих команд. Що станеться\n"
"якщо ви введете команду `cd` саму по собі, без зазначення\n"
"каталогу?"

# code block
#: shell-novice/_episodes/02-filedir.md:525
msgid ""
"~~~\n"
"$ cd\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:530
msgid "How can you check what happened? `pwd` gives us the answer!"
msgstr "Як ви можете перевірити, що сталося? Команда `pwd` дає нам відповідь!"

#: shell-novice/_episodes/02-filedir.md:542
msgid ""
"It turns out that `cd` without an argument will return you to your home directory,\n"
"which is great if you've got lost in your own filesystem."
msgstr ""
"Виявляється, `cd` без аргументу поверне вас до домашнього каталогу,\n"
"що дуже зручно, якщо ви загубилися у власній файловій системі."

#: shell-novice/_episodes/02-filedir.md:545
msgid ""
"Let's try returning to the `exercise-data` directory from before. Last time, we used\n"
"three commands, but we can actually string together the list of directories\n"
"to move to `exercise-data` in one step:"
msgstr ""
"Спробуємо повернутися до каталогу `exercise-data` з попереднього. Минулого разу ми використовували\n"
"три команди, але насправді ми можемо поєднати перелік каталогів\n"
"для переходу до каталогу `exercise-data` за один крок:"

# code block
#: shell-novice/_episodes/02-filedir.md:549
msgid ""
"~~~\n"
"$ cd Desktop/shell-lesson-data/exercise-data\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd Desktop/shell-lesson-data/exercise-data\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:554
msgid ""
"Check that we've moved to the right place by running `pwd` and `ls -F`."
msgstr ""
"Переконайтеся, що ми перемістилися в потрібне місце, виконавши `pwd` і `ls "
"-F`."

#: shell-novice/_episodes/02-filedir.md:556
msgid ""
"If we want to move up one level from the data directory, we could use `cd ..`.  But\n"
"there is another way to move to any directory, regardless of your\n"
"current location."
msgstr ""
"Якщо ми хочемо перейти на один рівень вище від каталогу даних, ми можемо використати `cd ..`. Але\n"
"існує інший спосіб переміщення до будь-якого каталогу, незалежно від вашого\n"
"поточного розташування."

#: shell-novice/_episodes/02-filedir.md:560
msgid ""
"So far, when specifying directory names, or even a directory path (as above),\n"
"we have been using **relative paths**.  When you use a relative path with a command\n"
"like `ls` or `cd`, it tries to find that location from where we are,\n"
"rather than from the root of the file system."
msgstr ""
"Дотепер, коли ми вказували імена каталогів або навіть шлях до каталогів (як описано вище),\n"
"ми використовували **відносні шляхи**. Коли ви використовуєте відносний шлях за допомогою команди\n"
"на кшталт `ls` або `cd`, вона намагається знайти це місце з того місця, де ми перебуваємо,\n"
"а не з кореня файлової системи."

#: shell-novice/_episodes/02-filedir.md:565
msgid ""
"However, it is possible to specify the **absolute path** to a directory by\n"
"including its entire path from the root directory, which is indicated by a\n"
"leading slash. The leading `/` tells the computer to follow the path from\n"
"the root of the file system, so it always refers to exactly one directory,\n"
"no matter where we are when we run the command."
msgstr ""
"Втім, можна зазначити **абсолютний шлях** до каталогу за допомогою\n"
"включивши до нього повний шлях від кореневого каталогу, який позначається символом\n"
"скісної риски (слешу). Символ `/` на початку абсолютного шляху вказує комп'ютеру йти за шляхом від\n"
"кореня файлової системи, тому він завжди вказує лише на один і той самий каталог,\n"
"незалежно від того, де ми знаходимося під час виконання команди."

#: shell-novice/_episodes/02-filedir.md:571
msgid ""
"This allows us to move to our `shell-lesson-data` directory from anywhere on\n"
"the filesystem (including from inside `exercise-data`). To find the absolute path\n"
"we're looking for, we can use `pwd` and then extract the piece we need\n"
"to move to `shell-lesson-data`."
msgstr ""
"Це дає змогу перейти до каталогу `shell-lesson-data` з будь-якого місця у файловій системі\n"
"файлової системи (у тому числі з каталогу `exercise-data`). Щоб знайти абсолютний шлях\n"
"ми можемо скористатися `pwd`, а потім витягти потрібний нам фрагмент,\n"
"шоб перейти до `shell-lesson-data`."

# code block
#: shell-novice/_episodes/02-filedir.md:586
msgid ""
"~~~\n"
"$ cd /Users/nelle/Desktop/shell-lesson-data\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd /Users/nelle/Desktop/shell-lesson-data\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:591
msgid "Run `pwd` and `ls -F` to ensure that we're in the directory we expect."
msgstr ""
"Виконайте `pwd` і `ls -F`, щоб переконатися, що ми знаходимося в потрібному "
"каталозі."

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:593
msgid "> ## Two More Shortcuts"
msgstr "> ## Ще два скорочення"

#: shell-novice/_episodes/02-filedir.md:594
msgid ""
">\n"
"> The shell interprets a tilde (`~`) character at the start of a path to\n"
"> mean \"the current user's home directory\". For example, if Nelle's home\n"
"> directory is `/Users/nelle`, then `~/data` is equivalent to\n"
"> `/Users/nelle/data`. This only works if it is the first character in the\n"
"> path: `here/there/~/elsewhere` is *not* `here/there/Users/nelle/elsewhere`.\n"
">\n"
"> Another shortcut is the `-` (dash) character. `cd` will translate `-` into\n"
"> *the previous directory I was in*, which is faster than having to remember,\n"
"> then type, the full path.  This is a *very* efficient way of moving\n"
"> *back and forth between two directories* -- i.e. if you execute `cd -` twice,\n"
"> you end up back in the starting directory.\n"
">\n"
"> The difference between `cd ..` and `cd -` is\n"
"> that the former brings you *up*, while the latter brings you *back*.\n"
">\n"
"> ----\n"
"> Try it!\n"
"> First navigate to `~/Desktop/shell-lesson-data` (you should already be there).\n"
"> ~~~\n"
"> $ cd ~/Desktop/shell-lesson-data\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Then `cd` into the `exercise-data/creatures` directory\n"
"> ~~~\n"
"> $ cd exercise-data/creatures\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Now if you run\n"
"> ~~~\n"
"> $ cd -\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> you'll see you're back in `~/Desktop/shell-lesson-data`.\n"
"> Run `cd -` again and you're back in `~/Desktop/shell-lesson-data/exercise-data/creatures`"
msgstr ""
">\n"
"> Термінал інтерпретує символ тильди (`~`) на початку шляху як\n"
"> \"домашній каталог поточного користувача\". Наприклад, якщо домашнім каталогом користувача Неллі\n"
"> є каталог `/Users/nelle`, то `~/data` еквівалентно\n"
"> `/Users/nelle/data`. Це працює лише у випадку, якщо це перший символ у\n"
"> шляху: `here/there/~/elsewhere` *не* дорівнює `here/there/Users/nelle/elsewhere`.\n"
">\n"
"> Іншим скороченням є символ `-` (тире). `cd` транслює `-` у\n"
"> *попередній каталог, у якому я був*, що швидше, ніж запам'ятовувати,\n"
"> а потім набирати повний шлях. Це *дуже* ефективний спосіб переміщення\n"
"> *вперед і назад між двома каталогами* - тобто, якщо ви виконаєте `cd -` двічі,\n"
"> ви повернетесь до початкового каталогу.\n"
">\n"
"> Різниця між `cd ..` і `cd -` полягає в тому,\n"
"> що перший повертає вас *вгору*, тоді як другий повертає вас *назад*.\n"
">\n"
"> ----\n"
"> Спробуйте!\n"
"> Спочатку перейдіть до `~/Desktop/shell-lesson-data` (ви вже маєте бути там).\n"
"> ~~~\n"
"> $ cd ~/Desktop/shell-lesson-data\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Потім `cd` у каталог `exercise-data/creatures`.\n"
"> ~~~\n"
"> $ cd exercise-data/creatures\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Тепер, якщо ви виконаєте\n"
"> ~~~\n"
"> $ cd -\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ви побачите, що повернулися до `~/Desktop/shell-lesson-data`.\n"
"> Запустіть `cd -` ще раз і ви повернетесь до `~/Desktop/shell-lesson-data/exercise-data/creatures`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:633
msgid "> ## Absolute vs Relative Paths"
msgstr "> ## Абсолютні та відносні шляхи"

#: shell-novice/_episodes/02-filedir.md:634
msgid ""
">\n"
"> Starting from `/Users/amanda/data`,\n"
"> which of the following commands could Amanda use to navigate to her home directory,\n"
"> which is `/Users/amanda`?\n"
">\n"
"> 1. `cd .`\n"
"> 2. `cd /`\n"
"> 3. `cd /home/amanda`\n"
"> 4. `cd ../..`\n"
"> 5. `cd ~`\n"
"> 6. `cd home`\n"
"> 7. `cd ~/data/..`\n"
"> 8. `cd`\n"
"> 9. `cd ..`\n"
">\n"
"> > ## Solution\n"
"> > 1. No: `.` stands for the current directory.\n"
"> > 2. No: `/` stands for the root directory.\n"
"> > 3. No: Amanda's home directory is `/Users/amanda`.\n"
"> > 4. No: this command goes up two levels, i.e. ends in `/Users`.\n"
"> > 5. Yes: `~` stands for the user's home directory, in this case `/Users/amanda`.\n"
"> > 6. No: this command would navigate into a directory `home` in the current directory\n"
"> >     if it exists.\n"
"> > 7. Yes: unnecessarily complicated, but correct.\n"
"> > 8. Yes: shortcut to go back to the user's home directory.\n"
"> > 9. Yes: goes up one level."
msgstr ""
">\n"
"> Починаючи з `/Users/amanda/data`,\n"
"> яку з наведених нижче команд Аманда може використати для переходу до свого домашнього каталогу,\n"
"> тобто `/Users/amanda`?\n"
">\n"
"> 1. `cd .`\n"
"> 2. `cd /`\n"
"> 3. `cd /home/amanda`.\n"
"> 4. `cd ../..`\n"
"> 5. `cd ~`\n"
"> 6. `cd home`\n"
"> 7. `cd ~/data/..`\n"
"> 8. `cd`\n"
"> 9. `cd ..`\n"
">\n"
"> > ## Розв'язання\n"
"> > 1. Ні: скорочення `.` означає поточний каталог.\n"
"> > 2. Ні: скорочення `/` означає кореневий каталог.\n"
"> > 3. Ні: домашнім каталогом Аманди є `/Users/amanda`.\n"
"> > 4. Ні: ця команда піднімається на два рівні, тобто закінчується на `/Users`.\n"
"> > 5. Так: скорочення `~` позначає домашній каталог користувача, у цьому випадку `/Users/amanda`.\n"
"> > 6. Ні: ця команда виконає перехід до каталогу `home` у поточному каталозі\n"
"> > якщо він існує.\n"
"> > 7. Так: надмірно складна, але правильна.\n"
"> > 8. Так: комбінація клавіш для повернення до домашнього каталогу користувача.\n"
"> > 9. Так: піднімається на один рівень."

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:663
msgid "> ## Relative Path Resolution"
msgstr "> ## Розв'язання відносного шляху"

#: shell-novice/_episodes/02-filedir.md:664
msgid ""
">\n"
"> Using the filesystem diagram below, if `pwd` displays `/Users/thing`,\n"
"> what will `ls -F ../backup` display?\n"
">\n"
"> 1.  `../backup: No such file or directory`\n"
"> 2.  `2012-12-01 2013-01-08 2013-01-27`\n"
"> 3.  `2012-12-01/ 2013-01-08/ 2013-01-27/`\n"
"> 4.  `original/ pnas_final/ pnas_sub/`\n"
">\n"
"> ![A directory tree below the Users directory where \"/Users\" contains the\n"
"directories \"backup\" and \"thing\"; \"/Users/backup\" contains \"original\",\n"
"\"pnas_final\" and \"pnas_sub\"; \"/Users/thing\" contains \"backup\"; and\n"
"\"/Users/thing/backup\" contains \"2012-12-01\", \"2013-01-08\" and\n"
"\"2013-01-27\"](../fig/filesystem-challenge.svg)\n"
">\n"
"> > ## Solution\n"
"> > 1. No: there *is* a directory `backup` in `/Users`.\n"
"> > 2. No: this is the content of `Users/thing/backup`,\n"
"> >    but with `..`, we asked for one level further up.\n"
"> > 3. No: see previous explanation.\n"
"> > 4. Yes: `../backup/` refers to `/Users/backup/`."
msgstr ""
">\n"
"> Використовуючи наведену нижче схему файлової системи, якщо `pwd` показує `/Users/thing`,\n"
"> що покаже команда `ls -F ../backup`?\n"
">\n"
"> 1. `../backup: Не існує такого файлу або каталогу`\n"
"> 2. `2012-12-01 2013-01-08 2013-01-27`\n"
"> 3. `2012-12-01/ 2013-01-08/ 2013-01-27/`\n"
"> 4. `original/ pnas_final/ pnas_sub/`\n"
">\n"
"> ![Дерево каталогів під каталогом Users, де \"/Users\" містить\n"
"каталоги \"backup\" і \"thing\"; \"/Users/backup\" містить \"original\",\n"
"\"pnas_final\" та \"pnas_sub\"; \"/Users/thing\" містить \"backup\"; та\n"
"\"/Users/thing/backup\" містить \"2012-12-01\", \"2013-01-08\" та\n"
"\"2013-01-27\"](../fig/filesystem-challenge.svg)\n"
">\n"
"> > Розв'язання\n"
"> > 1. Ні: у каталозі `/Users` існує каталог `backup`.\n"
"> > 2. Ні: це вміст каталогу `Users/thing/backup`,\n"
"> > але за допомогою `..` ми просили піднятися на один рівень вище.\n"
"> > 3. Ні: див. попереднє пояснення.\n"
"> > 4. Так: `../backup/` вказує на `/Users/backup/`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/02-filedir.md:688
msgid "> ## `ls` Reading Comprehension"
msgstr "> ## Розуміння прочитаного про команду `ls`"

#: shell-novice/_episodes/02-filedir.md:689
msgid ""
">\n"
"> Using the filesystem diagram below,\n"
"> if `pwd` displays `/Users/backup`,\n"
"> and `-r` tells `ls` to display things in reverse order,\n"
"> what command(s) will result in the following output:\n"
">\n"
"> ~~~\n"
"> pnas_sub/ pnas_final/ original/\n"
"> ~~~"
msgstr ""
">\n"
"> Використовуючи схему файлової системи, наведену нижче,\n"
"> якщо `pwd` показує `/Users/backup`,\n"
"> а `-r` каже `ls` виводити все у зворотному порядку,\n"
"> яка команда (команди) призведе до наступного виводу:\n"
">\n"
"> ~~~\n"
"> pnas_sub/ pnas_final/ original/\n"
"> ~~~"

#: shell-novice/_episodes/02-filedir.md:699
msgid ""
">\n"
"> ![A directory tree below the Users directory where \"/Users\" contains the\n"
"directories \"backup\" and \"thing\"; \"/Users/backup\" contains \"original\",\n"
"\"pnas_final\" and \"pnas_sub\"; \"/Users/thing\" contains \"backup\"; and\n"
"\"/Users/thing/backup\" contains \"2012-12-01\", \"2013-01-08\" and\n"
"\"2013-01-27\"](../fig/filesystem-challenge.svg)\n"
">\n"
"> 1.  `ls pwd`\n"
"> 2.  `ls -r -F`\n"
"> 3.  `ls -r -F /Users/backup`\n"
">\n"
"> > ## Solution\n"
"> >  1. No: `pwd` is not the name of a directory.\n"
"> >  2. Yes: `ls` without directory argument lists files and directories\n"
"> >     in the current directory.\n"
"> >  3. Yes: uses the absolute path explicitly."
msgstr ""
">\n"
"> ![Дерево каталогів під каталогом Users, де \"/Users\" містить\n"
"каталоги \"backup\" та \"thing\"; \"/Users/backup\" містить \"original\",\n"
"\"pnas_final\" та \"pnas_sub\"; \"/Users/thing\" містить \"backup\"; та\n"
"\"/Users/thing/backup\" містить \"2012-12-01\", \"2013-01-08\" та\n"
"\"2013-01-27\"](../fig/filesystem-challenge.svg)\n"
">\n"
"> 1. `ls pwd`\n"
"> 2. `ls -r -F`\n"
"> 3. `ls -r -F /Users/backup`\n"
">\n"
"> > ## Рішення\n"
"> > 1. Ні: `pwd` не є назвою каталогу.\n"
"> > 2. Так: команда `ls` без аргументу каталогу перелічує файли і каталоги\n"
"> >      у поточному каталозі.\n"
"> > 3. Так: явно використовує абсолютний шлях."

# header
#: shell-novice/_episodes/02-filedir.md:719
msgid "## General Syntax of a Shell Command"
msgstr "## Загальний синтаксис команди терміналу"

#: shell-novice/_episodes/02-filedir.md:720
msgid ""
"We have now encountered commands, options, and arguments,\n"
"but it is perhaps useful to formalise some terminology."
msgstr ""
"Ми вже познайомилися з командами, опціями та аргументами,\n"
"але, можливо, буде корисно формалізувати деяку термінологію."

#: shell-novice/_episodes/02-filedir.md:723
msgid ""
"Consider the command below as a general example of a command,\n"
"which we will dissect into its component parts:"
msgstr ""
"Розглянемо команду нижче як загальний приклад команди,\n"
"яку ми розберемо на складові частини:"

# code block
#: shell-novice/_episodes/02-filedir.md:726
#: shell-novice/_episodes/02-filedir.md:783
msgid ""
"~~~\n"
"$ ls -F /\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls -F /\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:731
msgid "![General syntax of a shell command](../fig/shell_command_syntax.svg)"
msgstr ""
"![Загальний синтаксис команди терміналу](../fig/shell_command_syntax.svg)"

#: shell-novice/_episodes/02-filedir.md:733
msgid ""
"`ls` is the **command**, with an **option** `-F` and an\n"
"**argument** `/`.\n"
"We've already encountered options  which\n"
"either start with a single dash (`-`) or two dashes (`--`),\n"
"and they change the behavior of a command.\n"
"[Arguments] tell the command what to operate on (e.g. files and directories).\n"
"Sometimes options and arguments are referred to as **parameters**.\n"
"A command can be called with more than one option and more than one argument, but a\n"
"command doesn't always require an argument or an option."
msgstr ""
"`ls` - це **команда**, з **опцією** `-F` та\n"
"**аргументом** `/`.\n"
"Ми вже зустрічалися з опціями, які\n"
"починаються з одного тире (`-`) або двох тире (`--`),\n"
"і вони змінюють поведінку команди.\n"
"[Аргументи] вказують команді, з чим працювати (наприклад, з файлами і каталогами).\n"
"Іноді опції та аргументи називають **параметрами**.\n"
"Команду можна викликати з більш ніж одним параметром і більш ніж одним аргументом, але команда\n"
"не завжди вимагає наявності аргументу або параметра."

#: shell-novice/_episodes/02-filedir.md:743
msgid ""
"You might sometimes see options being referred to as **switches** or **flags**,\n"
"especially for options that take no argument. In this lesson we will stick with\n"
"using the term *option*."
msgstr ""
"Іноді ви можете побачити, що опції називають **перемикачами** або **прапорами**,\n"
"особливо для параметрів, які не потребують аргументації. У цьому уроці ми будемо дотримуватися\n"
"терміну *опція*."

#: shell-novice/_episodes/02-filedir.md:747
msgid ""
"Each part is separated by spaces: if you omit the space\n"
"between `ls` and `-F` the shell will look for a command called `ls-F`, which\n"
"doesn't exist. Also, capitalization can be important.\n"
"For example, `ls -s` will display the size of files and directories alongside the names,\n"
"while `ls -S` will sort the files and directories by size, as shown below:"
msgstr ""
"Кожна частина відокремлюється пробілами: якщо ви пропустите пробіл\n"
"між `ls` і `-F`, термінал шукатиме команду з назвою `ls-F`, якої\n"
"не існує. Також може бути важливим написання великої літери.\n"
"Наприклад, `ls -s` покаже розмір файлів і каталогів поряд з назвами,\n"
"а `ls -S` відсортує файли і каталоги за розміром, як показано нижче:"

# code block
#: shell-novice/_episodes/02-filedir.md:753
msgid ""
"~~~\n"
"$ cd ~/Desktop/shell-lesson-data\n"
"$ ls -s exercise-data\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd ~/Desktop/shell-lesson-data\n"
"$ ls -s exercise-data\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:759
msgid ""
"~~~\n"
"total 28\n"
" 4 animal-counts   4 creatures  12 numbers.txt   4 proteins   4 writing\n"
"~~~"
msgstr ""
"~~~\n"
"total 28\n"
" 4 animal-counts   4 creatures  12 numbers.txt   4 proteins   4 writing\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:765
msgid ""
"Note that the sizes returned by `ls -s` are in *blocks*. \n"
"As these are defined differently for different operating systems,\n"
"you may not obtain the same figures as in the example."
msgstr ""
"Зверніть увагу, що розміри, які повертає команда `ls -s`, подано у *блоках*. \n"
"Оскільки вони визначаються по-різному для різних операційних систем,\n"
"ви можете отримати не такі значення, як у прикладі."

# code block
#: shell-novice/_episodes/02-filedir.md:769
msgid ""
"~~~\n"
"$ ls -S exercise-data\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls -S exercise-data\n"
"~~~"

# code block
#: shell-novice/_episodes/02-filedir.md:774
msgid ""
"~~~\n"
"animal-counts  creatures  proteins  writing  numbers.txt\n"
"~~~"
msgstr ""
"~~~\n"
"animal-counts  creatures  proteins  writing  numbers.txt\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:779
msgid ""
"Putting all that together, our command above gives us a listing\n"
"of files and directories in the root directory `/`.\n"
"An example of the output you might get from the above command is given below:"
msgstr ""
"Зібравши все це разом, наша команда вище дасть нам список\n"
"файлів і каталогів у кореневому каталозі `/`.\n"
"Приклад результату, який ви можете отримати за допомогою наведеної вище команди, наведено нижче:"

# code block
#: shell-novice/_episodes/02-filedir.md:788
msgid ""
"~~~\n"
"Applications/         System/\n"
"Library/              Users/\n"
"Network/              Volumes/\n"
"~~~"
msgstr ""
"~~~\n"
"Applications/         System/\n"
"Library/              Users/\n"
"Network/              Volumes/\n"
"~~~"

# header
#: shell-novice/_episodes/02-filedir.md:796
msgid "### Nelle's Pipeline: Organizing Files"
msgstr "### Конвеєр Неллі: Організація файлів"

#: shell-novice/_episodes/02-filedir.md:798
msgid ""
"Knowing this much about files and directories,\n"
"Nelle is ready to organize the files that the protein assay machine will create."
msgstr ""
"Знаючи так багато про файли та каталоги,\n"
"Неллі готова впорядкувати файли, які створить машина для аналізу білків."

#: shell-novice/_episodes/02-filedir.md:801
msgid ""
"She creates a directory called `north-pacific-gyre`\n"
"(to remind herself where the data came from),\n"
"which will contain the data files from the assay machine,\n"
"and her data processing scripts."
msgstr ""
"Вона створює каталог під назвою `north-pacific-gyre`.\n"
"(щоб нагадати собі, звідки взялися дані),\n"
"яка міститиме файли даних з аналітичної машини,\n"
"та її скрипти для обробки даних."

#: shell-novice/_episodes/02-filedir.md:807
msgid ""
"Each of her physical samples is labelled according to her lab's convention\n"
"with a unique ten-character ID,\n"
"such as 'NENE01729A'.\n"
"This ID is what she used in her collection log\n"
"to record the location, time, depth, and other characteristics of the sample,\n"
"so she decides to use it as part of each data file's name.\n"
"Since the assay machine's output is plain text,\n"
"she will call her files `NENE01729A.txt`, `NENE01812A.txt`, and so on.\n"
"All 1520 files will go into the same directory."
msgstr ""
"Кожен її фізичний зразок маркується згідно з прийнятими в лабораторії правилами\n"
"з унікальним десятисимвольним ідентифікатором,\n"
"наприклад, \"NENE01729A\".\n"
"Цей ідентифікатор вона використовує у своєму журналі збору зразків\n"
"для запису місця, часу, глибини та інших характеристик зразка,\n"
"тому вона вирішила використовувати його як частину імені кожного файлу даних.\n"
"Оскільки результат роботи аналізатора є звичайним текстом,\n"
"вона назве свої файли `NENE01729A.txt`, `NENE01812A.txt` і так далі.\n"
"Усі 1520 файлів буде збережено в одному каталозі."

#: shell-novice/_episodes/02-filedir.md:818
msgid ""
"Now in her current directory `shell-lesson-data`,\n"
"Nelle can see what files she has using the command:"
msgstr ""
"Тепер у її поточному каталозі `shell-lesson-data`,\n"
"Нелл може побачити, які файли вона має за допомогою цієї команди:"

# code block
#: shell-novice/_episodes/02-filedir.md:821
#: shell-novice/_episodes/02-filedir.md:838
msgid ""
"~~~\n"
"$ ls north-pacific-gyre/\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls north-pacific-gyre/\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:826
msgid ""
"This command is a lot to type,\n"
"but she can let the shell do most of the work through what is called **tab completion**.\n"
"If she types:"
msgstr ""
"Для введення цієї команди потрібно багато набирати на клавіатурі,\n"
"але вона може дозволити терміналу виконати більшу частину роботи за допомогою так званого **завершення табуляції**.\n"
"Якщо вона небере:"

# code block
#: shell-novice/_episodes/02-filedir.md:830
msgid ""
"~~~\n"
"$ ls nor\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls nor\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:835
msgid ""
"and then presses <kbd>Tab</kbd> (the tab key on her keyboard),\n"
"the shell automatically completes the directory name for her:"
msgstr ""
"а потім натискає клавішу <kbd>Tab</kbd> (клавішу табуляції на її клавіатурі),\n"
"оболонка автоматично доповнить назву каталогу для неї:"

#: shell-novice/_episodes/02-filedir.md:843
msgid ""
"Pressing <kbd>Tab</kbd> again does nothing,\n"
"since there are multiple possibilities;\n"
"pressing <kbd>Tab</kbd> twice brings up a list of all the files."
msgstr ""
"Повторне натискання клавіші <kbd>Tab</kbd> нічого не дасть,\n"
"оскільки існує декілька варіантів;\n"
"якщо натиснути <kbd>Tab</kbd> двічі, буде показано список усіх файлів."

#: shell-novice/_episodes/02-filedir.md:847
msgid ""
"If Nelle adds <kbd>G</kbd> and presses <kbd>Tab</kbd> again,\n"
"the shell will append 'goo' since all files that start with 'g' share\n"
"the first three characters 'goo'."
msgstr ""
"Якщо Неллі додасть <kbd>G</kbd> і знову натисне <kbd>Tab</kbd>,\n"
"оболонка додасть 'goo', оскільки всі файли, що починаються з 'g', мають спільні\n"
"перші три символи 'goo'."

# code block
#: shell-novice/_episodes/02-filedir.md:851
msgid ""
"~~~\n"
"$ ls north-pacific-gyre/goo\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls north-pacific-gyre/goo\n"
"~~~"

#: shell-novice/_episodes/02-filedir.md:856
msgid ""
"To see all of those files, she can press <kbd>Tab</kbd> twice more.\n"
"~~~\n"
"ls north-pacific-gyre/goo\n"
"goodiff.sh   goostats.sh\n"
"~~~\n"
"{: .language-bash}"
msgstr ""
"Щоб побачити всі ці файли, вона може натиснути клавішу <kbd>Tab</kbd> ще двічі.\n"
"~~~\n"
"ls north-pacific-gyre/goo\n"
"goodiff.sh goostats.sh\n"
"~~~\n"
"{: .language-bash}"

#: shell-novice/_episodes/02-filedir.md:863
msgid ""
"This is called **tab completion**,\n"
"and we will see it in many other tools as we go on."
msgstr ""
"Це називається **завершення табуляції**,\n"
"і ми побачимо його у багатьох інших інструментах."

#: shell-novice/_episodes/02-filedir.md:866
msgid ""
"[Arguments]: https://swcarpentry.github.io/shell-"
"novice/reference.html#argument"
msgstr ""
"[Аргументи]: https://swcarpentry.github.io/shell-"
"novice/reference.html#argument"

# Front Matter
#: shell-novice/_episodes/03-create.md:1
msgid ""
"---\n"
"title: \"Working With Files and Directories\"\n"
"teaching: 30\n"
"exercises: 20\n"
"questions:\n"
"- \"How can I create, copy, and delete files and directories?\"\n"
"- \"How can I edit files?\"\n"
"objectives:\n"
"- \"Create a directory hierarchy that matches a given diagram.\"\n"
"- \"Create files in that hierarchy using an editor or by copying and renaming existing files.\"\n"
"- \"Delete, copy and move specified files and/or directories.\"\n"
"keypoints:\n"
"- \"`cp [old] [new]` copies a file.\"\n"
"- \"`mkdir [path]` creates a new directory.\"\n"
"- \"`mv [old] [new]` moves (renames) a file or directory.\"\n"
"- \"`rm [path]` removes (deletes) a file.\"\n"
"- \"`*` matches zero or more characters in a filename, so `*.txt` matches all files ending in `.txt`.\"\n"
"- \"`?` matches any single character in a filename, so `?.txt` matches `a.txt` but not `any.txt`.\"\n"
"- \"Use of the Control key may be described in many ways, including `Ctrl-X`, `Control-X`, and `^X`.\"\n"
"- \"The shell does not have a trash bin: once something is deleted, it's really gone.\"\n"
"- \"Most files' names are `something.extension`. The extension isn't required, and doesn't guarantee anything, but is normally used to indicate the type of data in the file.\"\n"
"- \"Depending on the type of work you do, you may need a more powerful text editor than Nano.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Робота з файлами та каталогами\"\n"
"teaching: 30\n"
"exercises: 20\n"
"questions:\n"
"- \"Як я можу створювати, копіювати та видаляти файли і каталоги?\"\n"
"- \"Як я можу редагувати файли?\"\n"
"objectives:\n"
"- \"Створити ієрархію каталогів, яка відповідає заданій схемі.\"\n"
"- \"Створити файли в цій ієрархії за допомогою редактора або шляхом копіювання та перейменування файлів, що вже існують.\"\n"
"- \"Видалити, скопіювати та перемістити вказані файли та/або каталоги.\"\n"
"keypoints:\n"
"- \"`cp [old] [new]` копіює файл.\"\n"
"- \"`mkdir [path]` створює новий каталог.\"\n"
"- \"`mv [old] [new]` переміщує (перейменовує) файл або каталог.\"\n"
"- \"`rm [path]` вилучає (видаляє) файл.\"\n"
"- \"`*` відповідає нулю або більше символів в імені файлу, тому `*.txt` відповідає всім файлам, імена яких закінчуються на `.txt`.\"\n"
"- \"`?` відповідає будь-якому одному символу у назві файлу, тому `?.txt` відповідає `a.txt`, але не `any.txt`.\"\n"
"- \"Використання клавіші Control можна описати різними способами, зокрема `Ctrl-X`, `Control-X` та `^X`..\"\n"
"- \"В терміналі немає корзини: як тільки щось видаляється, воно дійсно зникає.\"\n"
"- \"Більшість файлів мають назву \"щось.розширення\". Розширення не є обов'язковим і нічого не гарантує, але зазвичай використовується для позначення типу даних у файлі.\"\n"
"- \"Залежно від типу роботи, яку ви виконуєте, вам може знадобитися потужніший текстовий редактор, ніж Nano.\"\n"
"---"

# header
#: shell-novice/_episodes/03-create.md:24
msgid "## Creating directories"
msgstr "## Створення каталогів"

#: shell-novice/_episodes/03-create.md:25
msgid ""
"We now know how to explore files and directories,\n"
"but how do we create them in the first place?"
msgstr ""
"Тепер ми знаємо, як досліджувати файли та каталоги,\n"
"але як їх створювати?"

#: shell-novice/_episodes/03-create.md:28
msgid ""
"In this episode we will learn about creating and moving files and directories,\n"
"using the `exercise-data/writing` directory as an example."
msgstr ""
"На цьому уроці ми дізнаємося про створення та переміщення файлів і каталогів\n"
"на прикладі каталогу `exercise-data/writing`."

# header
#: shell-novice/_episodes/03-create.md:31
msgid "### Step one: see where we are and what we already have"
msgstr "### Крок перший: подивіться, де ми знаходимося і що вже маємо"

#: shell-novice/_episodes/03-create.md:32
msgid ""
"We should still be in the `shell-lesson-data` directory on the Desktop,\n"
"which we can check using:"
msgstr ""
"Ми все ще маємо бути у каталозі `shell-lesson-data` на Робочому столі (англ. Desktop),\n"
"що ми можемо перевірити за допомогою:"

#: shell-novice/_episodes/03-create.md:45
msgid ""
"Next we'll move to the `exercise-data/writing` directory and see what it contains:\n"
"~~~\n"
"$ cd exercise-data/writing/\n"
"~~~\n"
"{:  .language-bash}"
msgstr ""
"Далі ми перейдемо до каталогу `exercise-data/writing` і подивимося, що у ньому міститься:\n"
"~~~\n"
"$ cd exercise-data/writing/\n"
"~~~\n"
"{: .language-bash}"

# code block
#: shell-novice/_episodes/03-create.md:56
msgid ""
"~~~\n"
"haiku.txt  LittleWomen.txt\n"
"~~~"
msgstr ""
"~~~\n"
"haiku.txt  LittleWomen.txt\n"
"~~~"

# header
#: shell-novice/_episodes/03-create.md:61
msgid "### Create a directory"
msgstr "### Створення каталогу"

#: shell-novice/_episodes/03-create.md:63
msgid ""
"Let's create a new directory called `thesis` using the command `mkdir thesis`\n"
"(which has no output):"
msgstr ""
"Створимо новий каталог з назвою `theis` за допомогою команди `mkdir thesis`\n"
"(яка не має виводу):"

# code block
#: shell-novice/_episodes/03-create.md:66
msgid ""
"~~~\n"
"$ mkdir thesis\n"
"~~~"
msgstr ""
"~~~\n"
"$ mkdir thesis\n"
"~~~"

#: shell-novice/_episodes/03-create.md:71
msgid ""
"As you might guess from its name,\n"
"`mkdir` means 'make directory'.\n"
"Since `thesis` is a relative path\n"
"(i.e., does not have a leading slash, like `/what/ever/thesis`),\n"
"the new directory is created in the current working directory:"
msgstr ""
"Як ви можете здогадатися з її назви,\n"
"команда `mkdir` означає 'зробити каталог' (англ. 'make directory').\n"
"Оскільки `thesis` є відносним шляхом\n"
"(тобто не має початкової косої риски, як `/what/ever/thesis`),\n"
"новий каталог буде створено у поточному робочому каталозі:"

# code block
#: shell-novice/_episodes/03-create.md:82
msgid ""
"~~~\n"
"haiku.txt  LittleWomen.txt  thesis/\n"
"~~~"
msgstr ""
"~~~\n"
"haiku.txt  LittleWomen.txt  thesis/\n"
"~~~"

#: shell-novice/_episodes/03-create.md:87
msgid ""
"Since we've just created the `thesis` directory, there's nothing in it yet:"
msgstr "Оскільки ми щойно створили каталог `thesis`, у ньому ще нічого немає:"

# code block
#: shell-novice/_episodes/03-create.md:89
msgid ""
"~~~\n"
"$ ls -F thesis\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls -F thesis\n"
"~~~"

#: shell-novice/_episodes/03-create.md:94
msgid ""
"Note that `mkdir` is not limited to creating single directories one at a time.\n"
"The `-p` option allows `mkdir` to create a directory with nested subdirectories\n"
"in a single operation:"
msgstr ""
"Зауважте, що команда `mkdir` не обмежується створенням окремих каталогів по одному.\n"
"Параметр `-p` дозволяє команді `mkdir` створювати каталог із вкладеними підкаталогами\n"
"за одну операцію:"

# code block
#: shell-novice/_episodes/03-create.md:98
msgid ""
"~~~\n"
"$ mkdir -p ../project/data ../project/results\n"
"~~~"
msgstr ""
"~~~\n"
"$ mkdir -p ../project/data ../project/results\n"
"~~~"

#: shell-novice/_episodes/03-create.md:103
msgid ""
"The `-R` option to the `ls` command will list all nested subdirectories within a directory.\n"
"Let's use `ls -FR` to recursively list the new directory hierarchy we just created in the\n"
"`project` directory:"
msgstr ""
"Параметр `-R` до команди `ls` покаже усі вкладені підкаталоги у каталозі.\n"
"Давайте скористаємося `ls -FR` для рекурсивного відображення нової ієрархії каталогів, яку ми щойно створили у\n"
"каталозі `project`:"

# code block
#: shell-novice/_episodes/03-create.md:107
msgid ""
"~~~\n"
"$ ls -FR ../project\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls -FR ../project\n"
"~~~"

# code block
#: shell-novice/_episodes/03-create.md:112
msgid ""
"~~~\n"
"../project/:\n"
"data/  results/\n"
"\n"
"../project/data:\n"
"\n"
"../project/results:\n"
"~~~"
msgstr ""
"~~~\n"
"../project/:\n"
"data/  results/\n"
"\n"
"../project/data:\n"
"\n"
"../project/results:\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:122
msgid "> ## Two ways of doing the same thing"
msgstr "> ## Два способи зробити одне й те саме"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:123
msgid ""
"> Using the shell to create a directory is no different than using a file "
"explorer."
msgstr ""
"> Використання терміналу для створення каталогу нічим не відрізняється від "
"використання файлового провідника."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:124
msgid ""
"> If you open the current directory using your operating system's graphical "
"file explorer,"
msgstr ""
"> Якщо ви відкриваєте поточний каталог за допомогою графічного провідника "
"файлів вашої операційної системи,"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:125
msgid "> the `thesis` directory will appear there too."
msgstr "> там також з'явиться каталог `thesis`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:126
msgid ""
"> While the shell and the file explorer are two different ways of "
"interacting with the files,"
msgstr ""
"> Хоча оболонка і файловий провідник - це два різні способи взаємодії з "
"файлами,"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:127
msgid "> the files and directories themselves are the same."
msgstr "> файли та каталоги одні й ті ж самі."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:130
msgid "> ## Good names for files and directories"
msgstr "> ## Хороші імена для файлів і каталогів"

#: shell-novice/_episodes/03-create.md:131
msgid ""
">\n"
"> Complicated names of files and directories can make your life painful\n"
"> when working on the command line. Here we provide a few useful\n"
"> tips for the names of your files and directories.\n"
">\n"
"> 1. Don't use spaces.\n"
">\n"
">    Spaces can make a name more meaningful,\n"
">    but since spaces are used to separate arguments on the command line\n"
">    it is better to avoid them in names of files and directories.\n"
">    You can use `-` or `_` instead (e.g. `north-pacific-gyre/` rather than `north pacific gyre/`).\n"
">    To test this out, try typing `mkdir north pacific gyre`and see what directory (or directories!)\n"
">    are made when you check with `ls -F`.\n"
">\n"
"> 2. Don't begin the name with `-` (dash).\n"
">\n"
">    Commands treat names starting with `-` as options.\n"
">\n"
"> 3. Stick with letters, numbers, `.` (period or 'full stop'), `-` (dash) and `_` (underscore).\n"
">\n"
">    Many other characters have special meanings on the command line.\n"
">    We will learn about some of these during this lesson.\n"
">    There are special characters that can cause your command to not work as\n"
">    expected and can even result in data loss.\n"
">\n"
"> If you need to refer to names of files or directories that have spaces\n"
"> or other special characters, you should surround the name in quotes (`\"\"`)."
msgstr ""
">\n"
"> Складні назви файлів і каталогів можуть зробити ваше життя болісним\n"
"> під час роботи з командним рядком. Тут ми надаємо кілька корисних\n"
"> підказок щодо назв ваших файлів і каталогів.\n"
">\n"
"> 1. Не використовуйте пробіли.\n"
">\n"
"> Пробіли можуть зробити назву більш змістовною,\n"
"> але оскільки пробіли використовуються для відокремлення аргументів у командному рядку\n"
"> краще уникати їх у назвах файлів і каталогів.\n"
"> Ви можете використовувати `-` або `_` (наприклад, `north-pacific-gyre/` замість `north pacific gyre/`).\n"
"> Щоб перевірити це, спробуйте набрати `mkdir north pacific gyre` і подивіться, який каталог (або каталоги!)\n"
"> буде створено при перевірці за допомогою `ls -F`.\n"
">\n"
"> 2. Не починайте назву з `-` (тире).\n"
">\n"
"> Команди розглядають назви, що починаються з `-`, як опції.\n"
">\n"
"> 3. Використовуйте літери, цифри, `.` (крапка), `-` (тире) і `_` (підкреслення).\n"
">\n"
"> Багато інших символів мають особливе значення у командному рядку.\n"
"> Про деякі з них ми дізнаємося на цьому уроці.\n"
"> Існують спеціальні символи, які можуть призвести до того, що ваша команда працюватиме не так, як\n"
"> очікуваним чином і навіть призвести до втрати даних.\n"
">\n"
"> Якщо вам потрібно звернутися до назв файлів або каталогів, які містять пробіли\n"
"> або інші спеціальні символи, вам слід взяти назву у лапки (`\"\"`)."

# header
#: shell-novice/_episodes/03-create.md:160
msgid "### Create a text file"
msgstr "### Створення текстового файлу"

#: shell-novice/_episodes/03-create.md:161
msgid ""
"Let's change our working directory to `thesis` using `cd`,\n"
"then run a text editor called Nano to create a file called `draft.txt`:"
msgstr ""
"Давайте змінимо наш робочий каталог на `thesis` за допомогою `cd`,\n"
"а потім запустимо текстовий редактор Nano і створимо файл з назвою `draft.txt`:"

# code block
#: shell-novice/_episodes/03-create.md:164
msgid ""
"~~~\n"
"$ cd thesis\n"
"$ nano draft.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd thesis\n"
"$ nano draft.txt\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:170
msgid "> ## Which Editor?"
msgstr "> ## Який редактор?"

#: shell-novice/_episodes/03-create.md:171
msgid ""
">\n"
"> When we say, '`nano` is a text editor' we really do mean 'text': it can\n"
"> only work with plain character data, not tables, images, or any other\n"
"> human-friendly media. We use it in examples because it is one of the\n"
"> least complex text editors. However, because of this trait, it may\n"
"> not be powerful enough or flexible enough for the work you need to do\n"
"> after this workshop. On Unix systems (such as Linux and macOS),\n"
"> many programmers use [Emacs](http://www.gnu.org/software/emacs/) or\n"
"> [Vim](http://www.vim.org/) (both of which require more time to learn),\n"
"> or a graphical editor such as\n"
"> [Gedit](http://projects.gnome.org/gedit/). On Windows, you may wish to\n"
"> use [Notepad++](http://notepad-plus-plus.org/).  Windows also has a built-in\n"
"> editor called `notepad` that can be run from the command line in the same\n"
"> way as `nano` for the purposes of this lesson.\n"
">\n"
"> No matter what editor you use, you will need to know where it searches\n"
"> for and saves files. If you start it from the shell, it will (probably)\n"
"> use your current working directory as its default location. If you use\n"
"> your computer's start menu, it may want to save files in your desktop or\n"
"> documents directory instead. You can change this by navigating to\n"
"> another directory the first time you 'Save As...'"
msgstr ""
">\n"
"> Коли ми говоримо, що \"nano\" - це текстовий редактор, ми дійсно маємо на увазі \"текст\": він може\n"
"> працювати лише з простими символьними даними, а не з таблицями, зображеннями чи будь-якими іншими\n"
"> зручними для людини даними. Ми використовуємо його у прикладах, тому що це один з\n"
"> найменш складних текстових редакторів. Однак, через цю особливість він може бути\n"
"> недостатньо потужним або гнучким для роботи, яку вам потрібно буде виконати\n"
"> після завершення наших уроків. У системах Unix (таких як Linux та macOS),\n"
"> багато програмістів використовують [Emacs] (http://www.gnu.org/software/emacs/) або\n"
"> [Vim](http://www.vim.org/) (обидва вимагають більше часу на вивчення),\n"
"> або графічний редактор, такий як\n"
"> [Gedit](http://projects.gnome.org/gedit/). У Windows, можливо, ви захочете\n"
"> скористатися [Notepad++] (http://notepad-plus-plus.org/). У Windows також є вбудований\n"
"> редактор з назвою `notepad`, який можна запустити з командного рядка так само\n"
"> чином, як і `nano` для цілей цього уроку.\n"
">\n"
"> Незалежно від того, яким редактором ви користуєтеся, вам потрібно знати, де він шукає\n"
"> і зберігає файли. Якщо ви запускаєте його з командної оболонки, він (ймовірно)\n"
"> використовуватиме ваш поточний робочий каталог як місце за замовчуванням. Якщо ви використовуєте\n"
"> меню \"Пуск\" вашого комп'ютера, можливо, програма захоче зберегти файли на робочому столі або\n"
"> в каталозі документів (Documents) замість цього. Ви можете змінити це, перейшовши до\n"
"> іншого каталогу під час першого виконання команди \"Зберегти як...\"."

#: shell-novice/_episodes/03-create.md:194
msgid ""
"Let's type in a few lines of text.\n"
"Once we're happy with our text, we can press <kbd>Ctrl</kbd>+<kbd>O</kbd>\n"
"(press the <kbd>Ctrl</kbd> or <kbd>Control</kbd> key and, while\n"
"holding it down, press the <kbd>O</kbd> key) to write our data to disk\n"
"(we'll be asked what file we want to save this to:\n"
"press <kbd>Return</kbd> to accept the suggested default of `draft.txt`)."
msgstr ""
"Давайте наберемо кілька рядків тексту.\n"
"Після того, як ми будемо задоволені нашим текстом, ми можемо натиснути <kbd>Ctrl</kbd>+<kbd>O</kbd>\n"
"(натисніть клавішу <kbd>Ctrl</kbd> або <kbd>Control</kbd> і, утримуючи її,\n"
"натиснути клавішу <kbd>O</kbd>), щоб записати наші дані на диск\n"
"(нас запитають, до якого файлу ми хочемо зберегти дані:\n"
"натисніть клавішу <kbd>Return</kbd>, щоб прийняти запропоновану за замовчуванням назву `draft.txt`)."

#: shell-novice/_episodes/03-create.md:201
msgid ""
"<div style=\"width:80%; margin: auto;\"><img alt=\"screenshot of nano text editor in action\"\n"
"src=\"../fig/nano-screenshot.png\"></div>"
msgstr ""
"<div style=\"width:80%; margin: auto;\"><img alt=\"знімок екрану з "
"редактором nano\" src=\"../fig/nano-screenshot.png\"/></div>"

#: shell-novice/_episodes/03-create.md:204
msgid ""
"Once our file is saved, we can use <kbd>Ctrl</kbd>+<kbd>X</kbd> to quit the editor and\n"
"return to the shell."
msgstr ""
"Після збереження файлу ми можемо скористатися комбінацією клавіш <kbd>Ctrl</kbd>+<kbd>X</kbd>, щоб вийти з редактора і\n"
"повернутися до терміналу."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:207
msgid "> ## Control, Ctrl, or ^ Key"
msgstr "> ## Клавіша Control, Ctrl або ^"

#: shell-novice/_episodes/03-create.md:208
msgid ""
">\n"
"> The Control key is also called the 'Ctrl' key. There are various ways\n"
"> in which using the Control key may be described. For example, you may\n"
"> see an instruction to press the <kbd>Control</kbd> key and, while holding it down,\n"
"> press the <kbd>X</kbd> key, described as any of:\n"
">\n"
"> * `Control-X`\n"
"> * `Control+X`\n"
"> * `Ctrl-X`\n"
"> * `Ctrl+X`\n"
"> * `^X`\n"
"> * `C-x`\n"
">\n"
"> In nano, along the bottom of the screen you'll see `^G Get Help ^O WriteOut`.\n"
"> This means that you can use `Control-G` to get help and `Control-O` to save your\n"
"> file."
msgstr ""
">\n"
"> Клавіша Control також називається клавішею Ctrl. Існує декілька способів, в які\n"
"> можна описати використання клавіші Control. Наприклад, ви можете\n"
"> побачити вказівку натиснути клавішу <kbd>Control</kbd> і, утримуючи її натиснутою,\n"
"> натиснути клавішу <kbd>X</kbd>, описану будь-яким з наступних способом:\n"
">\n"
"> * \"Control-X\n"
"> * `Control+X`\n"
"> * \"Ctrl-X\n"
"> * `Ctrl+X`\n"
"> * `^X`\n"
"> * `C-x`\n"
">\n"
"> У nano, у нижній частині екрана ви побачите `^G Отримати довідку ^O Вивести на екран`.\n"
"> Це означає, що ви можете скористатися `Control-G` для отримання довідки і `Control-O` для збереження вашого\n"
"> файлу."

#: shell-novice/_episodes/03-create.md:226
msgid ""
"`nano` doesn't leave any output on the screen after it exits,\n"
"but `ls` now shows that we have created a file called `draft.txt`:"
msgstr ""
"Після завершення роботи команда `nano` не залишає жодних даних на екрані,\n"
"але `ls` тепер показує, що ми створили файл з назвою `draft.txt`:"

# code block
#: shell-novice/_episodes/03-create.md:234
msgid ""
"~~~\n"
"draft.txt\n"
"~~~"
msgstr ""
"~~~\n"
"draft.txt\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:239
msgid "> ## Creating Files a Different Way"
msgstr "> ## Створення файлів іншим способом"

#: shell-novice/_episodes/03-create.md:240
msgid ""
">\n"
"> We have seen how to create text files using the `nano` editor.\n"
"> Now, try the following command:\n"
">\n"
"> ~~~\n"
"> $ touch my_file.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1.  What did the `touch` command do?\n"
">     When you look at your current directory using the GUI file explorer,\n"
">     does the file show up?\n"
">\n"
"> 2.  Use `ls -l` to inspect the files.  How large is `my_file.txt`?\n"
">\n"
"> 3.  When might you want to create a file this way?\n"
">\n"
"> > ## Solution\n"
"> > 1.  The `touch` command generates a new file called `my_file.txt` in\n"
"> >     your current directory.  You\n"
"> >     can observe this newly generated file by typing `ls` at the\n"
"> >     command line prompt.  `my_file.txt` can also be viewed in your\n"
"> >     GUI file explorer.\n"
"> >\n"
"> > 2.  When you inspect the file with `ls -l`, note that the size of\n"
"> >     `my_file.txt` is 0 bytes.  In other words, it contains no data.\n"
"> >     If you open `my_file.txt` using your text editor it is blank.\n"
"> >\n"
"> > 3.  Some programs do not generate output files themselves, but\n"
"> >     instead require that empty files have already been generated.\n"
"> >     When the program is run, it searches for an existing file to\n"
"> >     populate with its output.  The touch command allows you to\n"
"> >     efficiently generate a blank text file to be used by such\n"
"> >     programs."
msgstr ""
">\n"
"> Ми побачили, як створювати текстові файли за допомогою редактора `nano`.\n"
"> Тепер спробуйте виконати наступну команду:\n"
">\n"
"> ~~~\n"
"> $ touch my_file.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Що зробила команда `touch`?\n"
"> Коли ви дивитеся на ваш поточний каталог за допомогою провідника файлів у графічному інтерфейсі,\n"
"> чи відображається файл?\n"
">\n"
"> 2. Використовуйте `ls -l` для перегляду файлів. Який розмір має файл `my_file.txt`?\n"
">\n"
"> 3. Коли вам може знадобитися створити файл у такий спосіб?\n"
">\n"
"> > Розв'язання\n"
"> > 1. Команда `touch` створює новий файл з назвою `my_file.txt` у\n"
"> > вашому поточному каталозі. Ви\n"
"> > можете переглянути цей новостворений файл, набравши `ls` у\n"
"> > командному рядку. Файл `my_file.txt` також можна переглянути у вашому\n"
"> > графічному провіднику файлів.\n"
"> >\n"
"> > 2. Коли ви перевіряєте файл за допомогою `ls -l`, зверніть увагу, що розмір\n"
"> > `my_file.txt` дорівнює 0 байт. Іншими словами, він не містить жодних даних.\n"
"> > Якщо ви відкриєте `my_file.txt` за допомогою текстового редактора, він буде порожнім.\n"
"> >\n"
"> > 3. Деякі програми самі не створюють вихідні файли, а\n"
"> > натомість вимагають, щоб порожні файли вже було створено.\n"
"> > Під час запуску програма шукає існуючий файл, щоб\n"
"> > заповнити його своїми даними. За допомогою команди touch можна\n"
"> > ефективно створити порожній текстовий файл для подальшого використання такими\n"
"> > програмами."

#: shell-novice/_episodes/03-create.md:275
msgid ""
">\n"
"> To avoid confusion later on,\n"
"> we suggest removing the file you've just created before proceeding with the rest\n"
"> of the episode, otherwise future outputs may vary from those given in the lesson.\n"
"> To do this, use the following command:\n"
">\n"
"> ~~~\n"
"> $ rm my_file.txt\n"
"> ~~~\n"
"> {: .language-bash}"
msgstr ""
">\n"
"> Щоб уникнути плутанини в подальшому,\n"
"> радимо видалити файл, який ви щойно створили, перед тим, як переходити до решти\n"
"> епізоду, інакше майбутні результати можуть відрізнятися від наведених в уроці.\n"
"> Для цього скористайтеся наступною командою:\n"
">\n"
"> ~~~\n"
"> $ rm my_file.txt\n"
"> ~~~\n"
"> {: .language-bash}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:287
msgid "> ## What's In A Name?"
msgstr "> ## Що ховається в імені?"

#: shell-novice/_episodes/03-create.md:288
msgid ""
">\n"
"> You may have noticed that all of Nelle's files are named 'something dot\n"
"> something', and in this part of the lesson, we always used the extension\n"
"> `.txt`.  This is just a convention: we can call a file `mythesis` or\n"
"> almost anything else we want. However, most people use two-part names\n"
"> most of the time to help them (and their programs) tell different kinds\n"
"> of files apart. The second part of such a name is called the\n"
"> **filename extension** and indicates\n"
"> what type of data the file holds: `.txt` signals a plain text file, `.pdf`\n"
"> indicates a PDF document, `.cfg` is a configuration file full of parameters\n"
"> for some program or other, `.png` is a PNG image, and so on.\n"
">\n"
"> This is just a convention, albeit an important one. Files contain\n"
"> bytes: it's up to us and our programs to interpret those bytes\n"
"> according to the rules for plain text files, PDF documents, configuration\n"
"> files, images, and so on.\n"
">\n"
"> Naming a PNG image of a whale as `whale.mp3` doesn't somehow\n"
"> magically turn it into a recording of whale song, though it *might*\n"
"> cause the operating system to try to open it with a music player\n"
"> when someone double-clicks it."
msgstr ""
">\n"
"> Ви, мабуть, помітили, що всі файли Неллі називаються 'щось крапка\n"
"> щось\", і у цій частині уроку ми завжди використовували розширення\n"
"> `.txt`. Це лише умовність: ми можемо назвати файл `mythesis` або\n"
"> майже як завгодно. Однак, більшість людей використовують назви, що складаються з двох частин\n"
"> здебільшого для того, щоб допомогти їм (і їхнім програмам) розрізняти різні типи\n"
"> файлів. Друга частина такого імені називається\n"
"> **розширенням файлу** і вказує\n"
"> тип даних у файлі: `.txt` вказує на звичайний текстовий файл, `.pdf`\n"
"> вказує на PDF-документ, `.cfg` - це конфігураційний файл з параметрами\n"
"> для тієї чи іншої програми, `.png` - зображення у форматі PNG, і так далі.\n"
">\n"
"> Це лише умовність, хоча й важлива. Файли містять\n"
"> байти: ми та наші програми повинні інтерпретувати ці байти\n"
"> відповідно до правил для звичайних текстових файлів, PDF-документів, конфігураційних\n"
"> файлів, зображень тощо.\n"
">\n"
"> Якщо ви назвете зображення кита у форматі PNG як \"whale.mp3\", це не перетворить його якимось\n"
"> чарівним чином на запис пісні кита, хоча це *може*\n"
"> змусити операційну систему спробувати відкрити його за допомогою музичного плеєра.\n"
"> коли хтось двічі клікне на ньому."

# header
#: shell-novice/_episodes/03-create.md:311
msgid "## Moving files and directories"
msgstr "## Переміщення файлів і каталогів"

#: shell-novice/_episodes/03-create.md:312
msgid "Returning to the `shell-lesson-data/exercise-data/writing` directory,"
msgstr "Повернемося до каталогу `shell-lesson-data/exercise-data/writing`,"

# code block
#: shell-novice/_episodes/03-create.md:314
msgid ""
"```\n"
"$ cd ~/Desktop/shell-lesson-data/exercise-data/writing\n"
"```"
msgstr ""
"```\n"
"$ cd ~/Desktop/shell-lesson-data/exercise-data/writing\n"
"```"

#: shell-novice/_episodes/03-create.md:319
msgid ""
"In our `thesis` directory we have a file `draft.txt`\n"
"which isn't a particularly informative name,\n"
"so let's change the file's name using `mv`,\n"
"which is short for 'move':"
msgstr ""
"У нашому каталозі `thesis` є файл `draft.txt`.\n"
"з не надто інформативною назвою,\n"
"тому давайте змінимо назву файлу за допомогою команди `mv`,\n"
"що є скороченням від 'move' (з англ. - 'переміщати'):"

# code block
#: shell-novice/_episodes/03-create.md:324
msgid ""
"~~~\n"
"$ mv thesis/draft.txt thesis/quotes.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ mv thesis/draft.txt thesis/quotes.txt\n"
"~~~"

#: shell-novice/_episodes/03-create.md:329
msgid ""
"The first argument tells `mv` what we're 'moving',\n"
"while the second is where it's to go.\n"
"In this case,\n"
"we're moving `thesis/draft.txt` to `thesis/quotes.txt`,\n"
"which has the same effect as renaming the file.\n"
"Sure enough,\n"
"`ls` shows us that `thesis` now contains one file called `quotes.txt`:"
msgstr ""
"Перший аргумент говорить \"mv\", що ми 'переміщаємо',\n"
"а другий - куди саме.\n"
"У цьому випадку\n"
"ми переміщуємо `theis/draft.txt` до `theis/quotes.txt`,\n"
"що має той самий ефект, що і перейменування файлу.\n"
"Звісно,\n"
"`ls` показує нам, що `thesis` тепер містить один файл з назвою `quotes.txt`:"

# code block
#: shell-novice/_episodes/03-create.md:337
#: shell-novice/_episodes/03-create.md:371
msgid ""
"~~~\n"
"$ ls thesis\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls thesis\n"
"~~~"

# code block
#: shell-novice/_episodes/03-create.md:342
#: shell-novice/_episodes/03-create.md:403
msgid ""
"~~~\n"
"quotes.txt\n"
"~~~"
msgstr ""
"~~~\n"
"quotes.txt\n"
"~~~"

#: shell-novice/_episodes/03-create.md:347
msgid ""
"One must be careful when specifying the target file name, since `mv` will\n"
"silently overwrite any existing file with the same name, which could\n"
"lead to data loss. An additional option, `mv -i` (or `mv --interactive`),\n"
"can be used to make `mv` ask you for confirmation before overwriting."
msgstr ""
"Слід бути обережним при вказівці імені цільового файлу, оскільки `mv`\n"
"приховано перезапише будь-який файл, що вже існує, з такою самою назвою, а це може призвести до\n"
"втрати даних. Додатковий параметр `mv -i` (або `mv --interactive`, з англ. - 'інтерактивно'),\n"
"може бути використано для того, щоб змусити `mv` запитувати у вас підтвердження перед перезаписом."

#: shell-novice/_episodes/03-create.md:352
msgid "Note that `mv` also works on directories."
msgstr "Зверніть увагу, що `mv` також працює з каталогами."

#: shell-novice/_episodes/03-create.md:354
msgid ""
"Let's move `quotes.txt` into the current working directory.\n"
"We use `mv` once again,\n"
"but this time we'll use just the name of a directory as the second argument\n"
"to tell `mv` that we want to keep the filename\n"
"but put the file somewhere new.\n"
"(This is why the command is called 'move'.)\n"
"In this case,\n"
"the directory name we use is the special directory name `.` that we mentioned earlier."
msgstr ""
"Перемістимо `quotes.txt` до поточного робочого каталогу.\n"
"Знову скористаємося `mv`,\n"
"але цього разу ми використаємо лише назву каталогу як другий аргумент\n"
"щоб повідомити `mv`, що ми хочемо зберегти назву файлу\n"
"але перемістити файл у нове місце.\n"
"(Ось чому команда називається 'перемістити').\n"
"У цьому випадку\n"
"ми використовуємо спеціальну назву `.` поточного каталогу, про яку ми згадували раніше."

# code block
#: shell-novice/_episodes/03-create.md:363
msgid ""
"~~~\n"
"$ mv thesis/quotes.txt .\n"
"~~~"
msgstr ""
"~~~\n"
"$ mv thesis/quotes.txt .\n"
"~~~"

#: shell-novice/_episodes/03-create.md:368
msgid ""
"The effect is to move the file from the directory it was in to the current working directory.\n"
"`ls` now shows us that `thesis` is empty:"
msgstr ""
"Наслідком цього буде переміщення файла з каталогу, у якому він знаходився, до поточного робочого каталогу.\n"
"Тепер `ls` показує нам, що `thesis` порожній:"

#: shell-novice/_episodes/03-create.md:381
msgid ""
"Alternatively, we can confirm the file `quotes.txt` is no longer present in the `thesis` directory\n"
"by explicitly trying to list it:"
msgstr ""
"Крім того, ми можемо переконатися, що файл `quotes.txt` більше не присутній у каталозі `thesis`,\n"
"явно спробувавши показати інформацію про нього:"

# code block
#: shell-novice/_episodes/03-create.md:384
msgid ""
"~~~\n"
"$ ls thesis/quotes.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls thesis/quotes.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/03-create.md:389
msgid ""
"```\n"
"ls: cannot access 'thesis/quotes.txt': No such file or directory\n"
"```"
msgstr ""
"```\n"
"ls: cannot access 'thesis/quotes.txt': No such file or directory\n"
"```"

#: shell-novice/_episodes/03-create.md:394
msgid ""
"`ls` with a filename or directory as an argument only lists the requested file or directory.\n"
"If the file given as the argument doesn't exist, the shell returns an error as we saw above.\n"
"We can use this to see that `quotes.txt` is now present in our current directory:"
msgstr ""
"Команда `ls` з ім'ям файлу або каталогу в якості аргументу виводить лише список запитуваних файлів або каталогів.\n"
"Якщо файл, вказаний як аргумент, не існує, термінал поверне помилку, як ми бачили вище.\n"
"Ми можемо скористатися цим, щоб побачити, що файл `quotes.txt` знаходиться у нашому поточному каталозі:"

# code block
#: shell-novice/_episodes/03-create.md:398
#: shell-novice/_episodes/03-create.md:575
msgid ""
"~~~\n"
"$ ls quotes.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls quotes.txt\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:408
msgid "> ## Moving Files to a new folder"
msgstr "> ## Переміщення файлів до нової папки"

#: shell-novice/_episodes/03-create.md:409
msgid ""
">\n"
"> After running the following commands,\n"
"> Jamie realizes that she put the files `sucrose.dat` and `maltose.dat` into the wrong folder.\n"
"> The files should have been placed in the `raw` folder.\n"
">\n"
"> ~~~\n"
"> $ ls -F\n"
">  analyzed/ raw/\n"
"> $ ls -F analyzed\n"
"> fructose.dat glucose.dat maltose.dat sucrose.dat\n"
"> $ cd analyzed\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Fill in the blanks to move these files to the `raw/` folder\n"
"> (i.e. the one she forgot to put them in)\n"
">\n"
"> ~~~\n"
"> $ mv sucrose.dat maltose.dat ____/____\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> > ## Solution\n"
"> > ```\n"
"> > $ mv sucrose.dat maltose.dat ../raw\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> > Recall that `..` refers to the parent directory (i.e. one above the current directory)\n"
"> > and that `.` refers to the current directory."
msgstr ""
">\n"
"> Після виконання наступних команд\n"
"> Джеймі зрозуміла, що поклала файли `sucrose.dat` та `maltose.dat` не до того каталогу.\n"
"> Файли потрібно було покласти у каталог `raw`.\n"
">\n"
"> ~~~\n"
"> $ ls -F\n"
"> analyzed/ raw/\n"
"> $ ls -F analyzed\n"
"> fructose.dat glucose.dat maltose.dat sucrose.dat\n"
"> $ cd analyzed\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Заповніть пропуски, щоб перемістити ці файли до теки `raw/`.\n"
"> (тобто туди, куди вона забула їх покласти)\n"
">\n"
"> ~~~\n"
"> $ mv sucrose.dat maltose.dat ____/____\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> > ## Рішення\n"
"> > ```\n"
"> > $ mv sucrose.dat maltose.dat ../raw\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> > Пам'ятайте, що `..` вказує на батьківський каталог (тобто на каталог, розташований вище поточного)\n"
"> > і що `.` вказує на поточний каталог."

# header
#: shell-novice/_episodes/03-create.md:440
msgid "## Copying files and directories"
msgstr "## Копіювання файлів і каталогів"

#: shell-novice/_episodes/03-create.md:442
msgid ""
"The `cp` command works very much like `mv`,\n"
"except it copies a file instead of moving it.\n"
"We can check that it did the right thing using `ls`\n"
"with two paths as arguments --- like most Unix commands,\n"
"`ls` can be given multiple paths at once:"
msgstr ""
"Команда `cp` працює дуже схоже на команду `mv`,\n"
"за винятком того, що вона копіює файл, а не переміщує його.\n"
"Ми можемо перевірити правильність її роботи за допомогою `ls`\n"
"з двома шляхами в якості аргументів --- як і більшості команд Unix,\n"
"команді `ls` можна вказати одразу декілька шляхів:"

# code block
#: shell-novice/_episodes/03-create.md:448
msgid ""
"~~~\n"
"$ cp quotes.txt thesis/quotations.txt\n"
"$ ls quotes.txt thesis/quotations.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ cp quotes.txt thesis/quotations.txt\n"
"$ ls quotes.txt thesis/quotations.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/03-create.md:454
msgid ""
"~~~\n"
"quotes.txt   thesis/quotations.txt\n"
"~~~"
msgstr ""
"~~~\n"
"quotes.txt   thesis/quotations.txt\n"
"~~~"

#: shell-novice/_episodes/03-create.md:459
msgid ""
"We can also copy a directory and all its contents by using the\n"
"[recursive](https://en.wikipedia.org/wiki/Recursion) option `-r`,\n"
"e.g. to back up a directory:"
msgstr ""
"Ми також можемо скопіювати каталог і весь його вміст за допомогою\n"
"[рекурсивної](https://uk.wikipedia.org/wiki/Рекурсія) опції `-r`,\n"
"наприклад, для створення резервної копії каталогу:"

# code block
#: shell-novice/_episodes/03-create.md:463
msgid ""
"```\n"
"$ cp -r thesis thesis_backup\n"
"```"
msgstr ""
"```\n"
"$ cp -r thesis thesis_backup\n"
"```"

#: shell-novice/_episodes/03-create.md:468
msgid ""
"We can check the result by listing the contents of both the `thesis` and "
"`thesis_backup` directory:"
msgstr ""
"Ми можемо перевірити результат, переглянувши вміст каталогів `thesis` та "
"`thesis_backup`:"

# code block
#: shell-novice/_episodes/03-create.md:470
msgid ""
"```\n"
"$ ls thesis thesis_backup\n"
"```"
msgstr ""
"```\n"
"$ ls thesis thesis_backup\n"
"```"

# code block
#: shell-novice/_episodes/03-create.md:475
msgid ""
"```\n"
"thesis:\n"
"quotations.txt\n"
"\n"
"thesis_backup:\n"
"quotations.txt\n"
"```"
msgstr ""
"```\n"
"thesis:\n"
"quotations.txt\n"
"\n"
"thesis_backup:\n"
"quotations.txt\n"
"```"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:485
msgid "> ## Renaming Files"
msgstr "> ## Перейменування файлів"

#: shell-novice/_episodes/03-create.md:486
msgid ""
">\n"
"> Suppose that you created a plain-text file in your current directory to contain a list of the\n"
"> statistical tests you will need to do to analyze your data, and named it: `statstics.txt`\n"
">\n"
"> After creating and saving this file you realize you misspelled the filename! You want to\n"
"> correct the mistake, which of the following commands could you use to do so?\n"
">\n"
"> 1. `cp statstics.txt statistics.txt`\n"
"> 2. `mv statstics.txt statistics.txt`\n"
"> 3. `mv statstics.txt .`\n"
"> 4. `cp statstics.txt .`\n"
">\n"
"> > ## Solution\n"
"> > 1. No.  While this would create a file with the correct name,\n"
"> > the incorrectly named file still exists in the directory\n"
"> > and would need to be deleted.\n"
"> > 2. Yes, this would work to rename the file.\n"
"> > 3. No, the period(.) indicates where to move the file, but does not provide a new file name;\n"
"> > identical file names\n"
"> > cannot be created.\n"
"> > 4. No, the period(.) indicates where to copy the file, but does not provide a new file name;\n"
"> > identical file names cannot be created."
msgstr ""
">\n"
"> Припустімо, що ви створили у поточному каталозі файл простого тексту, який містить список статистичних тестів, які\n"
"> вам знадобляться для аналізу ваших даних, і назвали його: `statstics.txt`.\n"
">\n"
"> Після створення і збереження цього файлу ви зрозуміли, що неправильно написали назву файлу! Ви хочете\n"
"> виправити помилку, яку з наведених нижче команд ви можете використати для цього?\n"
">\n"
"> 1. `cp statstics.txt статистика.txt\n"
"> 2. `mv statstics.txt статистика.txt\n"
"> 3. `mv statstics.txt .`\n"
"> 4. `cp statstics.txt .`\n"
">\n"
"> > ## Розв'язок\n"
"> > 1. Ні. Хоча це створить файл з правильною назвою,\n"
"> > неправильно названий файл все одно існуватиме у каталозі,\n"
"> > і його потрібно буде видалити.\n"
"> > 2. Так, це допоможе перейменувати файл.\n"
"> > 3. Ні, крапка (.) вказує, куди перемістити файл, але не надає нового імені файлу;\n"
"> > однакові назви файлів\n"
"> > не можуть бути створені.\n"
"> > 4. Ні, крапка (.) вказує, куди скопіювати файл, але не надає нового імені файлу;\n"
"> > не можна створювати однакові імена файлів."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:511
msgid "> ## Moving and Copying"
msgstr "> ## Переміщення та копіювання"

#: shell-novice/_episodes/03-create.md:512
msgid ""
">\n"
"> What is the output of the closing `ls` command in the sequence shown below?\n"
">\n"
"> ~~~\n"
"> $ pwd\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> /Users/jamie/data\n"
"> ~~~"
msgstr ""
">\n"
"> Що виводить остання команда `ls` у наведеній нижче послідовності?\n"
">\n"
"> ~~~\n"
"> $ pwd\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> /Users/jamie/data\n"
"> ~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:523
#: shell-novice/_episodes/03-create.md:525
#: shell-novice/_episodes/03-create.md:527
#: shell-novice/_episodes/03-create.md:529
#: shell-novice/_episodes/03-create.md:531
#: shell-novice/_episodes/03-create.md:536
#: shell-novice/_episodes/03-create.md:672
#: shell-novice/_episodes/03-create.md:674
#: shell-novice/_episodes/03-create.md:881
#: shell-novice/_episodes/03-create.md:883
#: shell-novice/_episodes/03-create.md:885
#: shell-novice/_episodes/03-create.md:887
msgid "> ~~~"
msgstr "> ~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:524
#: shell-novice/_episodes/03-create.md:535
msgid "> $ ls"
msgstr "> $ ls"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:526
#: shell-novice/_episodes/03-create.md:537
#: shell-novice/_episodes/03-create.md:675
#: shell-novice/_episodes/03-create.md:884
msgid "> {: .language-bash}"
msgstr "> {: .language-bash}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:528
msgid "> proteins.dat"
msgstr "> proteins.dat"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:532
msgid "> $ mkdir recombined"
msgstr "> $ mkdir recombined"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:533
msgid "> $ mv proteins.dat recombined/"
msgstr "> $ mv proteins.dat recombined/"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:534
msgid "> $ cp recombined/proteins.dat ../proteins-saved.dat"
msgstr "> $ cp recombined/proteins.dat ../proteins-saved.dat"

#: shell-novice/_episodes/03-create.md:538
msgid ""
">\n"
">\n"
"> 1.   `proteins-saved.dat recombined`\n"
"> 2.   `recombined`\n"
"> 3.   `proteins.dat recombined`\n"
"> 4.   `proteins-saved.dat`\n"
">\n"
"> > ## Solution\n"
"> > We start in the `/Users/jamie/data` directory, and create a new folder called `recombined`.\n"
"> > The second line moves (`mv`) the file `proteins.dat` to the new folder (`recombined`).\n"
"> > The third line makes a copy of the file we just moved.\n"
"> > The tricky part here is where the file was copied to.\n"
"> > Recall that `..` means 'go up a level', so the copied file is now in `/Users/jamie`.\n"
"> > Notice that `..` is interpreted with respect to the current working\n"
"> > directory, **not** with respect to the location of the file being copied.\n"
"> > So, the only thing that will show using ls (in `/Users/jamie/data`) is the recombined folder.\n"
"> >\n"
"> > 1. No, see explanation above.  `proteins-saved.dat` is located at `/Users/jamie`\n"
"> > 2. Yes\n"
"> > 3. No, see explanation above.  `proteins.dat` is located at `/Users/jamie/data/recombined`\n"
"> > 4. No, see explanation above.  `proteins-saved.dat` is located at `/Users/jamie`"
msgstr ""
">\n"
">\n"
"> 1. `proteins-saved.dat рекомбіновано\n"
"> 2. `recombined`\n"
"> 3. `proteins.dat recombined`.\n"
"> 4. `proteins-saved.dat`.\n"
">\n"
"> > ## Рішення\n"
"> > Ми розпочинаємо в каталозі `/Users/jamie/data` і створюємо нову папку з назвою `recombined`.\n"
"> > Другий рядок переміщує (`mv`) файл `proteins.dat` до нового каталогу (`recombined`).\n"
"> > Третій рядок робить копію файлу, який ми щойно перемістили.\n"
"> > Складність полягає у тому, куди саме було скопійовано файл.\n"
"> > Нагадаємо, що `..` означає \"піднятися на рівень вище\", тому скопійований файл тепер знаходиться у `/Users/jamie`.\n"
"> > Зверніть увагу, що `..` інтерпретується відносно поточного робочого\n"
"> > каталогу, а **не** відносно розташування файла, який копіюється.\n"
"> > Отже, єдине, що буде показано за допомогою команди `ls` (у `/Users/jamie/data`) - це каталог `recombined`.\n"
"> >\n"
"> > 1. Ні, див. пояснення вище. Каталог `proteins-saved.dat` розташовано у каталозі `/Users/jamie`.\n"
"> > 2. Так\n"
"> > 3. Ні, див. пояснення вище. Файл `proteins.dat` знаходиться в каталозі `/Users/jamie/data/recombined`.\n"
"> > 4. Ні, див. пояснення вище. Файл `proteins-saved.dat` знаходиться в каталозі `/Users/jamie`."

# header
#: shell-novice/_episodes/03-create.md:562
msgid "## Removing files and directories"
msgstr "## Видалення файлів і каталогів"

#: shell-novice/_episodes/03-create.md:564
msgid ""
"Returning to the `shell-lesson-data/exercise-data/writing` directory,\n"
"let's tidy up this directory by removing the `quotes.txt` file we created.\n"
"The Unix command we'll use for this is `rm` (short for 'remove'):"
msgstr ""
"Повертаючись до каталогу `shell-lesson-data/exercise-data/writing`,\n"
"давайте почистимо цей каталог, видаливши створений нами файл `quotes.txt`.\n"
"Для цього ми скористаємося командою Unix `rm` (скорочення від англ. `remove` - видаляти):"

# code block
#: shell-novice/_episodes/03-create.md:568
msgid ""
"~~~\n"
"$ rm quotes.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ rm quotes.txt\n"
"~~~"

#: shell-novice/_episodes/03-create.md:573
msgid "We can confirm the file has gone using `ls`:"
msgstr "Ми можемо підтвердити, що файл був видалений, за допомогою `ls`:"

# code block
#: shell-novice/_episodes/03-create.md:580
msgid ""
"```\n"
"ls: cannot access 'quotes.txt': No such file or directory\n"
"```"
msgstr ""
"```\n"
"ls: cannot access 'quotes.txt': No such file or directory\n"
"```"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:585
msgid "> ## Deleting Is Forever"
msgstr "> ## Команда `ls` видаляє назавжди"

#: shell-novice/_episodes/03-create.md:586
msgid ""
">\n"
"> The Unix shell doesn't have a trash bin that we can recover deleted\n"
"> files from (though most graphical interfaces to Unix do).  Instead,\n"
"> when we delete files, they are unlinked from the file system so that\n"
"> their storage space on disk can be recycled. Tools for finding and\n"
"> recovering deleted files do exist, but there's no guarantee they'll\n"
"> work in any particular situation, since the computer may recycle the\n"
"> file's disk space right away."
msgstr ""
">\n"
"> В терміналу Unix немає кошика, з якого можна було б відновити видалені\n"
"> файли (хоча у більшості графічних інтерфейсів Unix він є). Замість цього\n"
"> коли ми видаляємо файли, вони від'єднуються від файлової системи, щоб\n"
"> їх місце на диску можна було використовувати повторно. Інструменти для пошуку та\n"
"> відновлення видалених файлів існують, але немає жодних гарантій, що вони\n"
"> працюватимуть у кожній конкретній ситуації, оскільки комп'ютер може повторно використати\n"
"> місце на диску, яке займав файл, одразу ж."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:597
msgid "> ## Using `rm` Safely"
msgstr "> ## Безпечне використання `rm`"

#: shell-novice/_episodes/03-create.md:598
msgid ""
">\n"
"> What happens when we execute `rm -i thesis_backup/quotations.txt`?\n"
"> Why would we want this protection when using `rm`?\n"
">\n"
"> > ## Solution\n"
"> > ```\n"
"> > rm: remove regular file 'thesis_backup/quotations.txt'? y\n"
"> > ```\n"
"> > {: .output}\n"
"> > The `-i` option will prompt before (every) removal (use <kbd>Y</kbd> to confirm deletion\n"
"> > or <kbd>N</kbd> to keep the file).\n"
"> > The Unix shell doesn't have a trash bin, so all the files removed will disappear forever.\n"
"> > By using the `-i` option, we have the chance to check that we are deleting only the files\n"
"> > that we want to remove."
msgstr ""
" >\n"
"> Що відбувається, коли ми виконуємо `rm -i thesis_backup/quotations.txt`?\n"
"> Навіщо нам потрібен цей захист при використанні `rm`?\n"
">\n"
"> > ## Рішення\n"
"> > ```\n"
"> > rm: видалити звичайний файл 'thesis_backup/quotations.txt'? y\n"
"> > ```\n"
"> > {: .output}\n"
"> > Параметр `-i` буде запитуватися перед (кожним) вилученням (використовуйте <kbd>Y</kbd> для підтвердження вилучення\n"
"> > або <kbd>N</kbd>, щоб зберегти файл).\n"
"> > У командному терміналі Unix немає кошика для сміття, тому всі вилучені файли зникнуть назавжди.\n"
"> > За допомогою опції `-i` ми можемо перевірити, що видаляємо лише ті файли,\n"
"> які ми хочемо видалити."

#: shell-novice/_episodes/03-create.md:616
msgid ""
"If we try to remove the `thesis` directory using `rm thesis`,\n"
"we get an error message:"
msgstr ""
"Якщо ми спробуємо видалити каталог `thesis` за допомогою `rm thesis`,\n"
"ми отримаємо повідомлення про помилку:"

# code block
#: shell-novice/_episodes/03-create.md:619
msgid ""
"~~~\n"
"$ rm thesis\n"
"~~~"
msgstr ""
"~~~\n"
"$ rm thesis\n"
"~~~"

# code block
#: shell-novice/_episodes/03-create.md:624
msgid ""
"~~~\n"
"rm: cannot remove `thesis': Is a directory\n"
"~~~"
msgstr ""
"~~~\n"
"rm: cannot remove `thesis': Is a directory\n"
"~~~"

#: shell-novice/_episodes/03-create.md:629
msgid ""
"This happens because `rm` by default only works on files, not directories."
msgstr ""
"Це відбувається тому, що команда `rm` за замовчуванням працює лише з "
"файлами, а не з каталогами."

#: shell-novice/_episodes/03-create.md:631
msgid ""
"`rm` can remove a directory *and all its contents* if we use the\n"
"recursive option `-r`, and it will do so *without any confirmation prompts*:"
msgstr ""
"Команда `rm` може видалити каталог *і весь його вміст*, якщо ми використаємо\n"
"рекурсивний параметр `-r`, і вона зробить це *без жодних запитів на підтвердження*:"

# code block
#: shell-novice/_episodes/03-create.md:634
msgid ""
"~~~\n"
"$ rm -r thesis\n"
"~~~"
msgstr ""
"~~~\n"
"$ rm -r thesis\n"
"~~~"

#: shell-novice/_episodes/03-create.md:639
msgid ""
"Given that there is no way to retrieve files deleted using the shell,\n"
"`rm -r` *should be used with great caution*\n"
"(you might consider adding the interactive option `rm -r -i`)."
msgstr ""
"Враховуючи, що немає можливості відновити файли, видалені за допомогою терміналу,\n"
"`rm -r` *слід використовувати з великою обережністю*.\n"
"(ви можете розглянути можливість додавання інтерактивного параметра `rm -r -i`)."

# header
#: shell-novice/_episodes/03-create.md:643
msgid "## Operations with multiple files and directories"
msgstr "## Операції з декількома файлами та каталогами"

#: shell-novice/_episodes/03-create.md:645
msgid ""
"Oftentimes one needs to copy or move several files at once.\n"
"This can be done by providing a list of individual filenames,\n"
"or specifying a naming pattern using wildcards."
msgstr ""
"Часто потрібно скопіювати або перемістити кілька файлів одночасно.\n"
"Це можна зробити, надавши список імен окремих файлів,\n"
"або вказати шаблон імен за допомогою підстановочних знаків."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:649
msgid "> ## Copy with Multiple Filenames"
msgstr "> ## Копіювання з кількома іменами файлів"

#: shell-novice/_episodes/03-create.md:650
msgid ""
">\n"
"> For this exercise, you can test the commands in the `shell-lesson-data/exercise-data` directory.\n"
">\n"
"> In the example below, what does `cp` do when given several filenames and a directory name?\n"
">\n"
"> ~~~\n"
"> $ mkdir backup\n"
"> $ cp creatures/minotaur.dat creatures/unicorn.dat backup/\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> In the example below, what does `cp` do when given three or more file names?\n"
">\n"
"> ~~~\n"
"> $ cd creatures\n"
"> $ ls -F\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> basilisk.dat  minotaur.dat  unicorn.dat\n"
"> ~~~"
msgstr ""
">\n"
"> Для цієї вправи ви можете протестувати команди з каталогу `shell-lesson-data/exercise-data`.\n"
">\n"
"> Що робить команда `cp` у наведеному нижче прикладі, коли їй задано декілька імен файлів і назву каталогу?\n"
">\n"
"> ~~~\n"
"> $ mkdir backup\n"
"> $ cp creatures/minotaur.dat creatures/unicorn.dat backup/\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Що робить команда `cp` у наведеному нижче прикладі, коли їй задано три або більше імен файлів?\n"
">\n"
"> ~~~\n"
"> $ cd creatures\n"
"> $ ls -F\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> basilisk.dat minotaur.dat unicorn.dat\n"
"> ~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:673
msgid "> $ cp minotaur.dat unicorn.dat basilisk.dat"
msgstr "> $ cp minotaur.dat unicorn.dat basilisk.dat"

#: shell-novice/_episodes/03-create.md:676
msgid ""
">\n"
"> > ## Solution\n"
"> > If given more than one file name followed by a directory name\n"
"> > (i.e. the destination directory must be the last argument),\n"
"> > `cp` copies the files to the named directory.\n"
"> >\n"
"> > If given three file names, `cp` throws an error such as the one below,\n"
"> > because it is expecting a directory name as the last argument.\n"
"> >\n"
"> > ```\n"
"> > cp: target 'basilisk.dat' is not a directory\n"
"> > ```\n"
"> > {: .error}"
msgstr ""
">\n"
"> > ## Розв'язання\n"
"> Якщо задано більше одного імені файлу, за яким наведене ім'я каталогу,\n"
"> > (тобто, каталог призначення має бути останнім аргументом),\n"
"> > команда `cp` копіює файли до вказаного каталогу.\n"
"> >\n"
"> > Якщо задано три імені файлів, `cp` видасть помилку, подібну до наведеної нижче,\n"
"> > оскільки очікує отримати ім'я каталогу як останній аргумент.\n"
"> >\n"
"> > ```\n"
"> > cp: target 'basilisk.dat' не є каталогом\n"
"> > ```\n"
"> > {: .error}"

# header
#: shell-novice/_episodes/03-create.md:692
msgid "### Using wildcards for accessing multiple files at once"
msgstr ""
"### Використання підстановочних знаків для доступу до кількох файлів "
"одночасно"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:694
#: shell-novice/_episodes/07-find.md:279
msgid "> ## Wildcards"
msgstr "> ## Підстановочні символи"

#: shell-novice/_episodes/03-create.md:695
msgid ""
">\n"
"> `*` is a **wildcard**, which matches zero or more  characters.\n"
"> Let's consider the `shell-lesson-data/exercise-data/proteins` directory:\n"
"> `*.pdb` matches `ethane.pdb`, `propane.pdb`, and every\n"
"> file that ends with '.pdb'. On the other hand, `p*.pdb` only matches\n"
"> `pentane.pdb` and `propane.pdb`, because the 'p' at the front only\n"
"> matches filenames that begin with the letter 'p'.\n"
">\n"
"> `?` is also a wildcard, but it matches exactly one character.\n"
"> So `?ethane.pdb` would match `methane.pdb` whereas\n"
"> `*ethane.pdb` matches both `ethane.pdb`, and `methane.pdb`.\n"
">\n"
"> Wildcards can be used in combination with each other\n"
"> e.g. `???ane.pdb` matches three characters followed by `ane.pdb`,\n"
"> giving `cubane.pdb  ethane.pdb  octane.pdb`.\n"
">\n"
"> When the shell sees a wildcard, it expands the wildcard to create a\n"
"> list of matching filenames *before* running the command that was\n"
"> asked for. As an exception, if a wildcard expression does not match\n"
"> any file, Bash will pass the expression as an argument to the command\n"
"> as it is. For example, typing `ls *.pdf` in the `proteins` directory\n"
"> (which contains only files with names ending with `.pdb`) results in\n"
"> an error message that there is no file called `*.pdf`.\n"
"> However, generally commands like `wc` and `ls` see the lists of\n"
"> file names matching these expressions, but not the wildcards\n"
"> themselves. It is the shell, not the other programs, that deals with\n"
"> expanding wildcards."
msgstr ""
">\n"
"> Символ `*` - це **підстановочний символ**, який відповідає нулю або більшій кількості будь-яких символів.\n"
"> Розглянемо каталог `shell-lesson-data/exercise-data/proteins`:\n"
"> `*.pdb` відповідає `ethane.pdb`, `propane.pdb` і кожному\n"
"> файлу, який закінчується на '.pdb'. З іншого боку, `p*.pdb` співпадає лише з\n"
"> `pentane.pdb` і `propane.pdb`, оскільки \"p\" спереду лише\n"
"> співпадає з назвами файлів, які починаються з літери 'p'.\n"
">\n"
"> Символ `?` також є подстановочним символом, але він відповідає рівно одному будь-якому символу.\n"
"> Отже, `?ethane.pdb` буде відповідати `methane.pdb`, тоді як\n"
"> `*ethane.pdb` відповідає як `ethane.pdb`, так і `methane.pdb`.\n"
">\n"
"> Підставні символи можна використовувати у поєднанні один з одним\n"
"> наприклад, `???ane.pdb` відповідає трьом символам, за якими слідує `ane.pdb`,\n"
"> що дає `cubane.pdb ethane.pdb octane.pdb`.\n"
">\n"
"> Коли термінал бачить підстановочний символ, він розгортає його для створення\n"
"> списку відповідних імен файлів *до* запуску команди, яку.\n"
"> було введено. Як виняток, якщо вираз підстановки не відповідає\n"
"> жодному файлу, Bash передасть вираз як аргумент до команди,\n"
"> як є. Наприклад, введення `ls *.pdf` у каталозі `proteins`\n"
"> (який містить лише файли з іменами, що закінчуються на `.pdb`) призведе до\n"
"> повідомлення про те, що не існує файла з назвою `*.pdf`.\n"
"> Втім, зазвичай команди на кшталт `wc` і `ls` показують списки > імен файлів, які відповідають цим виразам,\n"
"> але не самим підстановочним символам.\n"
"> Саме термінал, а не інші програми, виконує\n"
"> розкриття підстановочних символів."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:724
msgid "> ## List filenames matching a pattern"
msgstr "> ## Отримання переліку імен файлів, що відповідають шаблону"

#: shell-novice/_episodes/03-create.md:725
msgid ""
">\n"
"> When run in the `proteins` directory, which `ls` command(s) will\n"
"> produce this output?\n"
">\n"
"> `ethane.pdb   methane.pdb`\n"
">\n"
"> 1. `ls *t*ane.pdb`\n"
"> 2. `ls *t?ne.*`\n"
"> 3. `ls *t??ne.pdb`\n"
"> 4. `ls ethane.*`\n"
">\n"
"> > ## Solution\n"
">>  The solution is `3.`\n"
">>\n"
">> `1.` shows all files whose names contain zero or more characters (`*`)\n"
">> followed by the letter `t`,\n"
">> then zero or more characters (`*`) followed by `ane.pdb`.\n"
">> This gives `ethane.pdb  methane.pdb  octane.pdb  pentane.pdb`.\n"
">>\n"
">> `2.` shows all files whose names start with zero or more characters (`*`) followed by\n"
">> the letter `t`,\n"
">> then a single character (`?`), then `ne.` followed by zero or more characters (`*`).\n"
">> This will give us `octane.pdb` and `pentane.pdb` but doesn't match anything\n"
">> which ends in `thane.pdb`.\n"
">>\n"
">> `3.` fixes the problems of option 2 by matching two characters (`??`) between `t` and `ne`.\n"
">> This is the solution.\n"
">>\n"
">> `4.` only shows files starting with `ethane.`."
msgstr ""
">\n"
"> При виконанні в каталозі `proteins`, яка з команд `ls` видасть\n"
"> наступний результат?\n"
">\n"
"> `ethane.pdb methane.pdb`\n"
">\n"
"> 1. `ls *t*ane.pdb`\n"
"> 2. `ls *t?ne.*`\n"
"> 3. `ls *t??ne.pdb`\n"
"> 4. `ls ethane.*`\n"
">\n"
"> Розв'язок\n"
">> Розв'язком є `3`.\n"
">>\n"
">> `1.` показує всі файли, назви яких містять нуль або більше символів (`*`)\n"
">> далі йде літера `t`,\n"
">> потім нуль або більше символів (`*`) і далі `ane.pdb`.\n"
">> Це дасть `ethane.pdb methane.pdb octane.pdb pentane.pdb`.\n"
">>\n"
">> `2.` показує всі файли, назви яких починаються з нуля або більше символів (`*`), за якими йде\n"
">> літера `t`,\n"
">> потім один будь-який символ (`?`), потім `ne.` і далі нуль або більше символів (`*`).\n"
">> Це дасть нам `octane.pdb` і `pentane.pdb`, але не збігається ні з чим,\n"
">> що закінчується на `thane.pdb`.\n"
">>\n"
">> `3.` виправляє проблеми варіанта 2, зіставляючи два символи (`??`) між `t` і `ne`.\n"
">> Це і є рішення.\n"
">>\n"
">> `4.` показує лише файли, що починаються з `ethane.`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:757
msgid "> ## More on Wildcards"
msgstr "> ## Більше про підстановочні символи"

#: shell-novice/_episodes/03-create.md:758
msgid ""
">\n"
"> Sam has a directory containing calibration data, datasets, and descriptions of\n"
"> the datasets:\n"
">\n"
"> ~~~\n"
"> .\n"
"> ├── 2015-10-23-calibration.txt\n"
"> ├── 2015-10-23-dataset1.txt\n"
"> ├── 2015-10-23-dataset2.txt\n"
"> ├── 2015-10-23-dataset_overview.txt\n"
"> ├── 2015-10-26-calibration.txt\n"
"> ├── 2015-10-26-dataset1.txt\n"
"> ├── 2015-10-26-dataset2.txt\n"
"> ├── 2015-10-26-dataset_overview.txt\n"
"> ├── 2015-11-23-calibration.txt\n"
"> ├── 2015-11-23-dataset1.txt\n"
"> ├── 2015-11-23-dataset2.txt\n"
"> ├── 2015-11-23-dataset_overview.txt\n"
"> ├── backup\n"
"> │   ├── calibration\n"
"> │   └── datasets\n"
"> └── send_to_bob\n"
">     ├── all_datasets_created_on_a_23rd\n"
">     └── all_november_files\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Before heading off to another field trip, she wants to back up her data and\n"
"> send some datasets to her colleague Bob. Sam uses the following commands\n"
"> to get the job done:\n"
">\n"
"> ~~~\n"
"> $ cp *dataset* backup/datasets\n"
"> $ cp ____calibration____ backup/calibration\n"
"> $ cp 2015-____-____ send_to_bob/all_november_files/\n"
"> $ cp ____ send_to_bob/all_datasets_created_on_a_23rd/\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Help Sam by filling in the blanks.\n"
">\n"
"> The resulting directory structure should look like this\n"
"> ```\n"
"> .\n"
"> ├── 2015-10-23-calibration.txt\n"
"> ├── 2015-10-23-dataset1.txt\n"
"> ├── 2015-10-23-dataset2.txt\n"
"> ├── 2015-10-23-dataset_overview.txt\n"
"> ├── 2015-10-26-calibration.txt\n"
"> ├── 2015-10-26-dataset1.txt\n"
"> ├── 2015-10-26-dataset2.txt\n"
"> ├── 2015-10-26-dataset_overview.txt\n"
"> ├── 2015-11-23-calibration.txt\n"
"> ├── 2015-11-23-dataset1.txt\n"
"> ├── 2015-11-23-dataset2.txt\n"
"> ├── 2015-11-23-dataset_overview.txt\n"
"> ├── backup\n"
"> │   ├── calibration\n"
"> │   │   ├── 2015-10-23-calibration.txt\n"
"> │   │   ├── 2015-10-26-calibration.txt\n"
"> │   │   └── 2015-11-23-calibration.txt\n"
"> │   └── datasets\n"
"> │       ├── 2015-10-23-dataset1.txt\n"
"> │       ├── 2015-10-23-dataset2.txt\n"
"> │       ├── 2015-10-23-dataset_overview.txt\n"
"> │       ├── 2015-10-26-dataset1.txt\n"
"> │       ├── 2015-10-26-dataset2.txt\n"
"> │       ├── 2015-10-26-dataset_overview.txt\n"
"> │       ├── 2015-11-23-dataset1.txt\n"
"> │       ├── 2015-11-23-dataset2.txt\n"
"> │       └── 2015-11-23-dataset_overview.txt\n"
"> └── send_to_bob\n"
">     ├── all_datasets_created_on_a_23rd\n"
">     │   ├── 2015-10-23-dataset1.txt\n"
">     │   ├── 2015-10-23-dataset2.txt\n"
">     │   ├── 2015-10-23-dataset_overview.txt\n"
">     │   ├── 2015-11-23-dataset1.txt\n"
">     │   ├── 2015-11-23-dataset2.txt\n"
">     │   └── 2015-11-23-dataset_overview.txt\n"
">     └── all_november_files\n"
">         ├── 2015-11-23-calibration.txt\n"
">         ├── 2015-11-23-dataset1.txt\n"
">         ├── 2015-11-23-dataset2.txt\n"
">         └── 2015-11-23-dataset_overview.txt\n"
"> ```\n"
"> {: .language-bash}\n"
">\n"
"> > ## Solution\n"
"> > ```\n"
"> > $ cp *calibration.txt backup/calibration\n"
"> > $ cp 2015-11-* send_to_bob/all_november_files/\n"
"> > $ cp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/\n"
"> > ```\n"
"> > {: .language-bash}"
msgstr ""
">\n"
"> Сем має каталог, який містить дані калібрування, набори даних та описи\n"
"> наборів даних:\n"
">\n"
"> ~~~\n"
"> .\n"
"> ├── 2015-10-23-calibration.txt\n"
"> ├── 2015-10-23-dataset1.txt\n"
"> ├── 2015-10-23-dataset2.txt\n"
"> ├── 2015-10-23-dataset_overview.txt\n"
"> ├── 2015-10-26-calibration.txt\n"
"> ├── 2015-10-26-dataset1.txt\n"
"> ├── 2015-10-26-dataset2.txt\n"
"> ├── 2015-10-26-dataset_overview.txt\n"
"> ├── 2015-11-23-calibration.txt\n"
"> ├── 2015-11-23-dataset1.txt\n"
"> ├── 2015-11-23-dataset2.txt\n"
"> ├── 2015-11-23-dataset_overview.txt\n"
"> ├── backup\n"
"> │   ├── calibration\n"
"> │   └── datasets\n"
"> └── send_to_bob\n"
">     ├── all_datasets_created_on_a_23rd\n"
">     └── all_november_files\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Перед тим, як вирушити на чергову екскурсію, вона хоче створити резервну копію даних і\n"
"> надіслати деякі набори даних своєму колезі Бобу. Сем використовує наступні команди\n"
"> щоб виконати роботу:\n"
">\n"
"> ~~~\n"
"> $ cp *dataset* backup/datasets\n"
"> $ cp ____calibration____ backup/calibration\n"
"> $ cp 2015-____-____ send_to_bob/all_november_files/\n"
"> $ cp ____ send_to_bob/all_datasets_created_on_a_23rd/\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Допоможіть Сему, заповнивши пропуски.\n"
">\n"
"> Отримана структура каталогів повинна виглядати наступним чином\n"
"> ```\n"
"> .\n"
"> ├── 2015-10-23-calibration.txt\n"
"> ├── 2015-10-23-dataset1.txt\n"
"> ├── 2015-10-23-dataset2.txt\n"
"> ├── 2015-10-23-dataset_overview.txt\n"
"> ├── 2015-10-26-calibration.txt\n"
"> ├── 2015-10-26-dataset1.txt\n"
"> ├── 2015-10-26-dataset2.txt\n"
"> ├── 2015-10-26-dataset_overview.txt\n"
"> ├── 2015-11-23-calibration.txt\n"
"> ├── 2015-11-23-dataset1.txt\n"
"> ├── 2015-11-23-dataset2.txt\n"
"> ├── 2015-11-23-dataset_overview.txt\n"
"> ├── backup\n"
"> │   ├── calibration\n"
"> │   │   ├── 2015-10-23-calibration.txt\n"
"> │   │   ├── 2015-10-26-calibration.txt\n"
"> │   │   └── 2015-11-23-calibration.txt\n"
"> │   └── datasets\n"
"> │       ├── 2015-10-23-dataset1.txt\n"
"> │       ├── 2015-10-23-dataset2.txt\n"
"> │       ├── 2015-10-23-dataset_overview.txt\n"
"> │       ├── 2015-10-26-dataset1.txt\n"
"> │       ├── 2015-10-26-dataset2.txt\n"
"> │       ├── 2015-10-26-dataset_overview.txt\n"
"> │       ├── 2015-11-23-dataset1.txt\n"
"> │       ├── 2015-11-23-dataset2.txt\n"
"> │       └── 2015-11-23-dataset_overview.txt\n"
"> └── send_to_bob\n"
">     ├── all_datasets_created_on_a_23rd\n"
">     │   ├── 2015-10-23-dataset1.txt\n"
">     │   ├── 2015-10-23-dataset2.txt\n"
">     │   ├── 2015-10-23-dataset_overview.txt\n"
">     │   ├── 2015-11-23-dataset1.txt\n"
">     │   ├── 2015-11-23-dataset2.txt\n"
">     │   └── 2015-11-23-dataset_overview.txt\n"
">     └── all_november_files\n"
">         ├── 2015-11-23-calibration.txt\n"
">         ├── 2015-11-23-dataset1.txt\n"
">         ├── 2015-11-23-dataset2.txt\n"
">         └── 2015-11-23-dataset_overview.txt\n"
"> ```\n"
"> {: .language-bash}\n"
">\n"
"> > ## Розв'язання\n"
"> > ```\n"
"> > $ cp *calibration.txt backup/calibration\n"
"> > $ cp 2015-11-* send_to_bob/all_november_files/\n"
"> > $ cp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/\n"
"> > ```\n"
"> > {: .language-bash}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:855
msgid "> ## Organizing Directories and Files"
msgstr "> ## Упорядкування каталогів і файлів"

#: shell-novice/_episodes/03-create.md:856
msgid ""
">\n"
"> Jamie is working on a project and she sees that her files aren't very well\n"
"> organized:\n"
">\n"
"> ~~~\n"
"> $ ls -F\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> analyzed/  fructose.dat    raw/   sucrose.dat\n"
"> ~~~"
msgstr ""
">\n"
"> Джеймі працює над проектом і бачить, що її файли не дуже добре\n"
"> впорядковані:\n"
">\n"
"> ~~~\n"
"> $ ls -F\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> analyzed/  fructose.dat    raw/   sucrose.dat\n"
"> ~~~"

#: shell-novice/_episodes/03-create.md:868
msgid ""
">\n"
"> The `fructose.dat` and `sucrose.dat` files contain output from her data\n"
"> analysis. What command(s) covered in this lesson does she need to run\n"
"> so that the commands below will produce the output shown?\n"
">\n"
"> ~~~\n"
"> $ ls -F\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> analyzed/   raw/\n"
"> ~~~"
msgstr ""
">\n"
"> Файли `fructose.dat` та `ucrose.dat` містять результати її\n"
"> аналізу. Яку команду (команди), розглянуту (розглянуті) у цьому уроці, їй потрібно виконати,\n"
"> щоб наведені нижче команди створили показані нижче результати?\n"
">\n"
"> ~~~\n"
"> $ ls -F\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> analyzed/   raw/\n"
"> ~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:882
msgid "> $ ls analyzed"
msgstr "> $ ls analyzed"

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:886
msgid "> fructose.dat    sucrose.dat"
msgstr "> fructose.dat    sucrose.dat"

#: shell-novice/_episodes/03-create.md:889
msgid ""
">\n"
"> > ## Solution\n"
"> > ```\n"
"> > mv *.dat analyzed\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> > Jamie needs to move her files `fructose.dat` and `sucrose.dat` to the `analyzed` directory.\n"
"> > The shell will expand *.dat to match all .dat files in the current directory.\n"
"> > The `mv` command then moves the list of .dat files to the 'analyzed' directory."
msgstr ""
">\n"
"> > Розв'язання\n"
"> > ```\n"
"> > mv *.dat analyzed\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> > Джеймі потрібно перемістити файли `fructose.dat` та `ucrose.dat` до каталогу `analyzed`.\n"
"> > Термінал розширить шаблон *.dat так, щоб він відповідав усім файлам .dat у поточному каталозі.\n"
"> > Команда `mv` перемістить сформований перелік файлів .dat до каталогу 'analyzed'."

# blockquote, which can be cascaded
#: shell-novice/_episodes/03-create.md:901
msgid "> ## Reproduce a folder structure"
msgstr "> ## Відтворити структуру папок"

#: shell-novice/_episodes/03-create.md:902
msgid ""
">\n"
"> You're starting a new experiment and would like to duplicate the directory\n"
"> structure from your previous experiment so you can add new data.\n"
">\n"
"> Assume that the previous experiment is in a folder called `2016-05-18`,\n"
"> which contains a `data` folder that in turn contains folders named `raw` and\n"
"> `processed` that contain data files.  The goal is to copy the folder structure\n"
"> of the `2016-05-18` folder into a folder called `2016-05-20`\n"
"> so that your final directory structure looks like this:\n"
">\n"
"> ~~~\n"
"> 2016-05-20/\n"
"> └── data\n"
">    ├── processed\n"
">    └── raw\n"
"> ~~~"
msgstr ""
">\n"
"> Ви починаєте новий експеримент і хочете продублювати структуру каталогу\n"
"> з попереднього експерименту, щоб ви могли додати нові дані.\n"
">\n"
"> Припустимо, що попередній експеримент знаходиться у каталозі з назвою `2016-05-18`,\n"
"> який містить каталог `data`, який, у свою чергу, містить каталоги `raw` і\n"
"> `processed`, які містять файли даних. Мета полягає у копіюванні структури папок\n"
"> каталогу `2016-05-18` до каталогу з назвою `2016-05-20` \n"
"> таким чином, щоб ваша фінальна структура каталогів виглядала наступним чином:\n"
">\n"
"> ~~~\n"
"> 2016-05-20/\n"
"> └── data\n"
">    ├── processed\n"
">    └── raw\n"
"> ~~~"

#: shell-novice/_episodes/03-create.md:919
msgid ""
">\n"
"> Which of the following set of commands would achieve this objective?\n"
"> What would the other commands do?\n"
">\n"
"> ~~~\n"
"> $ mkdir 2016-05-20\n"
"> $ mkdir 2016-05-20/data\n"
"> $ mkdir 2016-05-20/data/processed\n"
"> $ mkdir 2016-05-20/data/raw\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> $ mkdir 2016-05-20\n"
"> $ cd 2016-05-20\n"
"> $ mkdir data\n"
"> $ cd data\n"
"> $ mkdir raw processed\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> $ mkdir 2016-05-20/data/raw\n"
"> $ mkdir 2016-05-20/data/processed\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> $ mkdir -p 2016-05-20/data/raw\n"
"> $ mkdir -p 2016-05-20/data/processed\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> $ mkdir 2016-05-20\n"
"> $ cd 2016-05-20\n"
"> $ mkdir data\n"
"> $ mkdir raw processed\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> >\n"
"> > ## Solution\n"
"> > The first two sets of commands achieve this objective.\n"
"> > The first set uses relative paths to create the top-level directory before\n"
"> > the subdirectories.\n"
"> >\n"
"> > The third set of commands will give an error because the default behavior of `mkdir`\n"
"> > won't create a subdirectory of a non-existent directory:\n"
"> > the intermediate level folders must be created first.\n"
"> >\n"
"> > The fourth set of commands achieve this objective. Remember, the `-p` option,\n"
"> > followed by a path of one or more\n"
"> > directories, will cause `mkdir` to create any intermediate subdirectories as required.\n"
"> >\n"
"> > The final set of commands generates the 'raw' and 'processed' directories at the same level\n"
"> > as the 'data' directory."
msgstr ""
">\n"
"> Який з наведених нижче наборів команд досягне цієї мети?\n"
"> Що зроблять інші команди?\n"
">\n"
"> ~~~\n"
"> $ mkdir 2016-05-20\n"
"> $ mkdir 2016-05-20/data\n"
"> $ mkdir 2016-05-20/data/processed\n"
"> $ mkdir 2016-05-20/data/raw\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> $ mkdir 2016-05-20\n"
"> $ cd 2016-05-20\n"
"> $ mkdir data\n"
"> $ cd data\n"
"> $ mkdir raw processed\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> $ mkdir 2016-05-20/data/raw\n"
"> $ mkdir 2016-05-20/data/processed\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> $ mkdir -p 2016-05-20/data/raw\n"
"> $ mkdir -p 2016-05-20/data/processed\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> $ mkdir 2016-05-20\n"
"> $ cd 2016-05-20\n"
"> $ mkdir data\n"
"> $ mkdir raw processed\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> >\n"
"> > ## Розв'язання\n"
"> > Перші два набори команд досягають цієї мети.\n"
"> > Перший набір використовує відносні шляхи для створення каталогу верхнього рівня перед\n"
"> > підкаталогами.\n"
"> >\n"
"> > Третій набір команд призведе до помилки, оскільки поведінка `mkdir` за замовчуванням\n"
"> > не створює підкаталог в каталозі, що не існує:\n"
"> > спочатку мають бути створені каталоги проміжних рівнів.\n"
"> >\n"
"> > Четвертий набір команд досягає цієї мети. Пам'ятайте, опція `-p`,\n"
"> > за яким слідує шлях до одного або декількох\n"
"> > каталогів, змусить `mkdir` створити будь-які проміжні підкаталоги за потреби.\n"
"> >\n"
"> > Останній набір команд створить каталоги 'raw' і 'processed' на тому ж рівні, \n"
"> > що і каталог 'data'."

# Front Matter
#: shell-novice/_episodes/04-pipefilter.md:1
msgid ""
"---\n"
"title: \"Pipes and Filters\"\n"
"teaching: 25\n"
"exercises: 10\n"
"questions:\n"
"- \"How can I combine existing commands to do new things?\"\n"
"objectives:\n"
"- \"Redirect a command's output to a file.\"\n"
"- \"Construct command pipelines with two or more stages.\"\n"
"- \"Explain what usually happens if a program or pipeline isn't given any input to process.\"\n"
"- \"Explain the advantage of linking commands with pipes and filters.\"\n"
"keypoints:\n"
"- \"`wc` counts lines, words, and characters in its inputs.\"\n"
"- \"`cat` displays the contents of its inputs.\"\n"
"- \"`sort` sorts its inputs.\"\n"
"- \"`head` displays the first 10 lines of its input.\"\n"
"- \"`tail` displays the last 10 lines of its input.\"\n"
"- \"`command > [file]` redirects a command's output to a file (overwriting any existing content).\"\n"
"- \"`command >> [file]` appends a command's output to a file.\"\n"
"- \"`[first] | [second]` is a pipeline: the output of the first command is used as the input to the second.\"\n"
"- \"The best way to use the shell is to use pipes to combine simple single-purpose programs (filters).\"\n"
"---"
msgstr ""
"---\n"
"title: \"Канали та фільтри\"\n"
"teaching: 25\n"
"exercises: 10\n"
"questions:\n"
"- \"Як я можу комбінувати команди, що вже існують, щоб робити нові речі?\"\n"
"objectives:\n"
"- \"Перенаправити вивід команди до файлу.\"\n"
"- \"Створити конвеєри команд з двома та більше ступенями.\"\n"
"- \"Пояснити, що зазвичай відбувається, якщо програмі або конвеєру не надається жодних вхідних даних для обробки.\"\n"
"- \"Пояснити перевагу поєднання команд з каналами та фільтрами.\"\n"
"keypoints:\n"
"- \"`wc` підраховує рядки, слова та символи у вхідних даних.\"\n"
"- \"cat` виводить вміст своїх вхідних даних.\"\n"
"- \"`sort` сортує вхідні дані.\"\n"
"- \"`head` виводить перші 10 рядків вхідних даних.\"\n"
"- \"`tail` виводить останні 10 рядків вхідних даних.\"\n"
"- \"`command > [file]` перенаправляє вивід команди у файл (перезаписуючи наявний вміст).\"\n"
"- \"`command >> [file]` додає вивід команди до файлу.\"\n"
"- \"`[first] | [second]` є конвеєром: вихід першої команди використовується як вхід для другої.\"\n"
"- \"Найкращий спосіб використання терміналу - це використання каналів для об'єднання простих одноцільових програм (фільтрів).\"\n"
"---"

#: shell-novice/_episodes/04-pipefilter.md:24
msgid ""
"Now that we know a few basic commands,\n"
"we can finally look at the shell's most powerful feature:\n"
"the ease with which it lets us combine existing programs in new ways.\n"
"We'll start with the directory `shell-lesson-data/exercise-data/proteins`\n"
"that contains six files describing some simple organic molecules.\n"
"The `.pdb` extension indicates that these files are in Protein Data Bank format,\n"
"a simple text format that specifies the type and position of each atom in the molecule."
msgstr ""
"Тепер, коли ми знаємо декілька основних команд,\n"
"ми можемо нарешті розглянути найпотужнішу можливість терміналу:\n"
"легкість, з якою він дозволяє нам комбінувати програми, що існують, новими способами.\n"
"Ми почнемо з каталогу `shell-lesson-data/exercise-data/proteins`,\n"
"який містить шість файлів, що описують деякі прості органічні молекули.\n"
"Розширення `.pdb` вказує на те, що ці файли у форматі Protein Data Bank,\n"
"простому текстовому форматі, який визначає тип і положення кожного атома в молекулі."

# code block
#: shell-novice/_episodes/04-pipefilter.md:37
msgid ""
"~~~\n"
"cubane.pdb    methane.pdb    pentane.pdb\n"
"ethane.pdb    octane.pdb     propane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"cubane.pdb    methane.pdb    pentane.pdb\n"
"ethane.pdb    octane.pdb     propane.pdb\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:43
msgid "Let's run an example command:"
msgstr "Запустимо приклад команди:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:45
msgid ""
"~~~\n"
"$ wc cubane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc cubane.pdb\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:50
msgid ""
"~~~\n"
"20  156 1158 cubane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"20  156 1158 cubane.pdb\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:55
msgid ""
"`wc` is the 'word count' command:\n"
"it counts the number of lines, words, and characters in files (from left to right, in that order)."
msgstr ""
"`wc` - команда 'порахуй слова' (англ. 'word count'):\n"
"вона підраховує кількість рядків, слів і символів у файлах (зліва направо, у такому порядку)."

#: shell-novice/_episodes/04-pipefilter.md:58
msgid ""
"If we run the command `wc *.pdb`, the `*` in `*.pdb` matches zero or more characters,\n"
"so the shell turns `*.pdb` into a list of all `.pdb` files in the current directory:"
msgstr ""
"Якщо ми виконаємо команду `wc *.pdb`, то `*` у `*.pdb` збігається з нулем або більшою кількістю символів,\n"
"тож термінал перетворить `*.pdb` на перелік усіх `.pdb`-файлів у поточному каталозі:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:61
msgid ""
"~~~\n"
"$ wc *.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc *.pdb\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:66
msgid ""
"~~~\n"
"  20  156  1158  cubane.pdb\n"
"  12  84   622   ethane.pdb\n"
"   9  57   422   methane.pdb\n"
"  30  246  1828  octane.pdb\n"
"  21  165  1226  pentane.pdb\n"
"  15  111  825   propane.pdb\n"
" 107  819  6081  total\n"
"~~~"
msgstr ""
"~~~\n"
"  20  156  1158  cubane.pdb\n"
"  12  84   622   ethane.pdb\n"
"   9  57   422   methane.pdb\n"
"  30  246  1828  octane.pdb\n"
"  21  165  1226  pentane.pdb\n"
"  15  111  825   propane.pdb\n"
" 107  819  6081  total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:77
msgid ""
"Note that `wc *.pdb` also shows the total number of all lines in the last "
"line of the output."
msgstr ""
"Зверніть увагу, що `wc *.pdb` також показує загальну кількість усіх рядків в"
" останньому рядку виводу."

#: shell-novice/_episodes/04-pipefilter.md:79
msgid ""
"If we run `wc -l` instead of just `wc`,\n"
"the output shows only the number of lines per file:"
msgstr ""
"Якщо ми виконаємо `wc -l` замість просто `wc`,\n"
"у виводі буде показано лише кількість рядків у файлі:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:82
msgid ""
"~~~\n"
"$ wc -l *.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.pdb\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:87
#: shell-novice/_episodes/04-pipefilter.md:166
msgid ""
"~~~\n"
"  20  cubane.pdb\n"
"  12  ethane.pdb\n"
"   9  methane.pdb\n"
"  30  octane.pdb\n"
"  21  pentane.pdb\n"
"  15  propane.pdb\n"
" 107  total\n"
"~~~"
msgstr ""
"~~~\n"
"  20  cubane.pdb\n"
"  12  ethane.pdb\n"
"   9  methane.pdb\n"
"  30  octane.pdb\n"
"  21  pentane.pdb\n"
"  15  propane.pdb\n"
" 107  total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:98
msgid ""
"The `-m` and `-w` options can also be used with the `wc` command, to show\n"
"only the number of characters or the number of words in the files."
msgstr ""
"Параметри `-m` і `-w` також можна використовувати з командою `wc`, щоб показати\n"
"тільки кількість символів або тільки кількість слів у файлах."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:101
msgid "> ## Why Isn't It Doing Anything?"
msgstr "> ## Чому воно нічого не робить?"

#: shell-novice/_episodes/04-pipefilter.md:102
msgid ""
">\n"
"> What happens if a command is supposed to process a file, but we\n"
"> don't give it a filename? For example, what if we type:\n"
">\n"
"> ~~~\n"
"> $ wc -l\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> but don't type `*.pdb` (or anything else) after the command?\n"
"> Since it doesn't have any filenames, `wc` assumes it is supposed to\n"
"> process input given at the command prompt, so it just sits there and waits for us to give\n"
"> it some data interactively. From the outside, though, all we see is it\n"
"> sitting there: the command doesn't appear to do anything.\n"
">\n"
"> If you make this kind of mistake, you can escape out of this state by holding down\n"
"> the control key (<kbd>Ctrl</kbd>) and typing the letter <kbd>C</kbd> once and\n"
"> letting go of the <kbd>Ctrl</kbd> key.\n"
"> <kbd>Ctrl</kbd>+<kbd>C</kbd>"
msgstr ""
">\n"
"> Що станеться, якщо команда має обробити файл, але ми\n"
"> не вкажемо імені файлу? Наприклад, що буде, якщо ми наберемо:\n"
">\n"
"> ~~~\n"
"> $ wc -l\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> але не будемо вводити `*.pdb` (або щось інше) після команди?\n"
"> Оскільки команда не має жодних назв файлів, `wc` вважає, що вона повинна\n"
"> обробляти дані, введені у командному рядку, тож вона просто сидить і чекає, поки ми надамо їй\n"
"> інтерактивно якісь дані. Ззовні, однак, все, що ми бачимо, це те, що вона,\n"
"> здається, нічого не робить.\n"
">\n"
"> Якщо ви припустилися такої помилки, ви можете вийти з цього стану, утримуючи\n"
"> клавішу control (<kbd>Ctrl</kbd>), один раз натиснувши клавішу <kbd>C</kbd>,\n"
"> відпустивши після цього клавішу <kbd>Ctrl</kbd>.\n"
"> <kbd>Ctrl</kbd>+<kbd>C</kbd>"

# header
#: shell-novice/_episodes/04-pipefilter.md:124
msgid "## Capturing output from commands"
msgstr "## Перехоплення виводу з команд"

#: shell-novice/_episodes/04-pipefilter.md:126
msgid ""
"Which of these files contains the fewest lines?\n"
"It's an easy question to answer when there are only six files,\n"
"but what if there were 6000?\n"
"Our first step toward a solution is to run the command:"
msgstr ""
"Який з цих файлів містить найменше рядків?\n"
"На це питання легко відповісти, коли файлів всього шість,\n"
"але що, якщо їх 6000?\n"
"Наш перший крок до пошуку рішеня - це запуск команди:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:131
msgid ""
"~~~\n"
"$ wc -l *.pdb > lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.pdb > lengths.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:136
msgid ""
"The greater than symbol, `>`, tells the shell to **redirect** the command's output\n"
"to a file instead of printing it to the screen. (This is why there is no screen output:\n"
"everything that `wc` would have printed has gone into the\n"
"file `lengths.txt` instead.)  The shell will create\n"
"the file if it doesn't exist. If the file exists, it will be\n"
"silently overwritten, which may lead to data loss and thus requires\n"
"some caution.\n"
"`ls lengths.txt` confirms that the file exists:"
msgstr ""
"Символ 'більше ніж', `>`, вказує терміналу **перенаправити** вивід команди\n"
"до файла замість виведення його на екран. (Саме тому виведення на екран не відбувається:\n"
"все, що мала вивести команда `wc`, було збережено у файлі\n"
"`lengths.txt` замість цього). Термінал створить\n"
"файл, якщо його не існує. Якщо файл існує, його буде\n"
"буде перезаписано без будь-яких повідомлень, що може призвести до втрати даних, а отже, вимагає\n"
"певної обережності.\n"
"Файл `ls lengths.txt` підтверджує, що файл існує:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:145
msgid ""
"~~~\n"
"$ ls lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls lengths.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:150
msgid ""
"~~~\n"
"lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"lengths.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:155
msgid ""
"We can now send the content of `lengths.txt` to the screen using `cat lengths.txt`.\n"
"The `cat` command gets its name from 'concatenate' i.e. join together,\n"
"and it prints the contents of files one after another.\n"
"There's only one file in this case,\n"
"so `cat` just shows us what it contains:"
msgstr ""
"Тепер ми можемо вивести вміст файлу `lengths.txt` на екран за допомогою команди `cat lengths.txt`.\n"
"Команда `cat` отримала свою назву від слова 'concatenate', тобто об'єднувати, \n"
"і вона виводить вміст файлів один за одним.\n"
"У цьому випадку є лише один файл,\n"
"тому `cat` просто відображає нам його вміст:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:161
msgid ""
"~~~\n"
"$ cat lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ cat lengths.txt\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:177
msgid "> ## Output Page by Page"
msgstr "> ## Виведення сторінка за сторінкою"

#: shell-novice/_episodes/04-pipefilter.md:178
msgid ""
">\n"
"> We'll continue to use `cat` in this lesson, for convenience and consistency,\n"
"> but it has the disadvantage that it always dumps the whole file onto your screen.\n"
"> More useful in practice is the command `less`,\n"
"> which you use with `less lengths.txt`.\n"
"> This displays a screenful of the file, and then stops.\n"
"> You can go forward one screenful by pressing the spacebar,\n"
"> or back one by pressing `b`.  Press `q` to quit."
msgstr ""
">\n"
"> У цьому уроці ми продовжимо використовувати команду `cat` для зручності та послідовності,\n"
"> але вона має той недолік, що завжди виводить весь файл на екран.\n"
"> Більш корисною на практиці є команда `less`,\n"
"> яку ви використовуєте за зразком `less lengths.txt`.\n"
"> Вона виводить один екран вмісту файлу, а потім зупиняється.\n"
"> Ви можете пересунутися на один екран вперед, натиснувши клавішу пробіл,\n"
"> або на один екран назад натисканням клавіші `b`. Щоб вийти, натисніть `q`."

# header
#: shell-novice/_episodes/04-pipefilter.md:189
msgid "## Filtering output"
msgstr "## Фільтрування виводу"

#: shell-novice/_episodes/04-pipefilter.md:191
msgid ""
"Next we'll use the `sort` command to sort the contents of the `lengths.txt` file.\n"
"But first we'll use an exercise to learn a little about the sort command:"
msgstr ""
"Далі ми скористаємося командою `sort` для сортування вмісту файлу `lengths.txt`.\n"
"Але спочатку ми виконаємо вправу, щоб дізнатися більше про команду sort:"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:194
msgid "> ## What Does `sort -n` Do?"
msgstr "> ## Що робить `sort -n`?"

#: shell-novice/_episodes/04-pipefilter.md:195
msgid ""
">\n"
"> The file `shell-lesson-data/exercise-data/numbers.txt` contains the following lines:\n"
">\n"
"> ~~~\n"
"> 10\n"
"> 2\n"
"> 19\n"
"> 22\n"
"> 6\n"
"> ~~~"
msgstr ""
">\n"
"> Файл `shell-lesson-data/exercise-data/numbers.txt` містить наступні рядки:\n"
">\n"
"> ~~~\n"
"> 10\n"
"> 2\n"
"> 19\n"
"> 22\n"
"> 6\n"
"> ~~~"

# SC/DC Template label
#: shell-novice/_episodes/04-pipefilter.md:205
#: shell-novice/_episodes/04-pipefilter.md:504
#: shell-novice/_episodes/05-loop.md:438
#: shell-novice/_episodes/06-script.md:304
#: shell-novice/_episodes/07-find.md:324 shell-novice/_episodes/07-find.md:336
msgid "> {: .source}"
msgstr "> {: .source}"

#: shell-novice/_episodes/04-pipefilter.md:206
msgid ""
">\n"
"> If we run `sort` on this file, the output is:\n"
">\n"
"> ~~~\n"
"> 10\n"
"> 19\n"
"> 2\n"
"> 22\n"
"> 6\n"
"> ~~~"
msgstr ""
">\n"
"> Якщо ми виконаємо команду `sort` для цього файлу, то отримаємо наступне:\n"
">\n"
"> ~~~\n"
"> 10\n"
"> 19\n"
"> 2\n"
"> 22\n"
"> 6\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:217
msgid ""
">\n"
"> If we run `sort -n` on the same file, we get this instead:\n"
">\n"
"> ~~~\n"
"> 2\n"
"> 6\n"
"> 10\n"
"> 19\n"
"> 22\n"
"> ~~~"
msgstr ""
">\n"
"> Якщо ми виконаємо команду `sort -n` для того ж файлу, то отримаємо наступне:\n"
">\n"
"> ~~~\n"
"> 2\n"
"> 6\n"
"> 10\n"
"> 19\n"
"> 22\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:228
msgid ""
">\n"
"> Explain why `-n` has this effect.\n"
">\n"
"> > ## Solution\n"
"> > The `-n` option specifies a numerical rather than an alphanumerical sort."
msgstr ""
">\n"
"> Поясніть, чому `-n` має такий ефект.\n"
">\n"
"> > ## Розв'язання\n"
"> > Опція `-n` задає числове, а не алфавітно-цифрове сортування."

#: shell-novice/_episodes/04-pipefilter.md:236
msgid ""
"We will also use the `-n` option to specify that the sort is\n"
"numerical instead of alphanumerical.\n"
"This does *not* change the file;\n"
"instead, it sends the sorted result to the screen:"
msgstr ""
"Ми також будемо використовувати опцію `-n`, щоб вказати, що сортування буде\n"
"числовим, а не алфавітно-цифровим.\n"
"Це *не* змінить файл;\n"
"натомість відсортований результат буде виведено на екран:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:241
msgid ""
"~~~\n"
"$ sort -n lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ sort -n lengths.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:246
msgid ""
"~~~\n"
"  9  methane.pdb\n"
" 12  ethane.pdb\n"
" 15  propane.pdb\n"
" 20  cubane.pdb\n"
" 21  pentane.pdb\n"
" 30  octane.pdb\n"
"107  total\n"
"~~~"
msgstr ""
"~~~\n"
"  9  methane.pdb\n"
" 12  ethane.pdb\n"
" 15  propane.pdb\n"
" 20  cubane.pdb\n"
" 21  pentane.pdb\n"
" 30  octane.pdb\n"
"107  total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:258
msgid ""
"We can put the sorted list of lines in another temporary file called `sorted-lengths.txt`\n"
"by putting `> sorted-lengths.txt` after the command,\n"
"just as we used `> lengths.txt` to put the output of `wc` into `lengths.txt`.\n"
"Once we've done that,\n"
"we can run another command called `head` to get the first few lines in `sorted-lengths.txt`:"
msgstr ""
"Ми можемо помістити відсортований список рядків в інший тимчасовий файл, який називається `sorted-lengths.txt`.\n"
"додавши `> sorted-lengths.txt` після команди,\n"
"так само, як ми використовували `> lengths.txt`, щоб помістити виведення `wc` у `lengths.txt`.\n"
"Після того, як ми це зробили,\n"
"ми можемо виконати іншу команду, що має назву `head`, щоб отримати перші кілька рядків у `sorted-lengths.txt`:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:264
msgid ""
"~~~\n"
"$ sort -n lengths.txt > sorted-lengths.txt\n"
"$ head -n 1 sorted-lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ sort -n lengths.txt > sorted-lengths.txt\n"
"$ head -n 1 sorted-lengths.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:270
#: shell-novice/_episodes/04-pipefilter.md:384
msgid ""
"~~~\n"
"  9  methane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"  9  methane.pdb\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:275
msgid ""
"Using `-n 1` with `head` tells it that\n"
"we only want the first line of the file;\n"
"`-n 20` would get the first 20,\n"
"and so on.\n"
"Since `sorted-lengths.txt` contains the lengths of our files ordered from least to greatest,\n"
"the output of `head` must be the file with the fewest lines."
msgstr ""
"Використання `-n 1` з `head` говорить команді, що\n"
"нам потрібен лише перший рядок файлу;\n"
"`-n 20` отримає перші 20,\n"
"і так далі.\n"
"Оскільки файл `sorted-lengths.txt` містить довжини наших файлів, впорядковані від найменшої до найбільшої,\n"
"виведенням `head` має бути файл з найменшою кількістю рядків."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:282
msgid "> ## Redirecting to the same file"
msgstr "> ## Перенаправлення у той самий файл"

#: shell-novice/_episodes/04-pipefilter.md:283
msgid ""
">\n"
"> It's a very bad idea to try redirecting\n"
"> the output of a command that operates on a file\n"
"> to the same file. For example:\n"
">\n"
"> ~~~\n"
"> $ sort -n lengths.txt > lengths.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Doing something like this may give you\n"
"> incorrect results and/or delete\n"
"> the contents of `lengths.txt`."
msgstr ""
">\n"
"> Це дуже погана ідея - намагатися перенаправити\n"
"> вихідні дані команди, яка оперує з файлом,\n"
"> у той самий файл. Наприклад:\n"
">\n"
"> ~~~\n"
"> $ sort -n lengths.txt > lengths.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Виконання таких дій може надати вам\n"
"> некоректні результати та/або видалити\n"
"> вміст файлу `lengths.txt`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:298
msgid "> ## What Does `>>` Mean?"
msgstr "> ## Що означає `>>`?"

#: shell-novice/_episodes/04-pipefilter.md:299
msgid ""
">\n"
"> We have seen the use of `>`, but there is a similar operator `>>`\n"
"> which works slightly differently.\n"
"> We'll learn about the differences between these two operators by printing some strings.\n"
"> We can use the `echo` command to print strings e.g.\n"
">\n"
"> ~~~\n"
"> $ echo The echo command prints text\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> The echo command prints text\n"
"> ~~~"
msgstr ""
">\n"
"> Ми бачили використання оператору `>`, але існує схожий оператор `>>`,\n"
"> який працює дещо по-іншому.\n"
"> Ми дізнаємося про відмінності між цими двома операторами, надрукувавши кілька рядків.\n"
"> Ми можемо скористатися командою `echo` для виведення рядків, наприклад\n"
">\n"
"> ~~~\n"
"> $ echo Команда echo виводить текст\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> Команда echo виводить текст\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:313
msgid ""
">\n"
"> Now test the commands below to reveal the difference between the two operators:\n"
">\n"
"> ~~~\n"
"> $ echo hello > testfile01.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> and:\n"
">\n"
"> ~~~\n"
"> $ echo hello >> testfile02.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Hint: Try executing each command twice in a row and then examining the output files.\n"
">\n"
"> > ## Solution\n"
"> > In the first example with `>`, the string 'hello' is written to `testfile01.txt`,\n"
"> > but the file gets overwritten each time we run the command.\n"
"> >\n"
"> > We see from the second example that the `>>` operator also writes 'hello' to a file\n"
"> > (in this case`testfile02.txt`),\n"
"> > but appends the string to the file if it already exists\n"
"> > (i.e. when we run it for the second time)."
msgstr ""
">\n"
"> Тепер протестуйте наведені нижче команди, щоб виявити різницю між цими двома операторами:\n"
">\n"
"> ~~~\n"
"> $ echo hello > testfile01.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> та:\n"
">\n"
"> ~~~\n"
"> $ echo hello >> testfile02.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Підказка: Спробуйте виконати кожну команду двічі поспіль, а потім переглянути вихідні файли.\n"
">\n"
"> > ## Розв'язання\n"
"> > У першому прикладі з `>` рядок 'hello' записується до файлу `testfile01.txt`,\n"
"> > але файл перезаписується кожного разу, коли ми запускаємо команду.\n"
"> >\n"
"> > З другого прикладу ми бачимо, що оператор `>>` також записує рядок 'hello' у файл\n"
"> > (у цьому випадку `testfile02.txt`),\n"
"> > але додає рядок до файлу, якщо останній вже існує\n"
"> > (тобто, коли ми запускаємо його вдруге)."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:341
msgid "> ## Appending Data"
msgstr "> ## Додавання даних"

#: shell-novice/_episodes/04-pipefilter.md:342
msgid ""
">\n"
"> We have already met the `head` command, which prints lines from the start of a file.\n"
"> `tail` is similar, but prints lines from the end of a file instead.\n"
">\n"
"> Consider the file `shell-lesson-data/exercise-data/animal-counts/animals.csv`.\n"
"> After these commands, select the answer that\n"
"> corresponds to the file `animals-subset.csv`:\n"
">\n"
"> ~~~\n"
"> $ head -n 3 animals.csv > animals-subset.csv\n"
"> $ tail -n 2 animals.csv >> animals-subset.csv\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. The first three lines of `animals.csv`\n"
"> 2. The last two lines of `animals.csv`\n"
"> 3. The first three lines and the last two lines of `animals.csv`\n"
"> 4. The second and third lines of `animals.csv`\n"
">\n"
"> > ## Solution\n"
"> > Option 3 is correct.\n"
"> > For option 1 to be correct we would only run the `head` command.\n"
"> > For option 2 to be correct we would only run the `tail` command.\n"
"> > For option 4 to be correct we would have to pipe the output of `head` into `tail -n 2`\n"
"> >  by doing `head -n 3 animals.csv | tail -n 2 > animals-subset.csv`"
msgstr ""
">\n"
"> Ми вже зустрічалися з командою `head`, яка друкує рядки з початку файлу.\n"
"> Команда `tail` схожа на неї, але друкує рядки з кінця файлу.\n"
">\n"
"> Розглянемо файл `shell-lesson-data/exercise-data/animal-counts/animals.csv`.\n"
"> Після виконання цих команд виберіть відповідь, яка\n"
"> відповідає файлу `animals-subset.csv`:\n"
">\n"
"> ~~~\n"
"> $ head -n 3 animals.csv > animals-subset.csv\n"
"> $ tail -n 2 animals.csv >> animals-subset.csv\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Перші три рядки файлу `animals.csv'\n"
"> 2. Останні два рядки файлу `animals.csv`.\n"
"> 3. Перші три рядки та останні два рядки файлу `animals.csv`.\n"
"> 4. Другий і третій рядки файлу `animals.csv`.\n"
">\n"
"> > Розв'язання\n"
"> > Варіант 3 є правильним.\n"
"> > Щоб варіант 1 був правильним, потрібно виконати лише команду `head`.\n"
"> > Щоб варіант 2 був правильним, нам слід виконати лише команду `tail`.\n"
"> > Щоб варіант 4 був коректним, нам слід передати вивід команди `head` у команду `tail -n 2`\n"
"> > виконавши `head -n 3 animals.csv | tail -n 2 > animals-subset.csv`."

# header
#: shell-novice/_episodes/04-pipefilter.md:371
msgid "## Passing output to another command"
msgstr "## Передача виводу іншій команді"

#: shell-novice/_episodes/04-pipefilter.md:372
msgid ""
"In our example of finding the file with the fewest lines,\n"
"we are using two intermediate files `lengths.txt` and `sorted-lengths.txt` to store output.\n"
"This is a confusing way to work because\n"
"even once you understand what `wc`, `sort`, and `head` do,\n"
"those intermediate files make it hard to follow what's going on.\n"
"We can make it easier to understand by running `sort` and `head` together:"
msgstr ""
"У нашому прикладі ми шукаємо файл з найменшою кількістю рядків,\n"
"ми використовуємо два проміжні файли `lengths.txt` і `sorted-lengths.txt` для зберігання результатів.\n"
"Це заплутаний спосіб роботи, оскільки\n"
"навіть після того, як ви зрозумієте, що роблять `wc`, `sort` і `head`,\n"
"ці проміжні файли ускладнюють розуміння того, що відбувається.\n"
"Ми можемо полегшити розуміння, запустивши `sort` і `head` разом:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:379
msgid ""
"~~~\n"
"$ sort -n lengths.txt | head -n 1\n"
"~~~"
msgstr ""
"~~~\n"
"$ sort -n lengths.txt | head -n 1\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:389
msgid ""
"The vertical bar, `|`, between the two commands is called a **pipe**.\n"
"It tells the shell that we want to use\n"
"the output of the command on the left\n"
"as the input to the command on the right."
msgstr ""
"Вертикальна риска `|` між двома командами називається  **каналом**.\n"
"Він вказує терміналу, що ми хочемо використовувати\n"
"вивід команди ліворуч\n"
"як вхідні дані для команди праворуч."

#: shell-novice/_episodes/04-pipefilter.md:394
msgid "This has removed the need for the `sorted-lengths.txt` file."
msgstr "Це усунуло необхідність у файлі `sorted-lengths.txt`."

# header
#: shell-novice/_episodes/04-pipefilter.md:396
msgid "## Combining multiple commands"
msgstr "## Поєднання декількох команд"

#: shell-novice/_episodes/04-pipefilter.md:397
msgid ""
"Nothing prevents us from chaining pipes consecutively.\n"
"We can for example send the output of `wc` directly to `sort`,\n"
"and then the resulting output to `head`.\n"
"This removes the need for any intermediate files."
msgstr ""
"Ніщо не заважає нам з'єднувати канали послідовно.\n"
"Ми можемо, наприклад, надсилати вивід `wc` безпосередньо до `sort`,\n"
"а потім отриманий результат - до `head`.\n"
"Це усуває необхідність у будь-яких проміжних файлах."

#: shell-novice/_episodes/04-pipefilter.md:402
msgid "We'll start by using a pipe to send the output of `wc` to `sort`:"
msgstr "Ми почнемо з використання каналу для відправки виводу `wc` до `sort`:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:404
#: shell-novice/_episodes/06-script.md:236
msgid ""
"~~~\n"
"$ wc -l *.pdb | sort -n\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.pdb | sort -n\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:409
msgid ""
"~~~\n"
"   9 methane.pdb\n"
"  12 ethane.pdb\n"
"  15 propane.pdb\n"
"  20 cubane.pdb\n"
"  21 pentane.pdb\n"
"  30 octane.pdb\n"
" 107 total\n"
"~~~"
msgstr ""
"~~~\n"
"   9 methane.pdb\n"
"  12 ethane.pdb\n"
"  15 propane.pdb\n"
"  20 cubane.pdb\n"
"  21 pentane.pdb\n"
"  30 octane.pdb\n"
" 107 total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:420
msgid ""
"We can then send that output through another pipe, to `head`, so that the "
"full pipeline becomes:"
msgstr ""
"Потім ми можемо відправити цей вивід через інший канал в `head`, отже "
"конвеєр стає наступним:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:422
msgid ""
"~~~\n"
"$ wc -l *.pdb | sort -n | head -n 1\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.pdb | sort -n | head -n 1\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:427
msgid ""
"~~~\n"
"   9  methane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"   9  methane.pdb\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:432
msgid ""
"This is exactly like a mathematician nesting functions like *log(3x)*\n"
"and saying 'the log of three times *x*'.\n"
"In our case,\n"
"the calculation is 'head of sort of line count of `*.pdb`'."
msgstr ""
"Це точно так само, як математик вкладає функції на кшталт *log(3x)*\n"
"і каже 'логарифм трьох, помноженого на *x*'.\n"
"У нашому випадку,\n"
"обчислюється 'head від sort від підрахунку кількості рядків у файлах `*.pdb`'."

#: shell-novice/_episodes/04-pipefilter.md:438
msgid ""
"The redirection and pipes used in the last few commands are illustrated "
"below:"
msgstr ""
"Перенаправлення та канали, використані в останніх кількох командах, "
"проілюстровано нижче:"

#: shell-novice/_episodes/04-pipefilter.md:440
msgid ""
"![Redirects and Pipes of different commands: \"wc -l *.pdb\" will direct the\n"
"output to the shell. \"wc -l *.pdb > lengths\" will direct output to the file\n"
"\"lengths\". \"wc -l *.pdb | sort -n | head -n 1\" will build a pipeline where the\n"
"output of the \"wc\" command is the input to the \"sort\" command, the output of\n"
"the \"sort\" command is the input to the \"head\" command and the output of the\n"
"\"head\" command is directed to the shell](../fig/redirects-and-pipes.svg)"
msgstr ""
"![Перенаправлення та канали різних команд: \"wc -l *.pdb\" перенаправить\n"
"виведення до терміналу. \"wc -l *.pdb > lengths\" спрямує вивід до файлу\n"
"\"lengths\". \"wc -l *.pdb | sort -n | head -n 1\" побудує конвеєр, де\n"
"вихід команди \"wc\" є входом для команди \"sort\", вихід команди\n"
"команди \"sort\" є входом для команди \"head\", а вихід команди\n"
"\"head\" буде спрямовано до терміналу](../fig/redirects-and-pipes.svg)"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:447
msgid "> ## Piping Commands Together"
msgstr "> ## З'єднання команд у конвеєр"

#: shell-novice/_episodes/04-pipefilter.md:448
msgid ""
">\n"
"> In our current directory, we want to find the 3 files which have the least number of\n"
"> lines. Which command listed below would work?\n"
">\n"
"> 1. `wc -l * > sort -n > head -n 3`\n"
"> 2. `wc -l * | sort -n | head -n 1-3`\n"
"> 3. `wc -l * | head -n 3 | sort -n`\n"
"> 4. `wc -l * | sort -n | head -n 3`\n"
">\n"
"> > ## Solution\n"
"> > Option 4 is the solution.\n"
"> > The pipe character `|` is used to connect the output from one command to\n"
"> > the input of another.\n"
"> > `>` is used to redirect standard output to a file.\n"
"> > Try it in the `shell-lesson-data/exercise-data/proteins` directory!"
msgstr ""
">\n"
"> У нашому поточному каталозі ми хочемо знайти 3 файли, які мають найменшу кількість\n"
"> рядків. Яка з наведених нижче команд підійде для цього?\n"
">\n"
"> 1. `wc -l * > sort -n > head -n 3`.\n"
"> 2. `wc -l * | sort -n | head -n 1-3`.\n"
"> 3. `wc -l * | head -n 3 | sort -n`\n"
"> 4. `wc -l * | sort -n | head -n 3`.\n"
">\n"
"> > Розв'язання\n"
"> > Варіант 4 є рішенням.\n"
"> > Символ каналу `|` використовується для під'єднання виводу однієї команди\n"
"> > до входу іншої.\n"
"> > Символ `>` використовується для перенаправлення стандартного виводу до файлу.\n"
"> > Спробуйте у каталозі `shell-lesson-data/exercise-data/proteins`!"

# header
#: shell-novice/_episodes/04-pipefilter.md:467
msgid "## Tools designed to work together"
msgstr "## Інструменти, розроблені для спільної роботи"

#: shell-novice/_episodes/04-pipefilter.md:468
msgid ""
"This idea of linking programs together is why Unix has been so successful.\n"
"Instead of creating enormous programs that try to do many different things,\n"
"Unix programmers focus on creating lots of simple tools that each do one job well,\n"
"and that work well with each other.\n"
"This programming model is called 'pipes and filters'.\n"
"We've already seen pipes;\n"
"a **filter** is a program like `wc` or `sort`\n"
"that transforms a stream of input into a stream of output.\n"
"Almost all of the standard Unix tools can work this way:\n"
"unless told to do otherwise,\n"
"they read from standard input,\n"
"do something with what they've read,\n"
"and write to standard output."
msgstr ""
"Ця ідея зв'язування програм разом є причиною успіху Unix.\n"
"Замість того, щоб створювати величезні програми, які намагаються робити багато різних речей,\n"
"програмісти Unix зосереджуються на створенні великої кількості простих інструментів, кожен з яких добре виконує одну роботу,\n"
"і які добре працюють один з іншим.\n"
"Ця модель програмування називається \"канали та фільтри\".\n"
"Ми вже бачили канали;\n"
"а **фільтр** - це програма на кшталт `wc` або `sort`.\n"
"яка перетворює потік вхідних даних у потік вихідних даних.\n"
"Майже всі стандартні інструменти Unix можуть працювати таким чином:\n"
"якщо їм не наказано робити інакше,\n"
"вони читають зі стандартного вводу,\n"
"роблять щось з прочитаним,\n"
"і записують у стандартний вивід."

#: shell-novice/_episodes/04-pipefilter.md:482
msgid ""
"The key is that any program that reads lines of text from standard input\n"
"and writes lines of text to standard output\n"
"can be combined with every other program that behaves this way as well.\n"
"You can *and should* write your programs this way\n"
"so that you and other people can put those programs into pipes to multiply their power."
msgstr ""
"Ключовим моментом є те, що будь-яка програма, яка зчитує рядки тексту зі стандартного вводу\n"
"і записує рядки тексту у стандартний вивід,\n"
"може бути об'єднана з будь-якою іншою програмою, яка поводиться так само.\n"
"Ви можете *і повинні* писати свої програми у такий спосіб,\n"
"щоб ви та інші люди могли об'єднати ці програми у канали, щоб примножити їхню потужність."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:489
msgid "> ## Pipe Reading Comprehension"
msgstr "> ## Розуміння читання каналу"

#: shell-novice/_episodes/04-pipefilter.md:490
msgid ""
">\n"
"> A file called `animals.csv` (in the `shell-lesson-data/exercise-data/animal-counts` folder)\n"
"> contains the following data:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> 2012-11-06,deer,2\n"
"> 2012-11-06,fox,4\n"
"> 2012-11-07,rabbit,16\n"
"> 2012-11-07,bear,1\n"
"> ~~~"
msgstr ""
">\n"
"> Файл з назвою `animals.csv` (у папці `shell-lesson-data/exercise-data/animal-counts`)\n"
"> містить наступні дані:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> 2012-11-06,deer,2\n"
"> 2012-11-06,fox,4\n"
"> 2012-11-07,rabbit,16\n"
"> 2012-11-07,bear,1\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:505
msgid ""
">\n"
"> What text passes through each of the pipes and the final redirect in the pipeline below?\n"
"> Note, the `sort -r` command sorts in reverse order.\n"
">\n"
"> ~~~\n"
"> $ cat animals.csv | head -n 5 | tail -n 3 | sort -r > final.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> Hint: build the pipeline up one command at a time to test your understanding\n"
"> > ## Solution\n"
"> > The `head` command extracts the first 5 lines from `animals.csv`.\n"
"> > Then, the last 3 lines are extracted from the previous 5 by using the `tail` command.\n"
"> > With the `sort -r` command those 3 lines are sorted in reverse order and finally,\n"
"> > the output is redirected to a file `final.txt`.\n"
"> > The content of this file can be checked by executing `cat final.txt`.\n"
"> > The file should contain the following lines:\n"
"> > ```\n"
"> > 2012-11-06,rabbit,19\n"
"> > 2012-11-06,deer,2\n"
"> > 2012-11-05,raccoon,7\n"
"> > ```\n"
"> > {: .source}"
msgstr ""
">\n"
"> Який текст проходить через кожен з каналів і кінцеве перенаправлення у конвеєрі нижче?\n"
"> Зауважте, що команда `sort -r` сортує у зворотному порядку.\n"
">\n"
"> ~~~\n"
"> $ cat animals.csv | head -n 5 | tail -n 3 | sort -r > final.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> Підказка: створюйте конвеєр по одній команді за раз, щоб перевірити своє розуміння\n"
"> > ## Розв'язання\n"
"> > Команда `head` витягує перші 5 рядків з файлу `animals.csv`.\n"
"> > Потім останні 3 рядки витягуються з попередніх 5 за допомогою команди `tail`.\n"
"> > За допомогою команди `sort -r` ці 3 рядки сортуються у зворотному порядку і нарешті,\n"
"> > виведення перенаправляється до файлу `final.txt`.\n"
"> > Вміст цього файлу можна перевірити, виконавши команду `cat final.txt`.\n"
"> > Файл повинен містити наступні рядки:\n"
"> > ```\n"
"> > 2012-11-06,rabbit,19\n"
"> > 2012-11-06,олень,2\n"
"> > 2012-11-05,єнот,7\n"
"> > ```\n"
"> > {: .source}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:530
msgid "> ## Pipe Construction"
msgstr "> ## Конструювання каналу"

#: shell-novice/_episodes/04-pipefilter.md:531
msgid ""
">\n"
"> For the file `animals.csv` from the previous exercise, consider the following command:\n"
">\n"
"> ~~~\n"
"> $ cut -d , -f 2 animals.csv\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> The `cut` command is used to remove or 'cut out' certain sections of each line in the file,\n"
"> and `cut` expects the lines to be separated into columns by a <kbd>Tab</kbd> character.\n"
"> A character used in this way is a called a **delimiter**.\n"
"> In the example above we use the `-d` option to specify the comma as our delimiter character.\n"
"> We have also used the `-f` option to specify that we want to extract the second field (column).\n"
"> This gives the following output:\n"
">\n"
"> ~~~\n"
"> deer\n"
"> rabbit\n"
"> raccoon\n"
"> rabbit\n"
"> deer\n"
"> fox\n"
"> rabbit\n"
"> bear\n"
"> ~~~"
msgstr ""
">\n"
"> Для файлу `animals.csv` з попередньої завдання розглянемо наступну команду:>\n"
"> ~~~\n"
"> $ cut -d , -f 2 animals.csv\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Команда `cut` використовується для видалення або 'вирізання' певних частин кожного рядка у файлі,\n"
"> і `cut` очікує, що рядки буде розділено на стовпчики символом <kbd>Tab</kbd>.\n"
"> Символ, який використовується таким чином, називається **відокремлювальним символом**.\n"
"> У наведеному вище прикладі ми використовуємо опцію `-d`, щоб вказати кому як відокремлювальний символ.\n"
"> Ми також використали опцію `-f`, щоб вказати, що ми хочемо вилучити друге поле (стовпчик).\n"
"> Це призведе до наступного результату:\n"
">\n"
"> ~~~\n"
"> deer\n"
"> rabbit\n"
"> raccoon\n"
"> rabbit\n"
"> deer\n"
"> fox\n"
"> rabbit\n"
"> bear\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:557
msgid ""
">\n"
"> The `uniq` command filters out adjacent matching lines in a file.\n"
"> How could you extend this pipeline (using `uniq` and another command) to find\n"
"> out what animals the file contains (without any duplicates in their\n"
"> names)?\n"
">\n"
"> > ## Solution\n"
"> > ```\n"
"> > $ cut -d , -f 2 animals.csv | sort | uniq\n"
"> > ```\n"
"> > {: .language-bash}"
msgstr ""
">\n"
"> Команда `uniq` відфільтровує сусідні однакові рядки у файлі.\n"
"> Як можна розширити цей конвеєр (за допомогою `uniq` та іншої команди), щоб\n"
"> з'ясувати, які тварини містяться у файлі (без повторень у їхніх\n"
"> назвах)?\n"
">\n"
"> > ## Розв'язання\n"
"> > ```\n"
"> > $ cut -d , -f 2 animals.csv | sort | uniq\n"
"> > ```\n"
"> > {: .language-bash}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:571
msgid "> ## Which Pipe?"
msgstr "> ## Який канал?"

#: shell-novice/_episodes/04-pipefilter.md:572
msgid ""
">\n"
"> The file `animals.csv` contains 8 lines of data formatted as follows:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> ...\n"
"> ~~~"
msgstr ""
">\n"
"> Файл `animals.csv` містить 8 рядків даних, відформатованих наступним чином:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> ...\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:583
msgid ""
">\n"
"> The `uniq` command has a `-c` option which gives a count of the\n"
"> number of times a line occurs in its input.  Assuming your current\n"
"> directory is `shell-lesson-data/exercise-data/animal-counts`,\n"
"> what command would you use to produce a table that shows\n"
"> the total count of each type of animal in the file?\n"
">\n"
"> 1.  `sort animals.csv | uniq -c`\n"
"> 2.  `sort -t, -k2,2 animals.csv | uniq -c`\n"
"> 3.  `cut -d, -f 2 animals.csv | uniq -c`\n"
"> 4.  `cut -d, -f 2 animals.csv | sort | uniq -c`\n"
"> 5.  `cut -d, -f 2 animals.csv | sort | uniq -c | wc -l`\n"
">\n"
"> > ## Solution\n"
"> > Option 4. is the correct answer.\n"
"> > If you have difficulty understanding why, try running the commands, or sub-sections of\n"
"> > the pipelines (make sure you are in the `shell-lesson-data/exercise-data/animal-counts`\n"
"> > directory)."
msgstr ""
">\n"
"> Команда `uniq` має опцію `-c`, яка дає\n"
"> кількість входжень рядка у вхідних даних. Припустимо, що ваш поточний\n"
"> каталог має назву `shell-lesson-data/exercise-data/animal-counts`,\n"
"> яку команду слід використати, щоб створити таблицю, яка показує\n"
"> загальну кількість тварин кожного типу у файлі?\n"
">\n"
"> 1. `sort animals.csv | uniq -c`.\n"
"> 2. `sort -t, -k2,2 animals.csv | uniq -c`.\n"
"> 3. `cut -d, -f 2 animals.csv | uniq -c`\n"
"> 4. `cut -d, -f 2 animals.csv | sort | uniq -c`.\n"
"> 5. `cut -d, -f 2 animals.csv | sort | uniq -c | wc -l`\n"
">\n"
"> > ## Розв'язання\n"
"> > Варіант 4 є правильною відповіддю.\n"
"> > Якщо вам важко зрозуміти, чому, спробуйте виконати команди або фрагменти\n"
"> > конвеєрів (переконайтеся, що ви перебуваєте у каталозі `shell-lesson-data/exercise-data/animal-counts`)."

# header
#: shell-novice/_episodes/04-pipefilter.md:604
msgid "## Nelle's Pipeline: Checking Files"
msgstr "### Конвеєр Неллі: Перевірка файлів"

#: shell-novice/_episodes/04-pipefilter.md:606
msgid ""
"Nelle has run her samples through the assay machines\n"
"and created 17 files in the `north-pacific-gyre` directory described earlier.\n"
"As a quick check, starting from the `shell-lesson-data` directory, Nelle types:"
msgstr ""
"Неллі пропустила свої зразки через аналізатори\n"
"і створила 17 файлів у каталозі `north-pacific-gyre`, описаному раніше.\n"
"Для швидкої перевірки, починаючи з каталогу `shell-lesson-data`, Неллі набирає:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:610
msgid ""
"~~~\n"
"$ cd north-pacific-gyre\n"
"$ wc -l *.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd north-pacific-gyre\n"
"$ wc -l *.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:616
msgid "The output is 18 lines that look like this:"
msgstr "На виході вона отримує 18 рядків, які виглядають наступним чином:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:618
msgid ""
"~~~\n"
"300 NENE01729A.txt\n"
"300 NENE01729B.txt\n"
"300 NENE01736A.txt\n"
"300 NENE01751A.txt\n"
"300 NENE01751B.txt\n"
"300 NENE01812A.txt\n"
"... ...\n"
"~~~"
msgstr ""
"~~~\n"
"300 NENE01729A.txt\n"
"300 NENE01729B.txt\n"
"300 NENE01736A.txt\n"
"300 NENE01751A.txt\n"
"300 NENE01751B.txt\n"
"300 NENE01812A.txt\n"
"... ...\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:629
msgid "Now she types this:"
msgstr "Тепер вона набирає наступне:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:631
msgid ""
"~~~\n"
"$ wc -l *.txt | sort -n | head -n 5\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.txt | sort -n | head -n 5\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:636
msgid ""
"~~~\n"
" 240 NENE02018B.txt\n"
" 300 NENE01729A.txt\n"
" 300 NENE01729B.txt\n"
" 300 NENE01736A.txt\n"
" 300 NENE01751A.txt\n"
"~~~"
msgstr ""
"~~~\n"
" 240 NENE02018B.txt\n"
" 300 NENE01729A.txt\n"
" 300 NENE01729B.txt\n"
" 300 NENE01736A.txt\n"
" 300 NENE01751A.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:645
msgid ""
"Whoops: one of the files is 60 lines shorter than the others.\n"
"When she goes back and checks it,\n"
"she sees that she did that assay at 8:00 on a Monday morning --- someone\n"
"was probably in using the machine on the weekend,\n"
"and she forgot to reset it.\n"
"Before re-running that sample,\n"
"she checks to see if any files have too much data:"
msgstr ""
"Упс: один з файлів на 60 рядків коротший за інші.\n"
"Коли вона повертається і перевіряє його,\n"
"вона бачить, що зробила цей аналіз о 8:00 ранку в понеділок --- хтось,\n"
"можливо, користувався машиною на вихідних,\n"
"і вона забула її перезавантажити.\n"
"Перед тим, як повторно проаналізувати цей зразок,\n"
"вона перевіряє, чи є файли, що містять забагато даних:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:653
msgid ""
"~~~\n"
"$ wc -l *.txt | sort -n | tail -n 5\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.txt | sort -n | tail -n 5\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:658
msgid ""
"~~~\n"
" 300 NENE02040B.txt\n"
" 300 NENE02040Z.txt\n"
" 300 NENE02043A.txt\n"
" 300 NENE02043B.txt\n"
"5040 total\n"
"~~~"
msgstr ""
"~~~\n"
" 300 NENE02040B.txt\n"
" 300 NENE02040Z.txt\n"
" 300 NENE02043A.txt\n"
" 300 NENE02043B.txt\n"
"5040 total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:667
msgid ""
"Those numbers look good --- but what's that 'Z' doing there in the third-to-last line?\n"
"All of her samples should be marked 'A' or 'B';\n"
"by convention,\n"
"her lab uses 'Z' to indicate samples with missing information.\n"
"To find others like it, she does this:"
msgstr ""
"Ці цифри виглядають добре --- але що робить ця 'Z' у передостанньому рядку?\n"
"Всі її зразки мають бути позначені 'A' або 'B';\n"
"за попередньою домовленістю\n"
"її лабораторія використовує 'Z' для позначення зразків з недостатньою інформацією.\n"
"Щоб знайти подібні зразки, вона робить наступне:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:673
msgid ""
"~~~\n"
"$ ls *Z.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls *Z.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:678
msgid ""
"~~~\n"
"NENE01971Z.txt    NENE02040Z.txt\n"
"~~~"
msgstr ""
"~~~\n"
"NENE01971Z.txt    NENE02040Z.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:683
msgid ""
"Sure enough,\n"
"when she checks the log on her laptop,\n"
"there's no depth recorded for either of those samples.\n"
"Since it's too late to get the information any other way,\n"
"she must exclude those two files from her analysis.\n"
"She could delete them using `rm`,\n"
"but there are actually some analyses she might do later where depth doesn't matter,\n"
"so instead, she'll have to be careful later on to select files using the wildcard expressions\n"
"`NENE*A.txt NENE*B.txt`."
msgstr ""
"Звісно,\n"
"коли вона перевіряє журнал на своєму ноутбуці,\n"
"глибина не записана для жодного з цих зразків.\n"
"Оскільки вже занадто пізно отримати інформацію в інший спосіб,\n"
"вона повинна виключити ці два файли з аналізу.\n"
"Вона може видалити їх за допомогою `rm`,\n"
"але насправді є деякі аналізи, які вона може зробити пізніше, де глибина не має значення,\n"
"тож натомість, пізніше їй доведеться бути обережною і вибирати файли за допомогою підстановочних виразів\n"
"`NENE*A.txt NENE*B.txt`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:694
msgid "> ## Removing Unneeded Files"
msgstr "> ## Видалення непотрібних файлів"

#: shell-novice/_episodes/04-pipefilter.md:695
msgid ""
">\n"
"> Suppose you want to delete your processed data files, and only keep\n"
"> your raw files and processing script to save storage.\n"
"> The raw files end in `.dat` and the processed files end in `.txt`.\n"
"> Which of the following would remove all the processed data files,\n"
"> and *only* the processed data files?\n"
">\n"
"> 1. `rm ?.txt`\n"
"> 2. `rm *.txt`\n"
"> 3. `rm * .txt`\n"
"> 4. `rm *.*`\n"
">\n"
"> > ## Solution\n"
"> > 1. This would remove `.txt` files with one-character names\n"
"> > 2. This is the correct answer\n"
"> > 3. The shell would expand `*` to match everything in the current directory,\n"
"> > so the command would try to remove all matched files and an additional\n"
"> > file called `.txt`\n"
"> > 4. The shell would expand `*.*` to match all files with any extension,\n"
"> > so this command would delete all files"
msgstr ""
">\n"
"> Припустимо, ви хочете видалити файли оброблених даних і зберегти лише\n"
"> сирі файли і скрипт обробки для економії місця у сховищі.\n"
"> Вихідні файли закінчуються на `.dat`, а оброблені файли закінчуються на `.txt`.\n"
"> Яка з наведених нижче команд видалить усі оброблені файли даних,\n"
"> і *лише* оброблені файли даних?\n"
">\n"
"> 1. `rm ?.txt`\n"
"> 2. `rm *.txt`\n"
"> 3. `rm * .txt`\n"
"> 4. `rm *.*`\n"
">\n"
"> > Розв'язання\n"
"> > 1. Це призведе до вилучення файлів `.txt` з односимвольними назвами\n"
"> > 2. Це правильна відповідь\n"
"> > 3. Термінал розширить підстановочний символ `*` так, щоб він відповідав усім файлам у поточному каталозі,\n"
"> > таким чином, команда спробує видалити всі знайдені файли і додатковий\n"
"> > файл з назвою `.txt'.\n"
"> > 4. Термінал розширить `*.*`, щоб знайти всі файли з будь-яким розширенням,\n"
"> > таким чином, ця команда видалить усі файли."

# Front Matter
#: shell-novice/_episodes/05-loop.md:1
msgid ""
"---\n"
"title: \"Loops\"\n"
"teaching: 40\n"
"exercises: 10\n"
"questions:\n"
"- \"How can I perform the same actions on many different files?\"\n"
"objectives:\n"
"- \"Write a loop that applies one or more commands separately to each file in a set of files.\"\n"
"- \"Trace the values taken on by a loop variable during execution of the loop.\"\n"
"- \"Explain the difference between a variable's name and its value.\"\n"
"- \"Explain why spaces and some punctuation characters shouldn't be used in file names.\"\n"
"- \"Demonstrate how to see what commands have recently been executed.\"\n"
"- \"Re-run recently executed commands without retyping them.\"\n"
"keypoints:\n"
"- \"A `for` loop repeats commands once for every thing in a list.\"\n"
"- \"Every `for` loop needs a variable to refer to the thing it is currently operating on.\"\n"
"- \"Use `$name` to expand a variable (i.e., get its value). `${name}` can also be used.\"\n"
"- \"Do not use spaces, quotes, or wildcard characters such as '*' or '?' in filenames, as it complicates variable expansion.\"\n"
"- \"Give files consistent names that are easy to match with wildcard patterns to make it easy to select them for looping.\"\n"
"- \"Use the up-arrow key to scroll up through previous commands to edit and repeat them.\"\n"
"- \"Use <kbd>Ctrl</kbd>+<kbd>R</kbd> to search through the previously entered commands.\"\n"
"- \"Use `history` to display recent commands, and `![number]` to repeat a command by number.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Цикли\"\n"
"teaching: 40\n"
"exercises: 10\n"
"questions:\n"
"- \"Як виконати одні й ті ж дії над різними файлами?\"\n"
"objectives:\n"
"- \"Написати цикл, який застосовує одну або декілька команд окремо до кожного файлу в наборі файлів\".\n"
"- \"Простежити, яких значень набуває змінна циклу під час виконання циклу\".\n"
"- \"Пояснити різницю між ім'ям змінної та її значенням\".\n"
"- \"Пояснити, чому в іменах файлів не можна використовувати пробіли та деякі розділові знаки\".\n"
"- \"Продемонструвати, як побачити, які команди були виконані останнім часом\".\n"
"- \"Повторно запустити нещодавно виконані команди без повторного введення\".\n"
"keypoints:\n"
"- \"Цикл `for` повторює команди один раз для кожного елемента списку.\"\n"
"- \"Кожному циклу `for` потрібна змінна для посилання на об'єкт, над яким він зараз працює.\"\n"
"- \"Використовуйте `$name` для розкриття змінної (тобто отримання її значення). Також можна використовувати `${name}`.\"\n"
"- \"Не використовуйте у назвах файлів пробіли, лапки або символи підстановки, такі як '*' або '?', оскільки це ускладнює розширення змінних.\"\n"
"- \"Надавайте файлам однакові імена, які легко співпадають із шаблонами підстановок, щоб полегшити їх вибір для циклів\".\n"
"- \"Використовуйте клавішу зі стрілкою вгору для прокрутки попередніх команд, щоб редагувати та повторювати їх.\"\n"
"- \"Використовуйте <kbd>Ctrl</kbd>+<kbd>R</kbd> для пошуку попередньо введених команд.\"\n"
"- \"Використовуйте `history` для відображення останніх команд і `![номер]` для повторення команди за номером.\"\n"
"---"

#: shell-novice/_episodes/05-loop.md:25
msgid ""
"**Loops** are a programming construct which allow us to repeat a command or set of commands\n"
"for each item in a list.\n"
"As such they are key to productivity improvements through automation.\n"
"Similar to wildcards and tab completion, using loops also reduces the\n"
"amount of typing required (and hence reduces the number of typing mistakes)."
msgstr ""
"**Цикли** - це конструкція програмування, яка дозволяє повторювати команду або набір команд\n"
"для кожного елемента у списку.\n"
"Таким чином, вони є ключем до підвищення продуктивності за рахунок автоматизації.\n"
"Подібно до підстановочних символів і завершення клавішею табуляції, використання циклів також зменшує\n"
"кількість необхідного набору тексту (а отже, зменшує кількість помилок)."

#: shell-novice/_episodes/05-loop.md:31
msgid ""
"Suppose we have several hundred genome data files named `basilisk.dat`, `minotaur.dat`, and\n"
"`unicorn.dat`.\n"
"For this example, we'll use the `exercise-data/creatures` directory which only has three\n"
"example files,\n"
"but the principles can be applied to many many more files at once."
msgstr ""
"Припустимо, у нас є кілька сотень файлів геномних даних з іменами `basilisk.dat`, `minotaur.dat` та\n"
"`unicorn.dat`.\n"
"Для цього прикладу ми використаємо каталог `exercise-data/creatures`, який містить лише три\n"
"файли з прикладами,\n"
"але ці принципи можна застосувати до набагато більшої кількості файлів одночасно."

#: shell-novice/_episodes/05-loop.md:37
msgid ""
"The structure of these files is the same: the common name, classification, and updated date are\n"
"presented on the first three lines, with DNA sequences on the following lines.\n"
"Let's look at the files:"
msgstr ""
"Структура цих файлів однакова: загальна назва, класифікація та дата оновлення\n"
"у перших трьох рядках, а в наступних - послідовності ДНК.\n"
"Давайте подивимось на файли:"

# code block
#: shell-novice/_episodes/05-loop.md:41
msgid ""
"```\n"
"$ head -n 5 basilisk.dat minotaur.dat unicorn.dat\n"
"```"
msgstr ""
"```\n"
"$ head -n 5 basilisk.dat minotaur.dat unicorn.dat\n"
"```"

#: shell-novice/_episodes/05-loop.md:46
msgid ""
"We would like to print out the classification for each species, which is given on the second\n"
"line of each file.\n"
"For each file, we would need to execute the command `head -n 2` and pipe this to `tail -n 1`.\n"
"We’ll use a loop to solve this problem, but first let’s look at the general form of a loop,\n"
"using the pseudo-code below:"
msgstr ""
"Ми хотіли б роздрукувати класифікацію для кожного виду, яка наведена у другому\n"
"рядку кожного файлу.\n"
"Для кожного файлу нам потрібно виконати команду `head -n 2` і з'єднати її каналом з командою `tail -n 1`.\n"
"Для вирішення цієї задачі ми скористаємося циклом, але спочатку розглянемо загальну форму циклу,\n"
"використовуючи псевдокод нижче:"

# code block
#: shell-novice/_episodes/05-loop.md:52
msgid ""
"```\n"
"for thing in list_of_things\n"
"do\n"
"    operation_using $thing    # Indentation within the loop is not required, but aids legibility\n"
"done\n"
"```"
msgstr ""
"```\n"
"for thing in list_of_things\n"
"do\n"
"    operation_using $thing    # Відступ усередині циклу не є обов'язковим, але полегшує читабельність\n"
"done\n"
"```"

#: shell-novice/_episodes/05-loop.md:60
msgid "and we can apply this to our example like this:"
msgstr "і ми можемо застосувати це до нашого прикладу наступним чином:"

# code block
#: shell-novice/_episodes/05-loop.md:62
msgid ""
"```\n"
"$ for filename in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $filename | tail -n 1\n"
"> done\n"
"```"
msgstr ""
"```\n"
"$ for filename in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $filename | tail -n 1\n"
"> done\n"
"```"

# code block
#: shell-novice/_episodes/05-loop.md:70
msgid ""
"```\n"
"CLASSIFICATION: basiliscus vulgaris\n"
"CLASSIFICATION: bos hominus\n"
"CLASSIFICATION: equus monoceros\n"
"```"
msgstr ""
"```\n"
"CLASSIFICATION: basiliscus vulgaris\n"
"CLASSIFICATION: bos hominus\n"
"CLASSIFICATION: equus monoceros\n"
"```"

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:78
msgid "> ## Follow the Prompt"
msgstr "> ## Слідкуйте за підказкою"

#: shell-novice/_episodes/05-loop.md:79
msgid ""
">\n"
"> The shell prompt changes from `$` to `>` and back again as we were\n"
"> typing in our loop. The second prompt, `>`, is different to remind\n"
"> us that we haven't finished typing a complete command yet. A semicolon, `;`,\n"
"> can be used to separate two commands written on a single line."
msgstr ""
">\n"
"> Запрошення до введення в терміналі змінюється з `$` на `>` і назад, коли ми\n"
"> вводили команди всередині нашого циклу. Друге запрошення до введення, `>`, відрізняється, щоб нагадати\n"
"> нам, що ми ще не закінчили введення повної команди. Крапка з комою `;`\n"
"> використовується для розділення двох команд, написаних в одному рядку."

#: shell-novice/_episodes/05-loop.md:86
msgid ""
"When the shell sees the keyword `for`,\n"
"it knows to repeat a command (or group of commands) once for each item in a list.\n"
"Each time the loop runs (called an iteration), an item in the list is assigned in sequence to\n"
"the **variable**, and the commands inside the loop are executed, before moving on to\n"
"the next item in the list.\n"
"Inside the loop,\n"
"we call for the variable's value by putting `$` in front of it.\n"
"The `$` tells the shell interpreter to treat\n"
"the variable as a variable name and substitute its value in its place,\n"
"rather than treat it as text or an external command."
msgstr ""
"Коли термінал бачить ключове слово `for`,\n"
"він знає, що потрібно повторити команду (або групу команд) один раз для кожного елемента списку.\n"
"Кожного разу, коли вміст циклу виконується (одне виконання команд всередині циклу називається ітерацією), елемент списку послідовно присвоюється\n"
"**змінній**, і команди всередині циклу виконуються, перш ніж перейти\n"
"до наступного елементу списку.\n"
"Усередині циклу\n"
"ми звертаємося до значення змінної, ставлячи `$` перед ї іменем.\n"
"Символ `$` вказує інтерпретатору командного рядка розглядати\n"
"змінну як ім'я змінної і підставити замість неї її значення,\n"
"замість того, щоб розглядати її як текст або зовнішню команду."

#: shell-novice/_episodes/05-loop.md:97
msgid ""
"In this example, the list is three filenames: `basilisk.dat`, `minotaur.dat`, and `unicorn.dat`.\n"
"Each time the loop iterates, it will assign a file name to the variable `filename`\n"
"and run the `head` command.\n"
"The first time through the loop,\n"
"`$filename` is `basilisk.dat`.\n"
"The interpreter runs the command `head` on `basilisk.dat`\n"
"and pipes the first two lines to the `tail` command,\n"
"which then prints the second line of `basilisk.dat`.\n"
"For the second iteration, `$filename` becomes\n"
"`minotaur.dat`. This time, the shell runs `head` on `minotaur.dat`\n"
"and pipes the first two lines to the `tail` command,\n"
"which then prints the second line of `minotaur.dat`.\n"
"For the third iteration, `$filename` becomes\n"
"`unicorn.dat`, so the shell runs the `head` command on that file,\n"
"and `tail` on the output of that.\n"
"Since the list was only three items, the shell exits the `for` loop."
msgstr ""
"У цьому прикладі список складається з трьох файлів: `basilisk.dat`, `minotaur.dat` та `unicorn.dat`.\n"
"Кожного разу, коли виконанується цикл, він присвоює чергове ім'я файлу змінній `filename`\n"
"і виконає команду `head`.\n"
"При першому проходженні циклу\n"
"`$filename` дорівнює `basilisk.dat`.\n"
"Інтерпретатор виконує команду `head` на `basilisk.dat`\n"
"і передає перші два рядки команді `tail`,\n"
"яка виводить другий рядок файлу `basilisk.dat`.\n"
"Для другої ітерації `$filename` стає\n"
"`minotaur.dat`. Цього разу термінал виконує команду `head` на `minotaur.dat`\n"
"і передає перші два рядки команді `tail`,\n"
"яка виводить другий рядок `minotaur.dat`.\n"
"На третій ітерації `$filename` стає\n"
"`unicorn.dat`, тому термінал виконує команду `head` для цього файлу,\n"
"і `tail` на виході цього.\n"
"Оскільки у списку було лише три елементи, термінал вийде з циклу `for`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:114
msgid "> ## Same Symbols, Different Meanings"
msgstr "> ## Однакові символи, різні значення"

#: shell-novice/_episodes/05-loop.md:115
msgid ""
">\n"
"> Here we see `>` being used as a shell prompt, whereas `>` is also\n"
"> used to redirect output.\n"
"> Similarly, `$` is used as a shell prompt, but, as we saw earlier,\n"
"> it is also used to ask the shell to get the value of a variable.\n"
">\n"
"> If the *shell* prints `>` or `$` then it expects you to type something,\n"
"> and the symbol is a prompt.\n"
">\n"
"> If *you* type `>` or `$` yourself, it is an instruction from you that\n"
"> the shell should redirect output or get the value of a variable."
msgstr ""
">\n"
"> Тут ми бачимо, що символ `>` використовується як запрошення командного рядка, тоді як `>` також\n"
"> використовується для перенаправлення виводу.\n"
"> Аналогічно, символ `$` використовується як запрошення до командного рядка, але, як ми бачили раніше,\n"
"> він також використовується для запиту до оболонки про значення змінної.\n"
">\n"
"> Якщо *термінал* виводить `>` або `$`, то він очікує, що ви щось введете,\n"
"> і цей символ є підказкою.\n"
">\n"
"> Якщо *ви* вводите `>` або `$` самостійно, це є вашою вказівкою про те, що\n"
"> оболонці перенаправити вивід або отримати значення змінної."

#: shell-novice/_episodes/05-loop.md:128
msgid ""
"When using variables it is also\n"
"possible to put the names into curly braces to clearly delimit the variable\n"
"name: `$filename` is equivalent to `${filename}`, but is different from\n"
"`${file}name`. You may find this notation in other people's programs."
msgstr ""
"При використанні змінних також\n"
"можна брати імена у фігурні дужки, щоб чітко розмежувати імена змінних:\n"
"`$filename` еквівалентно `${filename}`, але відрізняється від\n"
"`${file}name`. Ви можете зустріти таку форму запису у програмах інших людей."

#: shell-novice/_episodes/05-loop.md:133
msgid ""
"We have called the variable in this loop `filename`\n"
"in order to make its purpose clearer to human readers.\n"
"The shell itself doesn't care what the variable is called;\n"
"if we wrote this loop as:"
msgstr ""
"Ми назвали змінну у цьому циклі `filename` (ім'я файлу)\n"
"для того, щоб зробити її призначення більш зрозумілим для читачів-людей.\n"
"Самій оболонці байдуже, як називається змінна;\n"
"якщо ми напишемо цей цикл наступним чином:"

# code block
#: shell-novice/_episodes/05-loop.md:138
msgid ""
"~~~\n"
"$ for x in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $x | tail -n 1\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for x in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $x | tail -n 1\n"
"> done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:146
msgid "or:"
msgstr "чи:"

# code block
#: shell-novice/_episodes/05-loop.md:148
msgid ""
"~~~\n"
"$ for temperature in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $temperature | tail -n 1\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for temperature in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $temperature | tail -n 1\n"
"> done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:156
msgid ""
"it would work exactly the same way.\n"
"*Don't do this.*\n"
"Programs are only useful if people can understand them,\n"
"so meaningless names (like `x`) or misleading names (like `temperature`)\n"
"increase the odds that the program won't do what its readers think it does."
msgstr ""
"це спрацювало б точно так само.\n"
"*Не роби цього.*\n"
"Програми корисні лише тоді, коли люди можуть їх розуміти,\n"
"тому беззмістовні назви (наприклад, `x`) або назви, що вводять в оману (наприклад, `temperature`)\n"
"збільшують ймовірність того, що програма не буде робити те, що читачі думають, що вона робить."

#: shell-novice/_episodes/05-loop.md:162
msgid ""
"In the above examples, the variables (`thing`, `filename`, `x` and `temperature`)\n"
"could have been given any other name, as long as it is meaningful to both the person\n"
"writing the code and the person reading it."
msgstr ""
"У наведених вище прикладах змінним (`thing`, `filename`, `x` та `temperature`)\n"
"можна було б назвати будь-якою іншою назвою, аби вона була зрозумілою як для того,\n"
"хто пише код, так і для того, хто його читає."

#: shell-novice/_episodes/05-loop.md:166
msgid ""
"Note also that loops can be used for other things than filenames, like a list of numbers\n"
"or a subset of data."
msgstr ""
"Зауважте також, що цикли можна використовувати для інших речей, окрім імен файлів, наприклад, для списку чисел\n"
"або підмножини даних."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:169
msgid "> ## Write your own loop"
msgstr "> ## Напишіть власний цикл"

#: shell-novice/_episodes/05-loop.md:170
msgid ""
">\n"
"> How would you write a loop that echoes all 10 numbers from 0 to 9?\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > $ for loop_variable in 0 1 2 3 4 5 6 7 8 9\n"
"> > > do\n"
"> > >     echo $loop_variable\n"
"> > > done\n"
"> > ~~~\n"
"> > {: .language-bash}\n"
"> >\n"
"> > ```\n"
"> > 0\n"
"> > 1\n"
"> > 2\n"
"> > 3\n"
"> > 4\n"
"> > 5\n"
"> > 6\n"
"> > 7\n"
"> > 8\n"
"> > 9\n"
"> > ```\n"
"> > {: .output}"
msgstr ""
">\n"
"> Як би ви написали цикл, який виводить всі 10 чисел від 0 до 9?\n"
">\n"
"> > ## Розв'язання\n"
"> >\n"
"> > ~~~\n"
"> > $ for loop_variable in 0 1 2 3 4 5 6 7 8 9\n"
"> > > do\n"
"> > >     echo $loop_variable\n"
"> > > done\n"
"> > ~~~\n"
"> > {: .language-bash}\n"
"> >\n"
"> > ```\n"
"> > 0\n"
"> > 1\n"
"> > 2\n"
"> > 3\n"
"> > 4\n"
"> > 5\n"
"> > 6\n"
"> > 7\n"
"> > 8\n"
"> > 9\n"
"> > ```\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:199
msgid "> ## Variables in Loops"
msgstr "> ## Змінні в циклах"

#: shell-novice/_episodes/05-loop.md:200
msgid ""
">\n"
"> This exercise refers to the `shell-lesson-data/exercise-data/proteins` directory.\n"
"> `ls *.pdb` gives the following output:\n"
">\n"
"> ~~~\n"
"> cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> ~~~"
msgstr ""
">\n"
"> Ця вправа звертається до каталогу `shell-lesson-data/exercise-data/proteins`.\n"
"> `ls *.pdb` видає наступний результат:\n"
">\n"
"> ~~~\n"
"> cubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:208
msgid ""
">\n"
"> What is the output of the following code?\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     ls *.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Now, what is the output of the following code?\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     ls $datafile\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Why do these two loops give different outputs?\n"
">\n"
"> > ## Solution\n"
"> > The first code block gives the same output on each iteration through\n"
"> > the loop.\n"
"> > Bash expands the wildcard `*.pdb` within the loop body (as well as\n"
"> > before the loop starts) to match all files ending in `.pdb`\n"
"> > and then lists them using `ls`.\n"
"> > The expanded loop would look like this:\n"
"> > ```\n"
"> > $ for datafile in cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > > do\n"
"> > >     ls cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > > done\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> >\n"
"> > ```\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > ```\n"
"> > {: .output}\n"
"> >\n"
"> > The second code block lists a different file on each loop iteration.\n"
"> > The value of the `datafile` variable is evaluated using `$datafile`,\n"
"> > and then listed using `ls`.\n"
"> >\n"
"> > ```\n"
"> > cubane.pdb\n"
"> > ethane.pdb\n"
"> > methane.pdb\n"
"> > octane.pdb\n"
"> > pentane.pdb\n"
"> > propane.pdb\n"
"> > ```\n"
"> > {: .output}"
msgstr ""
">\n"
"> Що виводить наступний код?\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     ls *.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Тепер, що виводить наступний код?\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     ls $datafile\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Чому ці два цикли дають різні результати?\n"
">\n"
"> > ## Розв'язання\n"
"> > Перший блок коду дає однаковий результат на кожній ітерації\n"
"> > циклу.\n"
"> > Bash розширює шаблон `*.pdb` в тілі циклу (а також\n"
"> > перед початком циклу), щоб знайти всі файли, що закінчуються на `.pdb`.\n"
"> > а потім перераховує їх за допомогою `ls`.\n"
"> > Розширений цикл матиме такий вигляд:\n"
"> > ```\n"
"> > $ for datafile in cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > > do\n"
"> > >     ls cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > > done\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> >\n"
"> > ```\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > ```\n"
"> > {: .output}\n"
"> >\n"
"> > Другий блок коду перераховує різні файли на кожній ітерації циклу.\n"
"> > Значення змінної `datafile` обчислюється за допомогою `$datafile`,\n"
"> > а потім перераховується за допомогою `ls`.\n"
"> >\n"
"> > ```\n"
"> > cubane.pdb\n"
"> > ethane.pdb\n"
"> > methane.pdb\n"
"> > octane.pdb\n"
"> > pentane.pdb\n"
"> > propane.pdb\n"
"> > ```\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:272
msgid "> ## Limiting Sets of Files"
msgstr "> ## Обмеження набору файлів"

#: shell-novice/_episodes/05-loop.md:273
msgid ""
">\n"
"> What would be the output of running the following loop in the\n"
"> `shell-lesson-data/exercise-data/proteins` directory?\n"
">\n"
"> ~~~\n"
"> $ for filename in c*\n"
"> > do\n"
"> >     ls $filename\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1.  No files are listed.\n"
"> 2.  All files are listed.\n"
"> 3.  Only `cubane.pdb`, `octane.pdb` and `pentane.pdb` are listed.\n"
"> 4.  Only `cubane.pdb` is listed.\n"
">\n"
"> > ## Solution\n"
"> > 4 is the correct answer. `*` matches zero or more characters, so any file name starting with\n"
"> > the letter c, followed by zero or more other characters will be matched."
msgstr ""
">\n"
"> Що буде виведено у результаті виконання наступного циклу в каталозі\n"
"> `shell-lesson-data/exercise-data/proteins`?>\n"
"> ~~~\n"
"> $ for filename in c*\n"
"> > do\n"
"> >     ls $filename\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Жодної назви файлу не буде виведено.\n"
"> 2. Будуть перелічені всі файли.\n"
"> 3. Будуть перелічені лише `cubane.pdb`, `octane.pdb` та `pentane.pdb`.\n"
"> 4. Буде виведено лише `cubane.pdb`.\n"
">\n"
"> > ## Розв'язання\n"
"> > 4 - правильна відповідь. Підстановочний символ `*` відповідає нулю або більшій кількості символів, тому будь-яке ім'я файлу, що починається з\n"
"> > літери 'c', за якою йдуть нуль або більша кількість символів, підійде."

#: shell-novice/_episodes/05-loop.md:294
msgid ""
">\n"
"> How would the output differ from using this command instead?\n"
">\n"
"> ~~~\n"
"> $ for filename in *c*\n"
"> > do\n"
"> >     ls $filename\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1.  The same files would be listed.\n"
"> 2.  All the files are listed this time.\n"
"> 3.  No files are listed this time.\n"
"> 4.  The files `cubane.pdb` and `octane.pdb` will be listed.\n"
"> 5.  Only the file `octane.pdb` will be listed.\n"
">\n"
"> > ## Solution\n"
"> > 4 is the correct answer. `*` matches zero or more characters, so a file name with zero or more\n"
"> > characters before a letter c and zero or more characters after the letter c will be matched."
msgstr ""
">\n"
"> Як зміниться результат, якщо замість неї використати цю команду?\n"
">\n"
"> ~~~\n"
"> $ for filename in *c*\n"
"> > do\n"
"> >     ls $filename\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Будуть перераховані ті ж файли.\n"
"> 2. Цього разу перераховані всі файли.\n"
"> 3. Цього разу не виведено жодного файла.\n"
"> 4. Будуть перераховані файли `cubane.pdb` і `octane.pdb`.\n"
"> 5. Буде перераховано лише файл `octane.pdb`.\n"
">\n"
"> > ## Розв'язання\n"
"> > 4 - правильна відповідь. Підстановочний символ `*` відповідає нулю або більшій кількості символів, тому всі імена файлів з нулем або більшою кількістю\n"
"> > символів перед літерою 'c' і нулем або більшою кількістю символів після літери 'c' підійдуть."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:317
msgid "> ## Saving to a File in a Loop - Part One"
msgstr "> ## Збереження у файл в циклі - Частина перша"

#: shell-novice/_episodes/05-loop.md:318
msgid ""
">\n"
"> In the `shell-lesson-data/exercise-data/proteins` directory, what is the effect of this loop?\n"
">\n"
"> ~~~\n"
"> for alkanes in *.pdb\n"
"> do\n"
">     echo $alkanes\n"
">     cat $alkanes > alkanes.pdb\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1.  Prints `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb` and\n"
">    `propane.pdb`, and the text from `propane.pdb` will be saved to a file called `alkanes.pdb`.\n"
"> 2.  Prints `cubane.pdb`, `ethane.pdb`, and `methane.pdb`, and the text from all three files\n"
">     would be concatenated and saved to a file called `alkanes.pdb`.\n"
"> 3.  Prints `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, and `pentane.pdb`,\n"
">     and the text from `propane.pdb` will be saved to a file called `alkanes.pdb`.\n"
"> 4.  None of the above.\n"
">\n"
"> > ## Solution\n"
"> > 1. The text from each file in turn gets written to the `alkanes.pdb` file.\n"
"> > However, the file gets overwritten on each loop iteration, so the final content of\n"
"> > `alkanes.pdb`\n"
"> > is the text from the `propane.pdb` file."
msgstr ""
">\n"
"> В каталозі `shell-lesson-data/exercise-data/proteins`, який результат роботи цього циклу?\n"
">\n"
"> ~~~\n"
"> for alkanes in *.pdb\n"
"> do\n"
">     echo $alkanes\n"
">     cat $alkanes > alkanes.pdb\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Буде виведено `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb` і\n"
"> `propane.pdb`, а текст з `propane.pdb` буде збережено у файлі з назвою `alkanes.pdb`.\n"
"> 2. Буде виведено `cubane.pdb`, `ethane.pdb` і `methane.pdb`, і текст з усіх трьох файлів\n"
"> буде об'єднано і збережено у файл з назвою `alkanes.pdb`.\n"
"> 3. Буде виведено `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb` і `pentane.pdb`,\n"
"> а текст з `propane.pdb` буде збережено до файлу з назвою `alkanes.pdb`.\n"
"> 4. Нічого з перерахованого вище.\n"
">\n"
"> > ## Розв'язання\n"
"> > 1. Текст з кожного файлу по черзі записується у файл `alkanes.pdb`.\n"
"> Однак, файл перезаписується на кожній ітерації циклу, тому кінцевий вміст\n"
"> > `alkanes.pdb'\n"
"> > буде дорівнювати тексту з файлу `propane.pdb`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:346
msgid "> ## Saving to a File in a Loop - Part Two"
msgstr "> ## Збереження у файл в циклі - Частина друга"

#: shell-novice/_episodes/05-loop.md:347
msgid ""
">\n"
"> Also in the `shell-lesson-data/exercise-data/proteins` directory,\n"
"> what would be the output of the following loop?\n"
">\n"
"> ~~~\n"
"> for datafile in *.pdb\n"
"> do\n"
">     cat $datafile >> all.pdb\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1.  All of the text from `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, and\n"
">     `pentane.pdb` would be concatenated and saved to a file called `all.pdb`.\n"
"> 2.  The text from `ethane.pdb` will be saved to a file called `all.pdb`.\n"
"> 3.  All of the text from `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb`\n"
">     and `propane.pdb` would be concatenated and saved to a file called `all.pdb`.\n"
"> 4.  All of the text from `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb`\n"
">     and `propane.pdb` would be printed to the screen and saved to a file called `all.pdb`.\n"
">\n"
"> > ## Solution\n"
"> > 3 is the correct answer. `>>` appends to a file, rather than overwriting it with the redirected\n"
"> > output from a command.\n"
"> > Given the output from the `cat` command has been redirected, nothing is printed to the screen."
msgstr ""
">\n"
"> Також у каталозі `shell-lesson-data/exercise-data/proteins`,\n"
"> що буде виведено у наступному циклі?>\n"
"> ~~~\n"
"> for datafile in *.pdb\n"
"> do\n"
">     cat $datafile >> all.pdb\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Весь текст з файлів `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb` та\n"
"> `pentane.pdb` буде об'єднано і збережено у файлі з назвою `all.pdb`.\n"
"> 2. Текст з файлу `ethane.pdb` буде збережено до файлу з назвою `all.pdb`.\n"
"> 3. Весь текст з файлів `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb`\n"
"> та `propane.pdb` буде об'єднано та збережено у файл з назвою `all.pdb`.\n"
"> 4. Весь текст з файлів `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb`\n"
"> і `propane.pdb` буде виведено на екран і збережено у файлі з назвою `all.pdb`.\n"
">\n"
"> > ## Розв'язання\n"
"> > 3 - правильна відповідь. Оператор `>>` додає вміст до файлу, а не перезаписує його перенаправленим\n"
"> > виводом команди.\n"
"> > Оскільки вивід команди `cat` було перенаправлено, на екран нічого не буде виведено."

#: shell-novice/_episodes/05-loop.md:374
msgid ""
"Let's continue with our example in the `shell-lesson-data/exercise-data/creatures` directory.\n"
"Here's a slightly more complicated loop:"
msgstr ""
"Давайте продовжимо наш приклад у каталозі `shell-lesson-data/exercise-data/creatures`.\n"
"Тут цикл трохи складніший:"

# code block
#: shell-novice/_episodes/05-loop.md:377
msgid ""
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     echo $filename\n"
">     head -n 100 $filename | tail -n 20\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     echo $filename\n"
">     head -n 100 $filename | tail -n 20\n"
"> done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:386
msgid ""
"The shell starts by expanding `*.dat` to create the list of files it will process.\n"
"The **loop body**\n"
"then executes two commands for each of those files.\n"
"The first command, `echo`, prints its command-line arguments to standard output.\n"
"For example:"
msgstr ""
"Термінал розпочинає роботу з розгортання `*.dat` для створення списку файлів, які він буде обробляти.\n"
"**Тіло циклу**\n"
"виконує дві команди для кожного з цих файлів.\n"
"Перша команда, `echo`, виводить аргументи командного рядка у стандартний вивід.\n"
"Наприклад:"

# code block
#: shell-novice/_episodes/05-loop.md:392
msgid ""
"~~~\n"
"$ echo hello there\n"
"~~~"
msgstr ""
"~~~\n"
"$ echo hello there\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:397
msgid "prints:"
msgstr "виводить:"

# code block
#: shell-novice/_episodes/05-loop.md:399
msgid ""
"~~~\n"
"hello there\n"
"~~~"
msgstr ""
"~~~\n"
"hello there\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:404
msgid ""
"In this case,\n"
"since the shell expands `$filename` to be the name of a file,\n"
"`echo $filename` prints the name of the file.\n"
"Note that we can't write this as:"
msgstr ""
"У цьому випадку,\n"
"оскільки термінал розширює `$filename` до імені файлу,\n"
"`echo $filename` виводить ім'я файлу.\n"
"Зауважте, що ми не можемо написати це як:"

# code block
#: shell-novice/_episodes/05-loop.md:409
msgid ""
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     $filename\n"
">     head -n 100 $filename | tail -n 20\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     $filename\n"
">     head -n 100 $filename | tail -n 20\n"
"> done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:418
msgid ""
"because then the first time through the loop,\n"
"when `$filename` expanded to `basilisk.dat`, the shell would try to run `basilisk.dat` as\n"
"a program.\n"
"Finally,\n"
"the `head` and `tail` combination selects lines 81-100\n"
"from whatever file is being processed\n"
"(assuming the file has at least 100 lines)."
msgstr ""
"тому що при першому проходженні через цикл,\n"
"коли `$filename` розшириться до `basilisk.dat`, оболонка спробує запустити `basilisk.dat`\n"
"як програму.\n"
"Нарешті,\n"
"комбінація `head` і `tail` виділить рядки 81-100\n"
"з будь-якого файлу, який обробляється\n"
"(за умови, що у відповідному файлі є принаймні 100 рядків)."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:426
msgid "> ## Spaces in Names"
msgstr "> ## Пробіли в іменах"

#: shell-novice/_episodes/05-loop.md:427
msgid ""
">\n"
"> Spaces are used to separate the elements of the list\n"
"> that we are going to loop over. If one of those elements\n"
"> contains a space character, we need to surround it with\n"
"> quotes, and do the same thing to our loop variable.\n"
"> Suppose our data files are named:\n"
">\n"
"> ~~~\n"
"> red dragon.dat\n"
"> purple unicorn.dat\n"
"> ~~~"
msgstr ""
">\n"
"> Пробіли використовуються для відокремлення елементів списку\n"
"> які ми будемо перебирати у циклі. Якщо один з цих елементів\n"
"> містить пробіл, нам потрібно взяти його в\n"
"> лапки і зробити те ж саме зі змінною циклу.\n"
"> Припустимо, що наші файли даних мають імена:\n"
">\n"
"> ~~~\n"
"> red dragon.dat\n"
"> purple unicorn.dat\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:439
msgid ""
">\n"
"> To loop over these files, we would need to add double quotes like so:\n"
">\n"
"> ~~~\n"
"> $ for filename in \"red dragon.dat\" \"purple unicorn.dat\"\n"
"> > do\n"
"> >     head -n 100 \"$filename\" | tail -n 20\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> It is simpler to avoid using spaces (or other special characters) in filenames.\n"
">\n"
"> The files above don't exist, so if we run the above code, the `head` command will be unable\n"
"> to find them, however the error message returned will show the name of the files it is\n"
"> expecting:\n"
">\n"
"> ~~~\n"
"> head: cannot open ‘red dragon.dat’ for reading: No such file or directory\n"
"> head: cannot open ‘purple unicorn.dat’ for reading: No such file or directory\n"
"> ~~~"
msgstr ""
">\n"
"> Щоб виконати цикл над цими файлами, нам потрібно додати подвійні лапки, ось так:\n"
">\n"
"> ~~~\n"
"> $ for filename in \"red dragon.dat\" \"purple unicorn.dat\"\n"
"> > do\n"
"> >     head -n 100 \"$filename\" | tail -n 20\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Простіше уникати використання пробілів (або інших спеціальних символів) у назвах файлів.\n"
">\n"
"> Вищевказані файли не існують, тому якщо ми виконаємо вищенаведений код, команда `head` не зможе\n"
"> знайти їх, однак у повідомленні про помилку буде показано назви цих файлів,\n"
"> що очікувалися:\n"
">\n"
"> ~~~\n"
"> head: cannot open ‘red dragon.dat’ for reading: No such file or directory\n"
"> head: cannot open ‘purple unicorn.dat’ for reading: No such file or directory\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:461
msgid ""
">\n"
"> Try removing the quotes around `$filename` in the loop above to see the effect of the quote\n"
"> marks on spaces. Note that we get a result from the loop command for unicorn.dat\n"
"> when we run this code in the `creatures` directory:\n"
">\n"
"> ~~~\n"
"> head: cannot open ‘red’ for reading: No such file or directory\n"
"> head: cannot open ‘dragon.dat’ for reading: No such file or directory\n"
"> head: cannot open ‘purple’ for reading: No such file or directory\n"
"> CGGTACCGAA\n"
"> AAGGGTCGCG\n"
"> CAAGTGTTCC\n"
"> ...\n"
"> ~~~"
msgstr ""
">\n"
"> Спробуйте видалити лапки навколо `$filename` у наведеному вище циклі, щоб побачити ефект лапок\n"
"> позначки на пробілах. Зверніть увагу, що ми отримуємо результат команди циклу для unicorn.dat\n"
"> коли ми запускаємо цей код у каталозі `creatures`:\n"
">\n"
"> ~~~\n"
"> head: cannot open ‘red’ for reading: No such file or directory\n"
"> head: cannot open ‘dragon.dat’ for reading: No such file or directory\n"
"> head: cannot open ‘purple’ for reading: No such file or directory\n"
"> CGGTACCGAA\n"
"> AAGGGTCGCG\n"
"> CAAGTGTTCC\n"
"> ...\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:478
msgid ""
"We would like to modify each of the files in `shell-lesson-data/exercise-data/creatures`,\n"
"but also save a version\n"
"of the original files, naming the copies `original-basilisk.dat` and `original-unicorn.dat`.\n"
"We can't use:"
msgstr ""
"Ми б хотіли змінити кожен з файлів у `shell-lesson-data/exercise-data/creatures`,\n"
"але також зберегти версію\n"
"оригінальних файлів, назвавши копії `original-basilisk.dat` і `original-unicorn.dat`.\n"
"Ми не можемо використовувати:"

# code block
#: shell-novice/_episodes/05-loop.md:483
msgid ""
"~~~\n"
"$ cp *.dat original-*.dat\n"
"~~~"
msgstr ""
"~~~\n"
"$ cp *.dat original-*.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:488
msgid "because that would expand to:"
msgstr "тому що це буде розширено до:"

# code block
#: shell-novice/_episodes/05-loop.md:490
msgid ""
"~~~\n"
"$ cp basilisk.dat minotaur.dat unicorn.dat original-*.dat\n"
"~~~"
msgstr ""
"~~~\n"
"$ cp basilisk.dat minotaur.dat unicorn.dat original-*.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:495
msgid "This wouldn't back up our files, instead we get an error:"
msgstr ""
"Це не створить резервну копію наших файлів, натомість ми отримаємо помилку:"

# code block
#: shell-novice/_episodes/05-loop.md:497
msgid ""
"~~~\n"
"cp: target `original-*.dat' is not a directory\n"
"~~~"
msgstr ""
"~~~\n"
"cp: target `original-*.dat' is not a directory\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:502
msgid ""
"This problem arises when `cp` receives more than two inputs. When this happens, it\n"
"expects the last input to be a directory where it can copy all the files it was passed.\n"
"Since there is no directory named `original-*.dat` in the `creatures` directory we get an\n"
"error."
msgstr ""
"Ця проблема виникає, коли команда `cp` отримує більше двох входів. Коли це відбувається, вона\n"
"очікує, що останнім вхідним параметром буде каталог, куди вона зможе скопіювати всі файли, які їй було передано.\n"
"Оскільки у каталозі `creatures` немає каталогу з назвою `original-*.dat`, ми отримаємо\n"
"помилку."

#: shell-novice/_episodes/05-loop.md:507
msgid ""
"Instead, we can use a loop:\n"
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     cp $filename original-$filename\n"
"> done\n"
"~~~\n"
"{: .language-bash}"
msgstr ""
"Замість цього ми можемо використати цикл:\n"
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     cp $filename original-$filename\n"
"> done\n"
"~~~\n"
"{: .language-bash}"

#: shell-novice/_episodes/05-loop.md:516
msgid ""
"This loop runs the `cp` command once for each filename.\n"
"The first time,\n"
"when `$filename` expands to `basilisk.dat`,\n"
"the shell executes:"
msgstr ""
"Цей цикл виконує команду `cp` один раз для кожного імені файлу.\n"
"Перший раз,\n"
"коли змінна `$filename` має значення до `basilisk.dat`,\n"
"термінал виконає:"

# code block
#: shell-novice/_episodes/05-loop.md:521
msgid ""
"~~~\n"
"cp basilisk.dat original-basilisk.dat\n"
"~~~"
msgstr ""
"~~~\n"
"cp basilisk.dat original-basilisk.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:526
msgid "The second time, the command is:"
msgstr "У другий раз команда наступна:"

# code block
#: shell-novice/_episodes/05-loop.md:528
msgid ""
"~~~\n"
"cp minotaur.dat original-minotaur.dat\n"
"~~~"
msgstr ""
"~~~\n"
"cp minotaur.dat original-minotaur.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:533
msgid "The third and last time, the command is:"
msgstr "В третій, останній раз, команда буде такою:"

# code block
#: shell-novice/_episodes/05-loop.md:535
msgid ""
"~~~\n"
"cp unicorn.dat original-unicorn.dat\n"
"~~~"
msgstr ""
"~~~\n"
"cp unicorn.dat original-unicorn.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:540
msgid ""
"Since the `cp` command does not normally produce any output, it's hard to check\n"
"that the loop is doing the correct thing.\n"
"However, we learned earlier how to print strings using `echo`, and we can modify the loop\n"
"to use `echo` to print our commands without actually executing them.\n"
"As such we can check what commands *would be* run in the unmodified loop."
msgstr ""
"Оскільки команда `cp` зазвичай не виводить нічого, важко перевірити\n"
"що цикл працює правильно.\n"
"Однак раніше ми дізналися, як виводити рядки за допомогою `echo`, і ми можемо модифікувати цикл\n"
"щоб використовувати `echo` для виведення наших команд без їхнього виконання.\n"
"Таким чином, ми можемо перевірити, які команди виконувалися *би* у немодифікованому циклі."

#: shell-novice/_episodes/05-loop.md:546
msgid ""
"The following diagram\n"
"shows what happens when the modified loop is executed, and demonstrates how the\n"
"judicious use of `echo` is a good debugging technique."
msgstr ""
"Наступна діаграма\n"
"показує, що відбувається при виконанні модифікованого циклу, і демонструє, як\n"
"розумне використання `echo` є гарною технікою зневадження."

#: shell-novice/_episodes/05-loop.md:550
msgid ""
"![The for loop \"for filename in *.dat; do echo cp $filename original-$filename;\n"
"done\" will successively assign the names of all \"*.dat\" files in your current\n"
"directory to the variable \"$filename\" and then execute the command. With the\n"
"files \"basilisk.dat\", \"minotaur.dat\" and \"unicorn.dat\" in the current directory\n"
"the loop will successively call the echo command three times and print three\n"
"lines: \"cp basislisk.dat original-basilisk.dat\", then \"cp minotaur.dat\n"
"original-minotaur.dat\" and finally \"cp unicorn.dat\n"
"original-unicorn.dat\"](../fig/shell_script_for_loop_flow_chart.svg)"
msgstr ""
"![Цикл for \"for filename in *.dat; do echo cp $filename original-$filename;\n"
"done\" послідовно присвоїть змінній \"$filename\" імена всіх \"*.dat\" файлів у вашому поточному\n"
"каталозі змінній \"$filename\" та після цього виконає команду. Для\n"
"файлів \"basilisk.dat\", \"minotaur.dat\" та \"unicorn.dat\" в поточному каталозі\n"
"цикл тричі послідовно викличе команду echo і виведе три\n"
"рядки: \"cp basislisk.dat original-basilisk.dat\", потім \"cp minotaur.dat\n"
"original-minotaur.dat\" та нарешті \"cp unicorn.dat\n"
"original-unicorn.dat\"](../fig/shell_script_for_loop_flow_chart.svg)"

# header
#: shell-novice/_episodes/05-loop.md:559
msgid "## Nelle's Pipeline: Processing Files"
msgstr "## Конвеєр Неллі: Обробка файлів"

#: shell-novice/_episodes/05-loop.md:561
msgid ""
"Nelle is now ready to process her data files using `goostats.sh` ---\n"
"a shell script written by her supervisor.\n"
"This calculates some statistics from a protein sample file, and takes two arguments:"
msgstr ""
"Тепер Неллі готова обробити свої файли даних за допомогою `goostats.sh` ---\n"
"скрипта терміналу, написаного її керівником.\n"
"Він обчислює деякі статистичні дані з файлу зразка білка і приймає два аргументи:"

# ordered list
#: shell-novice/_episodes/05-loop.md:565
msgid "1. an input file (containing the raw data)"
msgstr "1. вхідний файл (що містить вихідні дані)"

# ordered list
#: shell-novice/_episodes/05-loop.md:566
msgid "2. an output file (to store the calculated statistics)"
msgstr "2. вихідний файл (для збереження розрахованої статистики)"

#: shell-novice/_episodes/05-loop.md:568
msgid ""
"Since she's still learning how to use the shell,\n"
"she decides to build up the required commands in stages.\n"
"Her first step is to make sure that she can select the right input files --- remember,\n"
"these are ones whose names end in 'A' or 'B', rather than 'Z'.\n"
"Starting from her home directory, Nelle types:"
msgstr ""
"Оскільки вона все ще вчиться користуватися терміналом,\n"
"вона вирішує створювати необхідні команди поетапно.\n"
"Першим кроком буде переконатися, що вона може вибирати правильні вхідні файли - запам'ятайте,\n"
"це ті, назви яких закінчуються на 'A' або 'B', а не на 'Z'.\n"
"Починаючи з домашнього каталогу, Неллі набирає:"

# code block
#: shell-novice/_episodes/05-loop.md:574
msgid ""
"~~~\n"
"$ cd north-pacific-gyre\n"
"$ for datafile in NENE*A.txt NENE*B.txt\n"
"> do\n"
">     echo $datafile\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd north-pacific-gyre\n"
"$ for datafile in NENE*A.txt NENE*B.txt\n"
"> do\n"
">     echo $datafile\n"
"> done\n"
"~~~"

# code block
#: shell-novice/_episodes/05-loop.md:583
msgid ""
"~~~\n"
"NENE01729A.txt\n"
"NENE01729B.txt\n"
"NENE01736A.txt\n"
"...\n"
"NENE02043A.txt\n"
"NENE02043B.txt\n"
"~~~"
msgstr ""
"~~~\n"
"NENE01729A.txt\n"
"NENE01729B.txt\n"
"NENE01736A.txt\n"
"...\n"
"NENE02043A.txt\n"
"NENE02043B.txt\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:593
msgid ""
"Her next step is to decide\n"
"what to call the files that the `goostats.sh` analysis program will create.\n"
"Prefixing each input file's name with 'stats' seems simple,\n"
"so she modifies her loop to do that:"
msgstr ""
"Наступним кроком буде вирішити\n"
"як назвати файли, які створить програма аналізу `goostats.sh`.\n"
"Додавання до імені кожного вхідного файлу префікса \"stats\" здається простим,\n"
"тому вона модифікує свій цикл для цього:"

# code block
#: shell-novice/_episodes/05-loop.md:598
msgid ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt\n"
"> do\n"
">     echo $datafile stats-$datafile\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt\n"
"> do\n"
">     echo $datafile stats-$datafile\n"
"> done\n"
"~~~"

# code block
#: shell-novice/_episodes/05-loop.md:606
msgid ""
"~~~\n"
"NENE01729A.txt stats-NENE01729A.txt\n"
"NENE01729B.txt stats-NENE01729B.txt\n"
"NENE01736A.txt stats-NENE01736A.txt\n"
"...\n"
"NENE02043A.txt stats-NENE02043A.txt\n"
"NENE02043B.txt stats-NENE02043B.txt\n"
"~~~"
msgstr ""
"~~~\n"
"NENE01729A.txt stats-NENE01729A.txt\n"
"NENE01729B.txt stats-NENE01729B.txt\n"
"NENE01736A.txt stats-NENE01736A.txt\n"
"...\n"
"NENE02043A.txt stats-NENE02043A.txt\n"
"NENE02043B.txt stats-NENE02043B.txt\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:616
msgid ""
"She hasn't actually run `goostats.sh` yet,\n"
"but now she's sure she can select the right files and generate the right output filenames."
msgstr ""
"Насправді, вона ще не запускала `goostats.sh`,\n"
"але тепер вона впевнена, що може вибрати правильні файли і згенерувати правильні назви вихідних файлів."

#: shell-novice/_episodes/05-loop.md:619
msgid ""
"Typing in commands over and over again is becoming tedious,\n"
"though,\n"
"and Nelle is worried about making mistakes,\n"
"so instead of re-entering her loop,\n"
"she presses <kbd>↑</kbd>.\n"
"In response,\n"
"the shell redisplays the whole loop on one line\n"
"(using semi-colons to separate the pieces):"
msgstr ""
"Введення команд знову і знову стає нудним,\n"
"і Неллі хвилюється через можливі помилки,\n"
"тож замість того, щоб перенабирати свій цикл,\n"
"вона натискає <kbd>↑</kbd>.\n"
"У відповідь\n"
"оболонка відобразить весь цикл в одному рядку\n"
"(використовуючи крапку з комою для розділення частин):"

# code block
#: shell-novice/_episodes/05-loop.md:628
msgid ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:633
msgid ""
"Using the left arrow key,\n"
"Nelle backs up and changes the command `echo` to `bash goostats.sh`:"
msgstr ""
"За допомогою клавіші зі стрілкою ліворуч,\n"
"Неллі створює резервну копію і змінює команду `echo` на `bash goostats.sh`:"

# code block
#: shell-novice/_episodes/05-loop.md:636
msgid ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:641
msgid ""
"When she presses <kbd>Enter</kbd>,\n"
"the shell runs the modified command.\n"
"However, nothing appears to happen --- there is no output.\n"
"After a moment, Nelle realizes that since her script doesn't print anything to the screen\n"
"any longer, she has no idea whether it is running, much less how quickly.\n"
"She kills the running command by typing <kbd>Ctrl</kbd>+<kbd>C</kbd>,\n"
"uses <kbd>↑</kbd> to repeat the command,\n"
"and edits it to read:"
msgstr ""
"Коли вона натискає <kbd>Enter</kbd>,\n"
"термінал виконає змінену команду.\n"
"Однак, здається, нічого не відбувається - немає ніякого виводу.\n"
"За мить Неллі розуміє, що оскільки її скрипт більше нічого не виводить на екран,\n"
"вона не має жодного уявлення про те, чи виконується він, а тим паче, як швидко.\n"
"Вона перериває команду виконання, набравши <kbd>Ctrl</kbd>+<kbd>C</kbd>,\n"
"використовує <kbd>↑</kbd> для повтору команди,\n"
"і редагує її, щоб читати:"

# code block
#: shell-novice/_episodes/05-loop.md:650
msgid ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile;\n"
"bash goostats.sh $datafile stats-$datafile; done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile;\n"
"bash goostats.sh $datafile stats-$datafile; done\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:656
msgid "> ## Beginning and End"
msgstr "> ## Початок і кінець"

#: shell-novice/_episodes/05-loop.md:657
msgid ""
">\n"
"> We can move to the beginning of a line in the shell by typing <kbd>Ctrl</kbd>+<kbd>A</kbd>\n"
"> and to the end using <kbd>Ctrl</kbd>+<kbd>E</kbd>."
msgstr ""
">\n"
"> Перехід на початок рядка в оболонці здійснюється за допомогою комбінації клавіш <kbd>Ctrl</kbd>+<kbd>A</kbd>\n"
"> і в кінець рядка - за допомогою <kbd>Ctrl</kbd>+<kbd>E</kbd>."

#: shell-novice/_episodes/05-loop.md:662
msgid ""
"When she runs her program now,\n"
"it produces one line of output every five seconds or so:"
msgstr ""
"Коли вона запускає свою програму зараз,\n"
"програма виводить один рядок кожні п'ять секунд або близько того:"

# code block
#: shell-novice/_episodes/05-loop.md:665
msgid ""
"~~~\n"
"NENE01729A.txt\n"
"NENE01729B.txt\n"
"NENE01736A.txt\n"
"...\n"
"~~~"
msgstr ""
"~~~\n"
"NENE01729A.txt\n"
"NENE01729B.txt\n"
"NENE01736A.txt\n"
"...\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:673
msgid ""
"1518 times 5 seconds,\n"
"divided by 60,\n"
"tells her that her script will take about two hours to run.\n"
"As a final check,\n"
"she opens another terminal window,\n"
"goes into `north-pacific-gyre`,\n"
"and uses `cat stats-NENE01729B.txt`\n"
"to examine one of the output files.\n"
"It looks good,\n"
"so she decides to get some coffee and catch up on her reading."
msgstr ""
"Значення 1518, помножене на 5 секунд,\n"
"поділене на 60,\n"
"каже їй, що її сценарій буде виконуватися близько двох годин.\n"
"Для остаточної перевірки\n"
"вона відкриває інше вікно терміналу,\n"
"переходить в `north-pacific-gyre`,\n"
"і використовує `cat stats-NENE01729B.txt`.\n"
"для перевірки одного з вихідних файлів.\n"
"Виглядає добре,\n"
"тож вона вирішує випити кави і продовжити читання."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:684
msgid "> ## Those Who Know History Can Choose to Repeat It"
msgstr "> ## Хто знає історію, той може її повторити"

#: shell-novice/_episodes/05-loop.md:685
msgid ""
">\n"
"> Another way to repeat previous work is to use the `history` command to\n"
"> get a list of the last few hundred commands that have been executed, and\n"
"> then to use `!123` (where '123' is replaced by the command number) to\n"
"> repeat one of those commands. For example, if Nelle types this:\n"
">\n"
"> ~~~\n"
"> $ history | tail -n 5\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
">   456  ls -l NENE0*.txt\n"
">   457  rm stats-NENE01729B.txt.txt\n"
">   458  bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n"
">   459  ls -l NENE0*.txt\n"
">   460  history\n"
"> ~~~"
msgstr ""
">\n"
"> Інший спосіб повторити попередню роботу - скористатися командою `history`, щоб\n"
"> отримати список останніх кількох сотень команд, які було виконано, і\n"
"> потім скористатися командою `!123` (де \"123\" замінено на номер команди), щоб\n"
"> повторити одну з цих команд. Наприклад, якщо Неллі набере наступне:\n"
">\n"
"> ~~~\n"
"> $ history | tail -n 5\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
">   456  ls -l NENE0*.txt\n"
">   457  rm stats-NENE01729B.txt.txt\n"
">   458  bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n"
">   459  ls -l NENE0*.txt\n"
">   460  history\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:703
msgid ""
">\n"
"> then she can re-run `goostats.sh` on `NENE01729B.txt` simply by typing\n"
"> `!458`."
msgstr ""
">\n"
"> тоді вона може перезапустити `goostats.sh` на `NENE01729B.txt`, просто набравши\n"
"> `!458`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:708
msgid "> ## Other History Commands"
msgstr "> ## Інші команди історії"

#: shell-novice/_episodes/05-loop.md:709
msgid ""
">\n"
"> There are a number of other shortcut commands for getting at the history.\n"
">\n"
"> - <kbd>Ctrl</kbd>+<kbd>R</kbd> enters a history search mode 'reverse-i-search' and finds the\n"
"> most recent command in your history that matches the text you enter next.\n"
"> Press <kbd>Ctrl</kbd>+<kbd>R</kbd> one or more additional times to search for earlier matches.\n"
"> You can then use the left and right arrow keys to choose that line and edit\n"
"> it then hit <kbd>Return</kbd> to run the command.\n"
"> - `!!` retrieves the immediately preceding command\n"
"> (you may or may not find this more convenient than using <kbd>↑</kbd>)\n"
"> - `!$` retrieves the last word of the last command.\n"
"> That's useful more often than you might expect: after\n"
"> `bash goostats.sh NENE01729B.txt stats-NENE01729B.txt`, you can type\n"
"> `less !$` to look at the file `stats-NENE01729B.txt`, which is\n"
"> quicker than doing <kbd>↑</kbd> and editing the command-line."
msgstr ""
">\n"
"> Існує ряд інших команд швидкого доступу до історії.\n"
">\n"
"> - <kbd>Ctrl</kbd>+<kbd>R</kbd> переходить у режим \"зворотного пошуку\" в історіїі і знаходить\n"
"> останню команду у вашому журналі, яка відповідає тексту, що ви введете далі.\n"
"> Натисніть<kbd>Ctrl</kbd>+<kbd>R</kbd> ще один або кілька додаткових разів для пошуку більш ранніх збігів.\n"
"> За допомогою клавіш зі стрілками вліво і вправо виберіть цей рядок і відредагуйте\n"
"> його, потім натисніть <kbd>Return</kbd> щоб виконати команду.\n"
"> - `!!` повертає безпосередньо попередню команду\n"
"> (ви можете знайти це більш зручним, ніж використання <kbd>↑</kbd>)\n"
"> - `!$` повертає останнє слово останньої команди.\n"
"> Це корисно частіше, ніж ви можете собі уявити: після\n"
"> `bash goostats.sh NENE01729B.txt stats-NENE01729B.txt`, ви можете ввести\n"
"> `less !$` для перегляду файлу `stats-NENE01729B.txt`, що\n"
"> швидше, ніж набирати <kbd>↑</kbd> і редагувати командний рядок."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:726
msgid "> ## Doing a Dry Run"
msgstr "> ## Виконання пробного запуску"

#: shell-novice/_episodes/05-loop.md:727
msgid ""
">\n"
"> A loop is a way to do many things at once --- or to make many mistakes at\n"
"> once if it does the wrong thing. One way to check what a loop *would* do\n"
"> is to `echo` the commands it would run instead of actually running them.\n"
">\n"
"> Suppose we want to preview the commands the following loop will execute\n"
"> without actually running those commands:\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     cat $datafile >> all.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> What is the difference between the two loops below, and which one would we\n"
"> want to run?\n"
">\n"
"> ~~~\n"
"> # Version 1\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     echo cat $datafile >> all.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> # Version 2\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     echo \"cat $datafile >> all.pdb\"\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Solution\n"
"> > The second version is the one we want to run.\n"
"> > This prints to screen everything enclosed in the quote marks, expanding the\n"
"> > loop variable name because we have prefixed it with a dollar sign.\n"
"> > It also *does not* modify nor create the file `all.pdb`, as the `>>`\n"
"> > is treated literally as part of a string rather than as a\n"
"> > redirection instruction.\n"
"> >\n"
"> > The first version appends the output from the command `echo cat $datafile`\n"
"> > to the file, `all.pdb`. This file will just contain the list;\n"
"> > `cat cubane.pdb`, `cat ethane.pdb`, `cat methane.pdb` etc.\n"
"> >\n"
"> > Try both versions for yourself to see the output! Be sure to open the\n"
"> > `all.pdb` file to view its contents."
msgstr ""
">\n"
"> Цикл - це спосіб зробити багато речей одночасно --- або зробити багато помилок\n"
"> одночасно, якщо він робить неправильні речі. Один зі способів перевірити, що *робив би* цикл\n"
"> це за допомогою `echo` виводити команди, які він виконуватиме, замість того, щоб виконувати їх насправді.\n"
">\n"
"> Припустимо, ми хочемо переглянути команди, які виконає наступний цикл\n"
"> без виконання цих команд:\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     cat $datafile >> all.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> У чому різниця між двома наведеними нижче циклами, і який з них ми\n"
"> хочемо запустити?\n"
">\n"
"> ~~~\n"
"> # Варіант 1\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     echo cat $datafile >> all.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> # Варіант 2\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     echo \"cat $datafile >> all.pdb\"\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Розв'язання\n"
"> > Друга версія - це та, яку ми хочемо запустити.\n"
"> > Вона виводить на екран усе, що укладено у лапки, розширюючи\n"
"> > назву змінної циклу, оскільки ми додали до неї знак долара.\n"
"> > Він також *не* змінює і не створює файл `all.pdb`, оскільки оператор `>>`\n"
"> > розглядається буквально як частина рядка, а не як\n"
"> > інструкція перенаправлення.\n"
"> >\n"
"> > Перша версія додає вивід команди `echo cat $datafile`\n"
"> > до файлу `all.pdb`. Цей файл міститиме лише список\n"
"> > `cat cubane.pdb`, `cat ethane.pdb`, `cat methane.pdb` тощо.\n"
"> >\n"
"> > Спробуйте обидві версії, щоб побачити результат! Обов'язково відкрийте\n"
"> > файл `all.pdb`, щоб переглянути його вміст."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:781
msgid "> ## Nested Loops"
msgstr "> ## Вкладені цикли"

#: shell-novice/_episodes/05-loop.md:782
msgid ""
">\n"
"> Suppose we want to set up a directory structure to organize\n"
"> some experiments measuring reaction rate constants with different compounds\n"
"> *and* different temperatures.  What would be the\n"
"> result of the following code:\n"
">\n"
"> ~~~\n"
"> $ for species in cubane ethane methane\n"
"> > do\n"
"> >     for temperature in 25 30 37 40\n"
"> >     do\n"
"> >         mkdir $species-$temperature\n"
"> >     done\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Solution\n"
"> > We have a nested loop, i.e. contained within another loop, so for each species\n"
"> > in the outer loop, the inner loop (the nested loop) iterates over the list of\n"
"> > temperatures, and creates a new directory for each combination.\n"
"> >\n"
"> > Try running the code for yourself to see which directories are created!"
msgstr ""
">\n"
"> Припустімо, що ми хочемо створити структуру каталогів для організації\n"
"> певних експериментів з вимірювання констант швидкості реакції з різними сполуками\n"
"> *та* різними температурами. Яким буде\n"
"> результат виконання наступного коду:\n"
">\n"
"> ~~~\n"
"> $ for species in cubane ethane methane\n"
"> > do\n"
"> >     for temperature in 25 30 37 40\n"
"> >     do\n"
"> >         mkdir $species-$temperature\n"
"> >     done\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Розв'язання\n"
"> > Ми маємо вкладений цикл, тобто такий, що міститься в іншому циклі, тому для кожного значення змінної species\n"
"> > у зовнішньому циклі внутрішній цикл (вкладений цикл) перебирає список\n"
"> > температур і створює новий каталог для кожної комбінації.\n"
"> >\n"
"> > Спробуйте запустити код самостійно, щоб побачити, які каталоги буде створено!"

# Front Matter
#: shell-novice/_episodes/06-script.md:1
msgid ""
"---\n"
"title: \"Shell Scripts\"\n"
"teaching: 30\n"
"exercises: 15\n"
"questions:\n"
"- \"How can I save and re-use commands?\"\n"
"objectives:\n"
"- \"Write a shell script that runs a command or series of commands for a fixed set of files.\"\n"
"- \"Run a shell script from the command line.\"\n"
"- \"Write a shell script that operates on a set of files defined by the user on the command line.\"\n"
"- \"Create pipelines that include shell scripts you, and others, have written.\"\n"
"keypoints:\n"
"- \"Save commands in files (usually called shell scripts) for re-use.\"\n"
"- \"`bash [filename]` runs the commands saved in a file.\"\n"
"- \"`$@` refers to all of a shell script's command-line arguments.\"\n"
"- \"`$1`, `$2`, etc., refer to the first command-line argument, the second command-line argument, etc.\"\n"
"- \"Place variables in quotes if the values might have spaces in them.\"\n"
"- \"Letting users decide what files to process is more flexible and more consistent with built-in Unix commands.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Скрипти терміналу\"\n"
"teaching: 30\n"
"exercises: 15\n"
"questions:\n"
"- \"Як я можу зберігати і повторно використовувати команди?\"\n"
"objectives:\n"
"- \"Написати сценарій терміналу, який виконує команду або серію команд для фіксованого набору файлів.\"\n"
"- \"Запустити сценарій терміналу з командного рядка.\"\n"
"- \"Написати сценарій терміналу, який оперує набором файлів, заданих користувачем у командному рядку.\"\n"
"- \"Створити конвеєри, які включають написані вами та іншими користувачами скрипти терміналу.\"\n"
"keypoints:\n"
"- \"Зберігайте команди у файлах (зазвичай їх називають скриптами терміналу) для повторного використання.\"\n"
"- \"`bash [ім'я файлу]` виконує команди, збережені у відповідному файлі.\"\n"
"- \"`$@` посилається на всі аргументи командного рядка скрипта терміналу.\"\n"
"- \"`$1`, `$2`, і т.д., посилаються на перший аргумент командного рядка, другий аргумент командного рядка і т.д.\"\n"
"- \"Беріть змінні в лапки, якщо значення можуть містити пробіли.\"\n"
"- \"Дозвіл користувачам вирішувати, які файли обробляти, є більш гнучким і більш узгодженим з вбудованими командами Unix.\"\n"
"---"

#: shell-novice/_episodes/06-script.md:21
msgid ""
"We are finally ready to see what makes the shell such a powerful programming environment.\n"
"We are going to take the commands we repeat frequently and save them in files\n"
"so that we can re-run all those operations again later by typing a single command.\n"
"For historical reasons,\n"
"a bunch of commands saved in a file is usually called a **shell script**,\n"
"but make no mistake:\n"
"these are actually small programs."
msgstr ""
"Нарешті ми готові побачити, що робить термінал таким потужним середовищем програмування.\n"
"Ми збираємося взяти команди, які ми часто повторюємо, і зберегти їх у файлах,\n"
"щоб згодом ми могли повторно виконати всі ці операції, набравши одну команду.\n"
"З історичних причин\n"
"набір команд, збережених у файлі, зазвичай називають **скриптом терміналу**,\n"
"але не помиліться:\n"
"насправді це невеликі програми."

#: shell-novice/_episodes/06-script.md:29
msgid ""
"Not only will writing shell scripts make your work faster ---\n"
"you won't have to retype the same commands over and over again ---\n"
"it will also make it more accurate (fewer chances for typos) and more reproducible.\n"
"If you come back to your work later (or if someone else finds your work and wants to build on it)\n"
"you will be able to reproduce the same results simply by running your script,\n"
"rather than having to remember or retype a long list of commands."
msgstr ""
"Написання командних скриптів не тільки прискорить вашу роботу ---\n"
"вам не доведеться передруковувати ті самі команди знову і знову ---\n"
"це також зробить її більш точною (менше шансів на друкарські помилки) і більш відтворюваною.\n"
"Якщо ви повернетеся до своєї роботи пізніше (або якщо хтось інший знайде вашу роботу і захоче її використати)\n"
"ви зможете відтворити ті самі результати, просто запустивши ваш скрипт,\n"
"замість того, щоб запам'ятовувати або передруковувати довгий список команд."

#: shell-novice/_episodes/06-script.md:36
msgid ""
"Let's start by going back to `proteins/` and creating a new file, `middle.sh` which will\n"
"become our shell script:"
msgstr ""
"Давайте почнемо з того, що повернемося до каталогу `proteins/` і створимо новий файл `middle.sh`, який\n"
"стане нашим скриптом терміналу:"

# code block
#: shell-novice/_episodes/06-script.md:39
msgid ""
"~~~\n"
"$ cd proteins\n"
"$ nano middle.sh\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd proteins\n"
"$ nano middle.sh\n"
"~~~"

#: shell-novice/_episodes/06-script.md:45
msgid ""
"The command `nano middle.sh` opens the file `middle.sh` within the text editor 'nano'\n"
"(which runs within the shell).\n"
"If the file does not exist, it will be created.\n"
"We can use the text editor to directly edit the file -- we'll simply insert the following line:"
msgstr ""
"Команда `nano middle.sh` відкриває файл `middle.sh` у текстовому редакторі nano\n"
"(який запускається у терміналі).\n"
"Якщо файл не існує, його буде створено.\n"
"Ми можемо скористатися текстовим редактором для безпосереднього редагування файлу - просто вставте наступний рядок:"

# code block
#: shell-novice/_episodes/06-script.md:50
msgid ""
"~~~\n"
"head -n 15 octane.pdb | tail -n 5\n"
"~~~"
msgstr ""
"~~~\n"
"head -n 15 octane.pdb | tail -n 5\n"
"~~~"

# SC/DC Template label
#: shell-novice/_episodes/06-script.md:53
#: shell-novice/_episodes/06-script.md:114
#: shell-novice/_episodes/06-script.md:175
#: shell-novice/_episodes/06-script.md:224
#: shell-novice/_episodes/06-script.md:269
#: shell-novice/_episodes/06-script.md:359
msgid "{: .source}"
msgstr "{: .source}"

#: shell-novice/_episodes/06-script.md:55
msgid ""
"This is a variation on the pipe we constructed earlier:\n"
"it selects lines 11-15 of the file `octane.pdb`.\n"
"Remember, we are *not* running it as a command just yet:\n"
"we are putting the commands in a file."
msgstr ""
"Це варіація на тему каналу, яку ми побудували раніше:\n"
"вона вибирає рядки 11-15 файлу `octane.pdb`.\n"
"Пам'ятайте, що ми поки що *не* запускаємо її як команду:\n"
"ми записуємо команди у файл."

#: shell-novice/_episodes/06-script.md:60
msgid ""
"Then we save the file (`Ctrl-O` in nano),\n"
" and exit the text editor (`Ctrl-X` in nano).\n"
"Check that the directory `proteins` now contains a file called `middle.sh`."
msgstr ""
"Потім ми зберігаємо файл (`Ctrl-O` в nano),\n"
"і виходимо з текстового редактора (`Ctrl-X` у nano).\n"
"Переконайтеся, що в каталозі `proteins` тепер міститься файл з назвою `middle.sh`."

#: shell-novice/_episodes/06-script.md:64
msgid ""
"Once we have saved the file,\n"
"we can ask the shell to execute the commands it contains.\n"
"Our shell is called `bash`, so we run the following command:"
msgstr ""
"Після того, як ми зберегли файл,\n"
"ми можемо попросити термінал виконати команди, які у ньому містяться.\n"
"Наша термінал називається `bash`, тому ми виконаємо наступну команду:"

# code block
#: shell-novice/_episodes/06-script.md:68
msgid ""
"~~~\n"
"$ bash middle.sh\n"
"~~~"
msgstr ""
"~~~\n"
"$ bash middle.sh\n"
"~~~"

# code block
#: shell-novice/_episodes/06-script.md:73
#: shell-novice/_episodes/06-script.md:125
msgid ""
"~~~\n"
"ATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00\n"
"ATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00\n"
"ATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00\n"
"ATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00\n"
"ATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00\n"
"~~~"
msgstr ""
"~~~\n"
"ATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00\n"
"ATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00\n"
"ATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00\n"
"ATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00\n"
"ATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00\n"
"~~~"

#: shell-novice/_episodes/06-script.md:82
msgid ""
"Sure enough,\n"
"our script's output is exactly what we would get if we ran that pipeline directly."
msgstr ""
"Звісно,\n"
"вихідні дані нашого скрипта є саме тими, які ми отримали б, якби запустили цей конвеєр напряму."

# blockquote, which can be cascaded
#: shell-novice/_episodes/06-script.md:85
msgid "> ## Text vs. Whatever"
msgstr "> ## Текст проти Будь-чого іншого"

#: shell-novice/_episodes/06-script.md:86
msgid ""
">\n"
"> We usually call programs like Microsoft Word or LibreOffice Writer \"text\n"
"> editors\", but we need to be a bit more careful when it comes to\n"
"> programming. By default, Microsoft Word uses `.docx` files to store not\n"
"> only text, but also formatting information about fonts, headings, and so\n"
"> on. This extra information isn't stored as characters and doesn't mean\n"
"> anything to tools like `head`: they expect input files to contain\n"
"> nothing but the letters, digits, and punctuation on a standard computer\n"
"> keyboard. When editing programs, therefore, you must either use a plain\n"
"> text editor, or be careful to save files as plain text."
msgstr ""
">\n"
"> Зазвичай ми називаємо такі програми, як Microsoft Word або LibreOffice Writer, \"текстовими\n"
"> редакторами\", але потрібно бути трохи обережнішими, коли йдеться про\n"
"> програмування. За замовчуванням, Microsoft Word використовує файли `.docx` для зберігання не лише\n"
"> тексту, але й інформації про форматування.\n"
"> лише тексту, але й інформації про форматування: шрифти, заголовки\n"
"> тощо. Ця додаткова інформація не зберігається у вигляді символів і не означає\n"
"> нічого для інструментів типу `head`: вони очікують, що вхідні файли не міститимуть\n"
"> нічого, окрім літер, цифр і розділових знаків зі стандартної комп'ютерної\n"
"> клавіатури. Отже, при редагуванні програм вам слід або користуватися звичайним\n"
"> текстовий редактор, або обережно зберігати файли як звичайний текст."

#: shell-novice/_episodes/06-script.md:98
msgid ""
"What if we want to select lines from an arbitrary file?\n"
"We could edit `middle.sh` each time to change the filename,\n"
"but that would probably take longer than typing the command out again\n"
"in the shell and executing it with a new file name.\n"
"Instead, let's edit `middle.sh` and make it more versatile:"
msgstr ""
"А якщо ми хочемо вибрати рядки з довільного файлу?\n"
"Ми могли б редагувати `middle.sh` кожного разу, щоб змінити назву файлу,\n"
"але це, ймовірно, займе більше часу, ніж набрати команду знову\n"
"у командному рядку і виконати її з новим ім'ям файлу.\n"
"Замість цього давайте відредагуємо `middle.sh` і зробимо його більш універсальним:"

# code block
#: shell-novice/_episodes/06-script.md:104
#: shell-novice/_episodes/06-script.md:167
#: shell-novice/_episodes/06-script.md:214
msgid ""
"~~~\n"
"$ nano middle.sh\n"
"~~~"
msgstr ""
"~~~\n"
"$ nano middle.sh\n"
"~~~"

#: shell-novice/_episodes/06-script.md:109
msgid ""
"Now, within \"nano\", replace the text `octane.pdb` with the special "
"variable called `$1`:"
msgstr ""
"Тепер всередині \"nano\" замініть текст `octane.pdb` на спеціальну змінну з "
"назвою `$1`:"

# code block
#: shell-novice/_episodes/06-script.md:111
msgid ""
"~~~\n"
"head -n 15 \"$1\" | tail -n 5\n"
"~~~"
msgstr ""
"~~~\n"
"head -n 15 \"$1\" | tail -n 5\n"
"~~~"

#: shell-novice/_episodes/06-script.md:116
msgid ""
"Inside a shell script,\n"
"`$1` means 'the first filename (or other argument) on the command line'.\n"
"We can now run our script like this:"
msgstr ""
"Усередині скрипта терміналу\n"
"`$1` означає 'перше ім'я файлу (або інший аргумент) у командному рядку'.\n"
"Тепер ми можемо запустити наш скрипт таким чином:"

# code block
#: shell-novice/_episodes/06-script.md:120
msgid ""
"~~~\n"
"$ bash middle.sh octane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"$ bash middle.sh octane.pdb\n"
"~~~"

#: shell-novice/_episodes/06-script.md:134
msgid "or on a different file like this:"
msgstr "або передавши ім'я іншого файлу наступним чином:"

# code block
#: shell-novice/_episodes/06-script.md:136
msgid ""
"~~~\n"
"$ bash middle.sh pentane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"$ bash middle.sh pentane.pdb\n"
"~~~"

# code block
#: shell-novice/_episodes/06-script.md:141
#: shell-novice/_episodes/06-script.md:184
msgid ""
"~~~\n"
"ATOM      9  H           1       1.324   0.350  -1.332  1.00  0.00\n"
"ATOM     10  H           1       1.271   1.378   0.122  1.00  0.00\n"
"ATOM     11  H           1      -0.074  -0.384   1.288  1.00  0.00\n"
"ATOM     12  H           1      -0.048  -1.362  -0.205  1.00  0.00\n"
"ATOM     13  H           1      -1.183   0.500  -1.412  1.00  0.00\n"
"~~~"
msgstr ""
"~~~\n"
"ATOM      9  H           1       1.324   0.350  -1.332  1.00  0.00\n"
"ATOM     10  H           1       1.271   1.378   0.122  1.00  0.00\n"
"ATOM     11  H           1      -0.074  -0.384   1.288  1.00  0.00\n"
"ATOM     12  H           1      -0.048  -1.362  -0.205  1.00  0.00\n"
"ATOM     13  H           1      -1.183   0.500  -1.412  1.00  0.00\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/06-script.md:150
msgid "> ## Double-Quotes Around Arguments"
msgstr "> ## Подвійні лапки навколо аргументів"

#: shell-novice/_episodes/06-script.md:151
msgid ""
">\n"
"> For the same reason that we put the loop variable inside double-quotes,\n"
"> in case the filename happens to contain any spaces,\n"
"> we surround `$1` with double-quotes."
msgstr ""
">\n"
"> З тієї ж причини, з якої ми взяли змінну циклу у подвійні лапки,\n"
"> на випадок, якщо ім'я файлу містить пробіли,\n"
"> ми беремо `$1` у подвійні лапки."

#: shell-novice/_episodes/06-script.md:157
msgid ""
"Currently, we need to edit `middle.sh` each time we want to adjust the range of\n"
"lines that is returned.\n"
"Let's fix that by configuring our script to instead use three command-line arguments.\n"
"After the first command-line argument (`$1`), each additional argument that we\n"
"provide will be accessible via the special variables `$1`, `$2`, `$3`,\n"
"which refer to the first, second, third command-line arguments, respectively."
msgstr ""
"Наразі нам потрібно редагувати `middle.sh` кожного разу, коли ми хочемо змінити діапазон\n"
"рядків, які повертаються.\n"
"Давайте виправимо це, налаштувавши наш скрипт на використання трьох аргументів командного рядка.\n"
"Після першого аргументу командного рядка (`$1`), кожен наступний аргумент, який ми\n"
"надаємо, буде доступний через спеціальні змінні `$1`, `$2`, `$3`,\n"
"які посилаються на перший, другий і третій аргументи командного рядка відповідно."

#: shell-novice/_episodes/06-script.md:164
msgid ""
"Knowing this, we can use additional arguments to define the range of lines to\n"
"be passed to `head` and `tail` respectively:"
msgstr ""
"Знаючи це, ми можемо використовувати додаткові аргументи для визначення діапазону рядків, які\n"
"передавати до `head` та `tail` відповідно:"

# code block
#: shell-novice/_episodes/06-script.md:172
msgid ""
"~~~\n"
"head -n \"$2\" \"$1\" | tail -n \"$3\"\n"
"~~~"
msgstr ""
"~~~\n"
"head -n \"$2\" \"$1\" | tail -n \"$3\"\n"
"~~~"

#: shell-novice/_episodes/06-script.md:177
msgid "We can now run:"
msgstr "Тепер ми можемо запустити:"

# code block
#: shell-novice/_episodes/06-script.md:179
msgid ""
"~~~\n"
"$ bash middle.sh pentane.pdb 15 5\n"
"~~~"
msgstr ""
"~~~\n"
"$ bash middle.sh pentane.pdb 15 5\n"
"~~~"

#: shell-novice/_episodes/06-script.md:193
msgid ""
"By changing the arguments to our command we can change our script's\n"
"behaviour:"
msgstr ""
"Змінюючи аргументи нашої команди, ми можемо змінювати\n"
"поведінку нашого скрипта:"

# code block
#: shell-novice/_episodes/06-script.md:196
msgid ""
"~~~\n"
"$ bash middle.sh pentane.pdb 20 5\n"
"~~~"
msgstr ""
"~~~\n"
"$ bash middle.sh pentane.pdb 20 5\n"
"~~~"

# code block
#: shell-novice/_episodes/06-script.md:201
msgid ""
"~~~\n"
"ATOM     14  H           1      -1.259   1.420   0.112  1.00  0.00\n"
"ATOM     15  H           1      -2.608  -0.407   1.130  1.00  0.00\n"
"ATOM     16  H           1      -2.540  -1.303  -0.404  1.00  0.00\n"
"ATOM     17  H           1      -3.393   0.254  -0.321  1.00  0.00\n"
"TER      18              1\n"
"~~~"
msgstr ""
"~~~\n"
"ATOM     14  H           1      -1.259   1.420   0.112  1.00  0.00\n"
"ATOM     15  H           1      -2.608  -0.407   1.130  1.00  0.00\n"
"ATOM     16  H           1      -2.540  -1.303  -0.404  1.00  0.00\n"
"ATOM     17  H           1      -3.393   0.254  -0.321  1.00  0.00\n"
"TER      18              1\n"
"~~~"

#: shell-novice/_episodes/06-script.md:210
msgid ""
"This works,\n"
"but it may take the next person who reads `middle.sh` a moment to figure out what it does.\n"
"We can improve our script by adding some **comments** at the top:"
msgstr ""
"Це працює,\n"
"але наступній людині, яка прочитає `middle.sh`, може знадобитися деякий час, щоб зрозуміти, що він робить.\n"
"Ми можемо покращити наш скрипт, додавши деякі **коментарі** зверху:"

# code block
#: shell-novice/_episodes/06-script.md:219
msgid ""
"~~~\n"
"# Select lines from the middle of a file.\n"
"# Usage: bash middle.sh filename end_line num_lines\n"
"head -n \"$2\" \"$1\" | tail -n \"$3\"\n"
"~~~"
msgstr ""
"~~~\n"
"# Виділення рядків з середини файлу.\n"
"# Використання: bash middle.sh filename end_line num_lines\n"
"head -n \"$2\" \"$1\" | tail -n \"$3\"\n"
"~~~"

#: shell-novice/_episodes/06-script.md:226
msgid ""
"A comment starts with a `#` character and runs to the end of the line.\n"
"The computer ignores comments,\n"
"but they're invaluable for helping people (including your future self) understand and use scripts.\n"
"The only caveat is that each time you modify the script,\n"
"you should check that the comment is still accurate:\n"
"an explanation that sends the reader in the wrong direction is worse than none at all."
msgstr ""
"Коментар починається з символу `#` і продовжується до кінця рядка.\n"
"Комп'ютер ігнорує коментарі,\n"
"але вони безцінні, оскільки допомагають людям (у тому числі і вам самим у майбутньому) розуміти і використовувати скрипти.\n"
"Єдине застереження полягає у тому, що кожного разу, коли ви змінюєте скрипт,\n"
"ви повинні перевіряти, що коментар все ще правильний:\n"
"Пояснення, яке спрямовує читача в неправильному напрямку, гірше, ніж його відсутність."

#: shell-novice/_episodes/06-script.md:233
msgid ""
"What if we want to process many files in a single pipeline?\n"
"For example, if we want to sort our `.pdb` files by length, we would type:"
msgstr ""
"Що робити, якщо ми хочемо обробити багато файлів в одному конвеєрі?\n"
"Наприклад, якщо ми хочемо відсортувати наші `.pdb`-файли за довжиною, ми введемо:"

#: shell-novice/_episodes/06-script.md:241
msgid ""
"because `wc -l` lists the number of lines in the files\n"
"(recall that `wc` stands for 'word count', adding the `-l` option means 'count lines' instead)\n"
"and `sort -n` sorts things numerically.\n"
"We could put this in a file,\n"
"but then it would only ever sort a list of `.pdb` files in the current directory.\n"
"If we want to be able to get a sorted list of other kinds of files,\n"
"we need a way to get all those names into the script.\n"
"We can't use `$1`, `$2`, and so on\n"
"because we don't know how many files there are.\n"
"Instead, we use the special variable `$@`,\n"
"which means,\n"
"'All of the command-line arguments to the shell script'.\n"
"We also should put `$@` inside double-quotes\n"
"to handle the case of arguments containing spaces\n"
"(`\"$@\"` is special syntax and is equivalent to `\"$1\"` `\"$2\"` ...)."
msgstr ""
"оскільки `wc -l` виводить кількість рядків у файлах\n"
"(нагадаю, що `wc` означає 'підрахунок слів', додавання опції `-l` означає 'підрахунок рядків')\n"
"і `sort -n` сортує речі числовим способом.\n"
"Ми можемо записати це у файл,\n"
"але тоді він сортуватиме лише список файлів `.pdb` у поточному каталозі.\n"
"Якщо ми хочемо отримати відсортований список інших типів файлів,\n"
"нам потрібен спосіб вставити всі ці імена у скрипт.\n"
"Ми не можемо використовувати `$1`, `$2` і так далі\n"
"тому що ми не знаємо, скільки файлів існує.\n"
"Замість цього ми використовуємо спеціальну змінну `$@`,\n"
"що означає,\n"
"\"Всі аргументи командного рядка для скрипта терміналу\".\n"
"Ми також повинні взяти `$@` у подвійні лапки\n"
"щоб врахувати випадок, коли аргументи містять пробіли\n"
"(`\"$@\"` є спеціальним синтаксисом і він еквівалентний `\"$1\"` `\"$2\"` ...)."

#: shell-novice/_episodes/06-script.md:257
msgid "Here's an example:"
msgstr "Ось приклад:"

# code block
#: shell-novice/_episodes/06-script.md:259
msgid ""
"~~~\n"
"$ nano sorted.sh\n"
"~~~"
msgstr ""
"~~~\n"
"$ nano sorted.sh\n"
"~~~"

# code block
#: shell-novice/_episodes/06-script.md:264
msgid ""
"~~~\n"
"# Sort files by their length.\n"
"# Usage: bash sorted.sh one_or_more_filenames\n"
"wc -l \"$@\" | sort -n\n"
"~~~"
msgstr ""
"~~~\n"
"# Сортує файли за їх розміром.\n"
"# Використання: bash sorted.sh one_or_more_filenames\n"
"wc -l \"$@\" | sort -n\n"
"~~~"

# code block
#: shell-novice/_episodes/06-script.md:271
msgid ""
"~~~\n"
"$ bash sorted.sh *.pdb ../creatures/*.dat\n"
"~~~"
msgstr ""
"~~~\n"
"$ bash sorted.sh *.pdb ../creatures/*.dat\n"
"~~~"

# code block
#: shell-novice/_episodes/06-script.md:276
msgid ""
"~~~\n"
"9 methane.pdb\n"
"12 ethane.pdb\n"
"15 propane.pdb\n"
"20 cubane.pdb\n"
"21 pentane.pdb\n"
"30 octane.pdb\n"
"163 ../creatures/basilisk.dat\n"
"163 ../creatures/minotaur.dat\n"
"163 ../creatures/unicorn.dat\n"
"596 total\n"
"~~~"
msgstr ""
"~~~\n"
"9 methane.pdb\n"
"12 ethane.pdb\n"
"15 propane.pdb\n"
"20 cubane.pdb\n"
"21 pentane.pdb\n"
"30 octane.pdb\n"
"163 ../creatures/basilisk.dat\n"
"163 ../creatures/minotaur.dat\n"
"163 ../creatures/unicorn.dat\n"
"596 total\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/06-script.md:290
msgid "> ## List Unique Species"
msgstr "> ## Перелік унікальних видів"

#: shell-novice/_episodes/06-script.md:291
msgid ""
">\n"
"> Leah has several hundred data files, each of which is formatted like this:\n"
">\n"
"> ~~~\n"
"> 2013-11-05,deer,5\n"
"> 2013-11-05,rabbit,22\n"
"> 2013-11-05,raccoon,7\n"
"> 2013-11-06,rabbit,19\n"
"> 2013-11-06,deer,2\n"
"> 2013-11-06,fox,1\n"
"> 2013-11-07,rabbit,18\n"
"> 2013-11-07,bear,1\n"
"> ~~~"
msgstr ""
">\n"
"> Лія має кілька сотень файлів даних, кожен з яких відформатований наступним чином:\n"
">\n"
"> ~~~\n"
"> 2013-11-05,deer,5\n"
"> 2013-11-05,rabbit,22\n"
"> 2013-11-05,raccoon,7\n"
"> 2013-11-06,rabbit,19\n"
"> 2013-11-06,deer,2\n"
"> 2013-11-06,fox,1\n"
"> 2013-11-07,rabbit,18\n"
"> 2013-11-07,bear,1\n"
"> ~~~"

#: shell-novice/_episodes/06-script.md:305
msgid ""
">\n"
"> An example of this type of file is given in\n"
"> `shell-lesson-data/exercise-data/animal-counts/animals.csv`.\n"
">\n"
"> We can use the command `cut -d , -f 2 animals.csv | sort | uniq` to produce\n"
"> the unique species in `animals.csv`.\n"
"> In order to avoid having to type out this series of commands every time,\n"
"> a scientist may choose to write a shell script instead.\n"
">\n"
"> Write a shell script called `species.sh` that takes any number of\n"
"> filenames as command-line arguments, and uses a variation of the above command\n"
"> to print a list of the unique species appearing in each of those files separately.\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ```\n"
"> > # Script to find unique species in csv files where species is the second data field\n"
"> > # This script accepts any number of file names as command line arguments\n"
"> >\n"
"> > # Loop over all files\n"
"> > for file in $@\n"
"> > do\n"
"> >     echo \"Unique species in $file:\"\n"
"> >     # Extract species names\n"
"> >     cut -d , -f 2 $file | sort | uniq\n"
"> > done\n"
"> > ```\n"
"> > {: .language-bash}"
msgstr ""
">\n"
"> Приклад файлу такого типу наведено у\n"
"> `shell-lesson-data/exercise-data/animal-counts/animals.сcsv`.\n"
">\n"
"> Ми можемо скористатися командою `cut -d , -f 2 animals.csv | sort | uniq`, щоб отримати\n"
"> унікальні види у файлі `animals.csv`.\n"
"> Щоб уникнути необхідності кожного разу вводити цю серію команд,\n"
"> науковець може замість цього написати скрипт командного інтерпретатора.\n"
">\n"
"> Напишіть сценарій командного рядка з назвою `species.sh`, який приймає довільну кількість\n"
"> імен файлів як аргументи командного рядка і використовує варіацію наведеної вище команди\n"
"> для виведення списку унікальних видів, що з'являються у кожному з цих файлів окремо.\n"
">\n"
"> > > ## Розв'язання\n"
"> >\n"
"> > ```\n"
"> > # Скрипт для пошуку унікальних видів у csv-файлах, де вид є другим полем даних\n"
"> > # Цей скрипт приймає будь-яку кількість імен файлів як аргументи командного рядка\n"
"> >\n"
"> > # Перебір всіх файлів\n"
"> > for file in $@\n"
"> > do\n"
"> > echo \"Unique species in $file:\"\n"
"> > # Отримати назви видів\n"
"> > cut -d , -f 2 $file | sort | uniq\n"
"> > done\n"
"> > ```\n"
"> > {: .language-bash}"

#: shell-novice/_episodes/06-script.md:337
msgid ""
"Suppose we have just run a series of commands that did something useful --- for example,\n"
"that created a graph we'd like to use in a paper.\n"
"We'd like to be able to re-create the graph later if we need to,\n"
"so we want to save the commands in a file.\n"
"Instead of typing them in again\n"
"(and potentially getting them wrong)\n"
"we can do this:"
msgstr ""
"Припустимо, ми щойно виконали низку команд, які зробили щось корисне --- наприклад,\n"
"створили графік, який ми хотіли б використати у роботі.\n"
"Ми хотіли б мати можливість відновити графік пізніше, якщо це буде потрібно,\n"
"тому ми хочемо зберегти команди у файлі.\n"
"Замість того, щоб вводити їх знову\n"
"(і, можливо, зробити помилки)\n"
"ми можемо зробити так:"

# code block
#: shell-novice/_episodes/06-script.md:345
msgid ""
"~~~\n"
"$ history | tail -n 5 > redo-figure-3.sh\n"
"~~~"
msgstr ""
"~~~\n"
"$ history | tail -n 5 > redo-figure-3.sh\n"
"~~~"

#: shell-novice/_episodes/06-script.md:350
msgid "The file `redo-figure-3.sh` now contains:"
msgstr "Файл `redo-figure-3.sh` тепер містить наступне:"

# code block
#: shell-novice/_episodes/06-script.md:352
msgid ""
"~~~\n"
"297 bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n"
"298 bash goodiff.sh stats-NENE01729B.txt /data/validated/01729.txt > 01729-differences.txt\n"
"299 cut -d ',' -f 2-3 01729-differences.txt > 01729-time-series.txt\n"
"300 ygraph --format scatter --color bw --borders none 01729-time-series.txt figure-3.png\n"
"301 history | tail -n 5 > redo-figure-3.sh\n"
"~~~"
msgstr ""
"~~~\n"
"297 bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n"
"298 bash goodiff.sh stats-NENE01729B.txt /data/validated/01729.txt > 01729-differences.txt\n"
"299 cut -d ',' -f 2-3 01729-differences.txt > 01729-time-series.txt\n"
"300 ygraph --format scatter --color bw --borders none 01729-time-series.txt figure-3.png\n"
"301 history | tail -n 5 > redo-figure-3.sh\n"
"~~~"

#: shell-novice/_episodes/06-script.md:361
msgid ""
"After a moment's work in an editor to remove the serial numbers on the commands,\n"
"and to remove the final line where we called the `history` command,\n"
"we have a completely accurate record of how we created that figure."
msgstr ""
"Після невеликої роботи в редакторі з прибирання послідовних номерів на командах\n"
"і видалення останнього рядка, де ми викликали команду `history`,\n"
"ми отримаємо абсолютно точний запис того, як ми створили цю фігуру."

# blockquote, which can be cascaded
#: shell-novice/_episodes/06-script.md:365
msgid "> ## Why Record Commands in the History Before Running Them?"
msgstr "> ## Навіщо записувати команди в історію перед виконанням?"

#: shell-novice/_episodes/06-script.md:366
msgid ""
">\n"
"> If you run the command:\n"
">\n"
"> ~~~\n"
"> $ history | tail -n 5 > recent.sh\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> the last command in the file is the `history` command itself, i.e.,\n"
"> the shell has added `history` to the command log before actually\n"
"> running it. In fact, the shell *always* adds commands to the log\n"
"> before running them. Why do you think it does this?\n"
">\n"
"> > ## Solution\n"
"> > If a command causes something to crash or hang, it might be useful\n"
"> > to know what that command was, in order to investigate the problem.\n"
"> > Were the command only be recorded after running it, we would not\n"
"> > have a record of the last command run in the event of a crash."
msgstr ""
">\n"
"> Якщо виконати команду:\n"
">\n"
"> ~~~\n"
"> $ history | tail -n 5 > recent.sh\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> останньою командою у файлі є сама команда `history`, тобто,\n"
"> термінал додав `history` до журналу команд перед тим, як фактично\n"
"> її виконав. Насправді, термінал *завжди* додає команди до журналу\n"
"> перед їх виконанням. Як ви гадаєте, чому він це робить?\n"
">\n"
"> > ## Розв'язання\n"
"> > Якщо якась команда спричинила збій або зависання, може бути корисно\n"
"> > знати, що це була за команда, щоб дослідити проблему.\n"
"> > Якби команда записувалася лише після запуску, ми б\n"
"> > не мали запису останньої запущеної команди у випадку аварійного завершення роботи."

#: shell-novice/_episodes/06-script.md:387
msgid ""
"In practice, most people develop shell scripts by running commands at the shell prompt a few times\n"
"to make sure they're doing the right thing,\n"
"then saving them in a file for re-use.\n"
"This style of work allows people to recycle\n"
"what they discover about their data and their workflow with one call to `history`\n"
"and a bit of editing to clean up the output\n"
"and save it as a shell script."
msgstr ""
"На практиці більшість людей розробляють скрипти терміналу, запускаючи команди в командному рядку кілька разів,\n"
"щоб переконатися, що вони роблять все правильно,\n"
"а потім зберігають їх у файлі для повторного використання.\n"
"Такий стиль роботи дозволяє людям переробляти\n"
"те, що вони дізнаються про свої дані і робочий процес, одним викликом команди `history`\n"
"і невеликим редагуванням, щоб очистити результат\n"
"і зберегти його як скрипт терміналу."

# header
#: shell-novice/_episodes/06-script.md:395
msgid "## Nelle's Pipeline: Creating a Script"
msgstr "## Конвеєр Неллі: Створення скрипту"

#: shell-novice/_episodes/06-script.md:398
msgid ""
"Nelle's supervisor insisted that all her analytics must be reproducible.\n"
"The easiest way to capture all the steps is in a script."
msgstr ""
"Керівник Неллі наполягав на тому, що вся її аналітика має бути відтворюваною.\n"
"Найпростіший спосіб зафіксувати всі кроки - написати сценарій."

#: shell-novice/_episodes/06-script.md:401
msgid ""
"First we return to Nelle's project directory:\n"
"```\n"
"$ cd ../../north-pacific-gyre/\n"
"```\n"
"{: .language-bash}"
msgstr ""
"Спочатку повернемося до каталогу проектів Неллі:\n"
"```\n"
"$ cd ../../north-pacific-gyre/\n"
"```\n"
"{: .language-bash}"

#: shell-novice/_episodes/06-script.md:407
msgid "She creates a file using `nano` ..."
msgstr "Вона створює файл з використанням `nano` ..."

# code block
#: shell-novice/_episodes/06-script.md:409
msgid ""
"~~~\n"
"$ nano do-stats.sh\n"
"~~~"
msgstr ""
"~~~\n"
"$ nano do-stats.sh\n"
"~~~"

#: shell-novice/_episodes/06-script.md:414
msgid "...which contains the following:"
msgstr "...який містить наступне:"

# code block
#: shell-novice/_episodes/06-script.md:416
msgid ""
"~~~\n"
"# Calculate stats for data files.\n"
"for datafile in \"$@\"\n"
"do\n"
"    echo $datafile\n"
"    bash goostats.sh $datafile stats-$datafile\n"
"done\n"
"~~~"
msgstr ""
"~~~\n"
"# Розрахунок статистики для файлів даних.\n"
"for datafile in \"$@\"\n"
"do\n"
"    echo $datafile\n"
"    bash goostats.sh $datafile stats-$datafile\n"
"done\n"
"~~~"

#: shell-novice/_episodes/06-script.md:426
msgid ""
"She saves this in a file called `do-stats.sh`\n"
"so that she can now re-do the first stage of her analysis by typing:"
msgstr ""
"Вона зберігає його у файлі з назвою `do-stats.sh`.\n"
"щоб тепер вона могла повторити перший етап аналізу шляхом введення:"

# code block
#: shell-novice/_episodes/06-script.md:429
msgid ""
"~~~\n"
"$ bash do-stats.sh NENE*A.txt NENE*B.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ bash do-stats.sh NENE*A.txt NENE*B.txt\n"
"~~~"

#: shell-novice/_episodes/06-script.md:434
msgid "She can also do this:"
msgstr "Вона також може зробити наступне:"

# code block
#: shell-novice/_episodes/06-script.md:436
msgid ""
"~~~\n"
"$ bash do-stats.sh NENE*A.txt NENE*B.txt | wc -l\n"
"~~~"
msgstr ""
"~~~\n"
"$ bash do-stats.sh NENE*A.txt NENE*B.txt | wc -l\n"
"~~~"

#: shell-novice/_episodes/06-script.md:441
msgid ""
"so that the output is just the number of files processed\n"
"rather than the names of the files that were processed."
msgstr ""
"щоб вивести лише кількість оброблених файлів\n"
"а не імена файлів, які було оброблено."

#: shell-novice/_episodes/06-script.md:444
msgid ""
"One thing to note about Nelle's script is that\n"
"it lets the person running it decide what files to process.\n"
"She could have written it as:"
msgstr ""
"У скрипті Неллі є одна особливість, яку слід відзначити,\n"
"він дозволяє користувачеві, який його запускає, вирішувати, які файли обробляти.\n"
"Вона могла б написати його так:"

# code block
#: shell-novice/_episodes/06-script.md:448
msgid ""
"~~~\n"
"# Calculate stats for Site A and Site B data files.\n"
"for datafile in NENE*A.txt NENE*B.txt\n"
"do\n"
"    echo $datafile\n"
"    bash goostats.sh $datafile stats-$datafile\n"
"done\n"
"~~~"
msgstr ""
"~~~\n"
"# Обчисліть статистику для файлів даних A та B.\n"
"for datafile in NENE*A.txt NENE*B.txt\n"
"do\n"
"    echo $datafile\n"
"    bash goostats.sh $datafile stats-$datafile\n"
"done\n"
"~~~"

#: shell-novice/_episodes/06-script.md:458
msgid ""
"The advantage is that this always selects the right files:\n"
"she doesn't have to remember to exclude the 'Z' files.\n"
"The disadvantage is that it *always* selects just those files --- she can't run it on all files\n"
"(including the 'Z' files),\n"
"or on the 'G' or 'H' files her colleagues in Antarctica are producing,\n"
"without editing the script.\n"
"If she wanted to be more adventurous,\n"
"she could modify her script to check for command-line arguments,\n"
"and use `NENE*A.txt NENE*B.txt` if none were provided.\n"
"Of course, this introduces another tradeoff between flexibility and complexity."
msgstr ""
"Перевага полягає в тому, що вона завжди вибирає правильні файли:\n"
"їй не потрібно пам'ятати, що потрібно виключити файли з літерою 'Z'.\n"
"Недоліком є те, що вона *завжди* вибирає лише ці файли --- вона не може запустити її на всіх файлах\n"
"(включно з файлами 'Z'),\n"
"або на файлах 'G' чи 'H', які створюють її колеги в Антарктиді,\n"
"без редагування сценарію.\n"
"Якби вона хотіла бути більш сміливою,\n"
"вона могла б модифікувати свій скрипт для перевірки аргументів командного рядка,\n"
"і використовувати `NENE*A.txt NENE*B.txt`, якщо нічого не було передано.\n"
"Звичайно, це ще один компроміс між гнучкістю і складністю."

# blockquote, which can be cascaded
#: shell-novice/_episodes/06-script.md:469
msgid "> ## Variables in Shell Scripts"
msgstr "> ## Змінні в скриптах терміналу"

#: shell-novice/_episodes/06-script.md:470
msgid ""
">\n"
"> In the `proteins` directory, imagine you have a shell script called `script.sh` containing the\n"
"> following commands:\n"
">\n"
"> ~~~\n"
"> head -n $2 $1\n"
"> tail -n $3 $1\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> While you are in the `proteins` directory, you type the following command:\n"
">\n"
"> ~~~\n"
"> $ bash script.sh '*.pdb' 1 1\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Which of the following outputs would you expect to see?\n"
">\n"
"> 1. All of the lines between the first and the last lines of each file ending in `.pdb`\n"
">    in the `proteins` directory\n"
"> 2. The first and the last line of each file ending in `.pdb` in the `proteins` directory\n"
"> 3. The first and the last line of each file in the `proteins` directory\n"
"> 4. An error because of the quotes around `*.pdb`\n"
">\n"
"> > ## Solution\n"
"> > The correct answer is 2.\n"
"> >\n"
"> > The special variables $1, $2 and $3 represent the command line arguments given to the\n"
"> > script, such that the commands run are:\n"
"> >\n"
"> > ```\n"
"> > $ head -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\n"
"> > $ tail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> > The shell does not expand `'*.pdb'` because it is enclosed by quote marks.\n"
"> > As such, the first argument to the script is `'*.pdb'` which gets expanded within the\n"
"> > script by `head` and `tail`."
msgstr ""
">\n"
"> Уявіть, що у каталозі `proteins` у вас є скрипт терміналу з назвою `script.sh`, який містить\n"
"> наступні команди:>\n"
"> ~~~\n"
"> head -n $2 $1\n"
"> tail -n $3 $1\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Перебуваючи у каталозі `proteins`, ви вводите наступну команду:\n"
">\n"
"> ~~~\n"
"> $ bash script.sh '*.pdb' 1 1\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Які з наведених нижче результатів ви очікуєте побачити?\n"
">\n"
"> 1. Усі рядки між першим та останнім рядками кожного файлу, що закінчуються на `.pdb`\n"
"> у каталозі `proteins`.\n"
"> 2. Перший та останній рядок кожного файлу, що закінчується на `.pdb` у каталозі `proteins`.\n"
"> 3. Перший та останній рядок кожного файлу в каталозі `proteins`.\n"
"> 4. Помилка через лапки навколо `*.pdb`.\n"
">\n"
"> > ## Розв'язання\n"
"> > Правильна відповідь 2.\n"
"> >\n"
"> > Спеціальні змінні $1, $2 і $3 представляють аргументи командного рядка, що передаються\n"
"> > скрипту, таким чином команди, що виконуються, виглядають так:\n"
"> >\n"
"> > ```\n"
"> > $ head -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\n"
"> > $ tail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> > Термынал не розгортає `'*.pdb'`, оскільки його взято у лапки.\n"
"> > Таким чином, першим аргументом скрипту є `'*.pdb'`, який буде розгорнуто у\n"
"> > скрипті за допомогою `head` і `tail`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/06-script.md:512
msgid "> ## Find the Longest File With a Given Extension"
msgstr "> ## Пошук найдовшого файлу із заданим розширенням"

#: shell-novice/_episodes/06-script.md:513
msgid ""
">\n"
"> Write a shell script called `longest.sh` that takes the name of a\n"
"> directory and a filename extension as its arguments, and prints\n"
"> out the name of the file with the most lines in that directory\n"
"> with that extension. For example:\n"
">\n"
"> ~~~\n"
"> $ bash longest.sh shell-lesson-data/exercise-data/proteins pdb\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> would print the name of the `.pdb` file in `shell-lesson-data/exercise-data/proteins` that has\n"
"> the most lines.\n"
">\n"
"> Feel free to test your script on another directory e.g.\n"
"> ~~~\n"
"> $ bash longest.sh shell-lesson-data/exercise-data/writing txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ```\n"
"> > # Shell script which takes two arguments:\n"
"> > #    1. a directory name\n"
"> > #    2. a file extension\n"
"> > # and prints the name of the file in that directory\n"
"> > # with the most lines which matches the file extension.\n"
"> >\n"
"> > wc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> >\n"
"> > The first part of the pipeline, `wc -l $1/*.$2 | sort -n`, counts\n"
"> > the lines in each file and sorts them numerically (largest last). When\n"
"> > there's more than one file, `wc` also outputs a final summary line,\n"
"> > giving the total number of lines across _all_ files.  We use `tail\n"
"> > -n 2 | head -n 1` to throw away this last line.\n"
"> >\n"
"> > With `wc -l $1/*.$2 | sort -n | tail -n 1` we'll see the final summary\n"
"> > line: we can build our pipeline up in pieces to be sure we understand\n"
"> > the output."
msgstr ""
">\n"
"> Напишіть сценарій терміналу з назвою `longest.sh`, який отримує в якості аргументів ім'я\n"
"> каталогу і розширення імені файлу як аргументи, і виводить\n"
"> назву файлу з найбільшою кількістю рядків у цьому каталозі\n"
"> з цим розширенням. Наприклад:\n"
">\n"
"> ~~~\n"
"> $ bash longest.sh shell-lesson-data/exercise-data/proteins pdb\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> виведе назву файлу `.pdb` у каталозі `shell-lesson-data/exercise-data/proteins`, який має\n"
"> найбільшу кількість рядків.\n"
">\n"
"> Не соромтеся тестувати свій скрипт в іншому каталозі, наприклад\n"
"> ~~~\n"
"> $ bash longest.sh shell-lesson-data/exercise-data/writing txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Розв'язання\n"
"> >\n"
"> > ```\n"
"> > # Скрипт терміналу, який приймає два аргументи:\n"
"> > #    1. ім'я каталогу\n"
"> > #    2. розширення файлу\n"
"> > # і виводить ім'я файлу в цьому каталозі\n"
"> > # з найбільшою кількістю рядків, що відповідаює розширенню файлу.\n"
"> >\n"
"> > wc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> >\n"
"> > Перша частина конвеєра, `wc -l $1/*.$2 | sort -n`, підраховує\n"
"> рядки у кожному файлі і сортує їх за числом (найбільший в останню чергу). Якщо\n"
"> > файлів більше одного, `wc` також виводить останній підсумковий рядок,\n"
"> який показує загальну кількість рядків у _усіх_ файлах. Ми використовуємо `tail`\n"
"> > -n 2 | head -n 1`, щоб відкинути цей останній рядок.\n"
"> >\n"
"> > За допомогою `wc -l $1/*.$2 | sort -n | tail -n 1` ми побачимо остаточний підсумковий\n"
"> > рядок: ми можемо побудувати наш конвеєр по частинах, щоб бути впевненими, що розуміємо,\n"
"> що ми отримаємо на виході."

# blockquote, which can be cascaded
#: shell-novice/_episodes/06-script.md:558
msgid "> ## Script Reading Comprehension"
msgstr "> ## Розуміння читання скрипту"

#: shell-novice/_episodes/06-script.md:559
msgid ""
">\n"
"> For this question, consider the `shell-lesson-data/exercise-data/proteins` directory once again.\n"
"> This contains a number of `.pdb` files in addition to any other files you\n"
"> may have created.\n"
"> Explain what each of the following three scripts would do when run as\n"
"> `bash script1.sh *.pdb`, `bash script2.sh *.pdb`, and `bash script3.sh *.pdb` respectively.\n"
">\n"
"> ~~~\n"
"> # Script 1\n"
"> echo *.*\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> # Script 2\n"
"> for filename in $1 $2 $3\n"
"> do\n"
">     cat $filename\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> # Script 3\n"
"> echo $@.pdb\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Solutions\n"
"> > In each case, the shell expands the wildcard in `*.pdb` before passing the resulting\n"
"> > list of file names as arguments to the script.\n"
"> >\n"
"> > Script 1 would print out a list of all files containing a dot in their name.\n"
"> > The arguments passed to the script are not actually used anywhere in the script.\n"
"> >\n"
"> > Script 2 would print the contents of the first 3 files with a `.pdb` file extension.\n"
"> > `$1`, `$2`, and `$3` refer to the first, second, and third argument respectively.\n"
"> >\n"
"> > Script 3 would print all the arguments to the script (i.e. all the `.pdb` files),\n"
"> > followed by `.pdb`.\n"
"> > `$@` refers to *all* the arguments given to a shell script.\n"
"> > ```\n"
"> > cubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb\n"
"> > ```\n"
"> > {: .output}"
msgstr ""
">\n"
"> Для відповіді на це запитання ще раз розглянемо каталог `shell-lesson-data/exercise-data/proteins`.\n"
"> У ньому міститься низка файлів `.pdb` на додачу до інших файлів, які\n"
"> ви могли створити.\n"
"> Поясніть, що зробить кожен з наступних трьох скриптів, якщо його буде запущено як:\n"
"> `bash script1.sh *.pdb`, `bash script2.sh *.pdb` та`bash script3.sh *.pdb` відповідно.\n"
">\n"
"> ~~~\n"
"> # Скрипт 1\n"
"> echo *.*\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> # Скрипт 2\n"
"> for filename in $1 $2 $3\n"
"> do\n"
">     cat $filename\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> # Скрипт 3\n"
"> echo $@.pdb\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Розв'язання\n"
"> > У кожному випадку термінал розгортає символ підстановки у `*.pdb` перед тим, як передати отриманий\n"
"> > список назв файлів як аргументи скрипту.\n"
"> >\n"
"> > Скрипт 1 виведе список усіх файлів, що містять крапку у назві.\n"
"> Аргументи, що передаються скрипту, насправді ніде не використовуються у скрипті.\n"
"> >\n"
"> > Скрипт 2 виведе вміст перших 3 файлів з розширенням `.pdb`.\n"
"> > `$1`, `$2` і `$3` відносяться до першого, другого і третього аргументу відповідно.\n"
"> >\n"
"> > Скрипт 3 виведе всі аргументи скрипту (тобто всі файли `.pdb`),\n"
"> > за якими слідує `.pdb`.\n"
"> > `$@` відноситься до *усіх* аргументів, переданих командному рядку.\n"
"> > ```\n"
"> > cubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb\n"
"> > ```\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/06-script.md:607
msgid "> ## Debugging Scripts"
msgstr "> ## Зневадження скриптів"

#: shell-novice/_episodes/06-script.md:608
msgid ""
">\n"
"> Suppose you have saved the following script in a file called `do-errors.sh`\n"
"> in Nelle's `north-pacific-gyre/scripts` directory:\n"
">\n"
"> ~~~\n"
"> # Calculate stats for data files.\n"
"> for datafile in \"$@\"\n"
"> do\n"
">     echo $datfile\n"
">     bash goostats.sh $datafile stats-$datafile\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> When you run it from the `north-pacific-gyre` directory:\n"
">\n"
"> ~~~\n"
"> $ bash do-errors.sh NENE*A.txt NENE*B.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> the output is blank.\n"
"> To figure out why, re-run the script using the `-x` option:\n"
">\n"
"> ~~~\n"
"> $ bash -x do-errors.sh NENE*A.txt NENE*B.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> What is the output showing you?\n"
"> Which line is responsible for the error?\n"
">\n"
"> > ## Solution\n"
"> > The `-x` option causes `bash` to run in debug mode.\n"
"> > This prints out each command as it is run, which will help you to locate errors.\n"
"> > In this example, we can see that `echo` isn't printing anything. We have made a typo\n"
"> > in the loop variable name, and the variable `datfile` doesn't exist, hence returning\n"
"> > an empty string."
msgstr ""
">\n"
"> Припустимо, ви зберегли наступний скрипт у файлі з назвою `do-errors.sh`\n"
"> у каталозі Неллі `north-pacific-gyre/scripts`:>\n"
"> ~~~\n"
"> # Розрахунок статистики для файлів даних.\n"
"> for datafile in \"$@\"\n"
"> do\n"
">     echo $datfile\n"
">     bash goostats.sh $datafile stats-$datafile\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Якщо ви запускаєте його з каталогу `north-pacific-gyre`:\n"
">\n"
"> ~~~\n"
"> $ bash do-errors.sh NENE*A.txt NENE*B.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> програма нічого не виводить.\n"
"> Щоб з'ясувати причину, перезапустіть скрипт з опцією `-x`:\n"
">\n"
"> ~~~\n"
"> $ bash -x do-errors.sh NENE*A.txt NENE*B.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Що показує вивід?\n"
"> Який рядок відповідає за помилку?\n"
">\n"
"> > ## Розв'язання\n"
"> > Параметр `-x` призводить до запуску `bash` у режимі відлагодження (зневадження).\n"
"> > У цьому випадку кожна команда буде виводитися на екран під час виконання, що допоможе вам знайти помилки.\n"
"> > У цьому прикладі ми бачимо, що команда `echo` нічого не виводить. Ми допустили друкарську помилку:\n"
"> > у назві змінної циклу, а змінної `datfile` не існує, тому повертається\n"
"> > порожній рядок."

# Front Matter
#: shell-novice/_episodes/07-find.md:1
msgid ""
"---\n"
"title: \"Finding Things\"\n"
"teaching: 25\n"
"exercises: 20\n"
"questions:\n"
"- \"How can I find files?\"\n"
"- \"How can I find things in files?\"\n"
"objectives:\n"
"- \"Use `grep` to select lines from text files that match simple patterns.\"\n"
"- \"Use `find` to find files and directories whose names match simple patterns.\"\n"
"- \"Use the output of one command as the command-line argument(s) to another command.\"\n"
"- \"Explain what is meant by 'text' and 'binary' files, and why many common tools don't handle the latter well.\"\n"
"keypoints:\n"
"- \"`find` finds files with specific properties that match patterns.\"\n"
"- \"`grep` selects lines in files that match patterns.\"\n"
"- \"`--help` is an option supported by many bash commands, and programs that can be run from within Bash, to display more information on how to use these commands or programs.\"\n"
"- \"`man [command]` displays the manual page for a given command.\"\n"
"- \"`$([command])` inserts a command's output in place.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Пошук речей\"\n"
"teaching: 25\n"
"exercises: 20\n"
"questions:\n"
"- \"Як я можу знайти файли?\"\n"
"- \"Як знайти щось у файлах?\"\n"
"objectives:\n"
"- \"Використати `grep` для виділення рядків з текстових файлів, які відповідають простим шаблонам.\"\n"
"- \"Використати `find` для пошуку файлів і каталогів, назви яких відповідають простим шаблонам.\"\n"
"- \"Використати вихідні дані однієї команди як аргумент(и) командного рядка для іншої команди.\"\n"
"- \"Пояснити, що мається на увазі під 'текстовими' та 'бінарними' файлами, і чому багато поширених інструментів погано працюють з останніми.\"\n"
"keypoints:\n"
"- \"`find` шукає файли з певними властивостями, які відповідають шаблонам.\"\n"
"- \"`grep` вибирає рядки з файлів, які відповідають шаблонам.\"\n"
"- \"`--help` - це опція, яка підтримується багатьма командами bash і програмами, які можна запустити з bash, для відображення додаткової інформації про те, як користуватися цими командами або програмами.\"\n"
"- \"`man [команда]` показує сторінку посібника для даної команди.\"\n"
"- \"`$([команда])` вставляє вивід команди на місце.\"\n"
"---"

#: shell-novice/_episodes/07-find.md:21
msgid ""
"In the same way that many of us now use 'Google' as a\n"
"verb meaning 'to find', Unix programmers often use the\n"
"word 'grep'.\n"
"'grep' is a contraction of 'global/regular expression/print',\n"
"a common sequence of operations in early Unix text editors.\n"
"It is also the name of a very useful command-line program."
msgstr ""
"Так само, як багато хто з нас зараз використовує 'Google' як\n"
"дієслово, що означає 'шукати', Unix-програмісти часто використовують\n"
"слово 'grep'.\n"
"'grep' - це скорочення від 'global/regular expression/print' (з англ. 'глобальний/регулярний вираз/друк'),\n"
"поширеної послідовності операцій у ранніх текстових редакторах Unix.\n"
"Це також назва дуже корисної програми командного рядка."

#: shell-novice/_episodes/07-find.md:28
msgid ""
"`grep` finds and prints lines in files that match a pattern.\n"
"For our examples,\n"
"we will use a file that contains three haiku taken from a\n"
"[1998 competition](https://web.archive.org/web/19991201042211/http://salon.com/21st/chal/1998/01/26chal.html)\n"
"in *Salon* magazine (Credit to authors Bill Torcaso, Howard Korder, and \n"
"Margaret Segall, respectively. See \n"
"Haiku Error Messsages archived\n"
"[Page 1](https://web.archive.org/web/20000310061355/http://www.salon.com/21st/chal/1998/02/10chal2.html)\n"
"and\n"
"[Page 2](https://web.archive.org/web/20000229135138/http://www.salon.com/21st/chal/1998/02/10chal3.html)\n"
".). For this set of examples,\n"
"we're going to be working in the writing subdirectory:"
msgstr ""
"`grep` шукає і виводить рядки у файлах, які відповідають шаблону.\n"
"У нашому прикладі\n"
"ми використаємо файл, який містить три хайку, взяті з\n"
"[конкурсу 1998 року](https://web.archive.org/web/19991201042211/http://salon.com/21st/chal/1998/01/26chal.html)\n"
"в журналі *Salon* (авторство належить Біллу Торкасо (Bill Torcaso), Говарду Кордеру (Howard Korder) та \n"
"Маргарет Сігал (Margaret Segall), відповідно. Див. \n"
"Haiku Error Messages в архіві\n"
"[Сторінка 1] (https://web.archive.org/web/20000310061355/http://www.salon.com/21st/chal/1998/02/10chal2.html)\n"
"та\n"
"[Сторінка 2](https://web.archive.org/web/20000229135138/http://www.salon.com/21st/chal/1998/02/10chal3.html)\n"
".). Для цього набору прикладів\n"
"ми будемо працювати у підкаталозі writing:"

# code block
#: shell-novice/_episodes/07-find.md:41
msgid ""
"~~~\n"
"$ cd\n"
"$ cd Desktop/shell-lesson-data/exercise-data/writing\n"
"$ cat haiku.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd\n"
"$ cd Desktop/shell-lesson-data/exercise-data/writing\n"
"$ cat haiku.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:48
msgid ""
"~~~\n"
"The Tao that is seen\n"
"Is not the true Tao, until\n"
"You bring fresh toner.\n"
"\n"
"With searching comes loss\n"
"and the presence of absence:\n"
"\"My Thesis\" not found.\n"
"\n"
"Yesterday it worked\n"
"Today it is not working\n"
"Software is like that.\n"
"~~~"
msgstr ""
"~~~\n"
"The Tao that is seen\n"
"Is not the true Tao, until\n"
"You bring fresh toner.\n"
"\n"
"With searching comes loss\n"
"and the presence of absence:\n"
"\"My Thesis\" not found.\n"
"\n"
"Yesterday it worked\n"
"Today it is not working\n"
"Software is like that.\n"
"~~~"

#: shell-novice/_episodes/07-find.md:63
msgid "Let's find lines that contain the word 'not':"
msgstr "Знайдемо рядки, які містять слово 'not':"

# code block
#: shell-novice/_episodes/07-find.md:65
msgid ""
"~~~\n"
"$ grep not haiku.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep not haiku.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:70
msgid ""
"~~~\n"
"Is not the true Tao, until\n"
"\"My Thesis\" not found\n"
"Today it is not working\n"
"~~~"
msgstr ""
"~~~\n"
"Is not the true Tao, until\n"
"\"My Thesis\" not found\n"
"Today it is not working\n"
"~~~"

#: shell-novice/_episodes/07-find.md:77
msgid ""
"Here, `not` is the pattern we're searching for.\n"
"The grep command searches through the file, looking for matches to the pattern specified.\n"
"To use it type `grep`, then the pattern we're searching for and finally\n"
"the name of the file (or files) we're searching in."
msgstr ""
"Тут `not` - це шаблон, який ми шукаємо.\n"
"Команда grep шукає у файлі збіги із заданим шаблоном.\n"
"Щоб скористатися нею, введіть `grep`, потім шаблон, який ми шукаємо, і нарешті\n"
"ім'я файлу (або файлів), у якому (у яких) ми шукаємо."

#: shell-novice/_episodes/07-find.md:82
msgid ""
"The output is the three lines in the file that contain the letters 'not'."
msgstr "У вихідний файл виводяться три рядки, які містять літери 'not'."

#: shell-novice/_episodes/07-find.md:84
msgid ""
"By default, grep searches for a pattern in a case-sensitive way.\n"
"In addition, the search pattern we have selected does not have to form a complete word,\n"
"as we will see in the next example."
msgstr ""
"За замовчуванням grep шукає шаблон з урахуванням регістру.\n"
"Крім того, вибраний нами шаблон пошуку не обов'язково має бути повним словом,\n"
"як ми побачимо у наступному прикладі."

#: shell-novice/_episodes/07-find.md:88
msgid "Let's search for the pattern: 'The'."
msgstr "Давайте відшукаємо шаблон: 'The'."

# code block
#: shell-novice/_episodes/07-find.md:90
msgid ""
"~~~\n"
"$ grep The haiku.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep The haiku.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:95
msgid ""
"~~~\n"
"The Tao that is seen\n"
"\"My Thesis\" not found.\n"
"~~~"
msgstr ""
"~~~\n"
"The Tao that is seen\n"
"\"My Thesis\" not found.\n"
"~~~"

#: shell-novice/_episodes/07-find.md:101
msgid ""
"This time, two lines that include the letters 'The' are outputted,\n"
"one of which contained our search pattern within a larger word, 'Thesis'."
msgstr ""
"Цього разу буде виведено два рядки, що містять літери 'The',\n"
"один з яких містить наш шаблон пошуку у більшому слові 'Thesis'."

#: shell-novice/_episodes/07-find.md:104
msgid ""
"To restrict matches to lines containing the word 'The' on its own,\n"
"we can give `grep` the `-w` option.\n"
"This will limit matches to word boundaries."
msgstr ""
"Щоб обмежити збіги до рядків, що містять слово 'The' як таке,\n"
"ми можемо надати `grep` опцію `-w`.\n"
"Це обмежить збіги межами слів."

#: shell-novice/_episodes/07-find.md:108
msgid ""
"Later in this lesson, we will also see how we can change the search behavior of grep\n"
"with respect to its case sensitivity."
msgstr ""
"Пізніше у цьому уроці ми також побачимо, як можна змінити поведінку пошуку grep\n"
"з урахуванням чутливості до регістру."

# code block
#: shell-novice/_episodes/07-find.md:111
msgid ""
"~~~\n"
"$ grep -w The haiku.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep -w The haiku.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:116
msgid ""
"~~~\n"
"The Tao that is seen\n"
"~~~"
msgstr ""
"~~~\n"
"The Tao that is seen\n"
"~~~"

#: shell-novice/_episodes/07-find.md:121
msgid ""
"Note that a 'word boundary' includes the start and end of a line, so not\n"
"just letters surrounded by spaces.\n"
"Sometimes we don't\n"
"want to search for a single word, but a phrase. This is also easy to do with\n"
"`grep` by putting the phrase in quotes."
msgstr ""
"Зверніть увагу, що 'межа слова' включає початок і кінець рядка, тобто не\n"
"лише літери, оточені пробілами.\n"
"Іноді ми хочемо\n"
"шукати не окреме слово, а фразу. Це також легко зробити за допомогою\n"
"`grep`, взявши фразу в лапки."

# code block
#: shell-novice/_episodes/07-find.md:127
msgid ""
"~~~\n"
"$ grep -w \"is not\" haiku.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep -w \"is not\" haiku.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:132
msgid ""
"~~~\n"
"Today it is not working\n"
"~~~"
msgstr ""
"~~~\n"
"Today it is not working\n"
"~~~"

#: shell-novice/_episodes/07-find.md:137
msgid ""
"We've now seen that you don't have to have quotes around single words,\n"
"but it is useful to use quotes when searching for multiple words.\n"
"It also helps to make it easier to distinguish between the search term or phrase\n"
"and the file being searched.\n"
"We will use quotes in the remaining examples."
msgstr ""
"Ми вже бачили, що не обов'язково брати в лапки окремі слова,\n"
"але корисно використовувати лапки під час пошуку кількох слів.\n"
"Це також допомагає легше відрізнити пошуковий термін або фразу\n"
"від файлу, в якому відбувається пошук.\n"
"Ми будемо використовувати лапки в решті прикладів."

#: shell-novice/_episodes/07-find.md:143
msgid "Another useful option is `-n`, which numbers the lines that match:"
msgstr "Ще одна корисна опція - `-n`, яка нумерує рядки, що збігаються:"

# code block
#: shell-novice/_episodes/07-find.md:145
msgid ""
"~~~\n"
"$ grep -n \"it\" haiku.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep -n \"it\" haiku.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:150
msgid ""
"~~~\n"
"5:With searching comes loss\n"
"9:Yesterday it worked\n"
"10:Today it is not working\n"
"~~~"
msgstr ""
"~~~\n"
"5:With searching comes loss\n"
"9:Yesterday it worked\n"
"10:Today it is not working\n"
"~~~"

#: shell-novice/_episodes/07-find.md:157
msgid "Here, we can see that lines 5, 9, and 10 contain the letters 'it'."
msgstr "Ми бачимо, що рядки 5, 9 і 10 містять літери 'it'."

#: shell-novice/_episodes/07-find.md:159
msgid ""
"We can combine options (i.e. flags) as we do with other Unix commands.\n"
"For example, let's find the lines that contain the word 'the'.\n"
"We can combine the option `-w` to find the lines that contain the word 'the'\n"
"and `-n` to number the lines that match:"
msgstr ""
"Ми можемо комбінувати опції (тобто прапорці) так само, як і в інших командах Unix.\n"
"Наприклад, давайте знайдемо рядки, які містять слово 'the'.\n"
"Ми можемо комбінувати опцію `-w`, щоб знайти рядки, які містять слово 'the'\n"
"і `-n`, щоб пронумерувати рядки, що збігаються:"

# code block
#: shell-novice/_episodes/07-find.md:164
msgid ""
"~~~\n"
"$ grep -n -w \"the\" haiku.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep -n -w \"the\" haiku.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:169
msgid ""
"~~~\n"
"2:Is not the true Tao, until\n"
"6:and the presence of absence:\n"
"~~~"
msgstr ""
"~~~\n"
"2:Is not the true Tao, until\n"
"6:and the presence of absence:\n"
"~~~"

#: shell-novice/_episodes/07-find.md:175
msgid ""
"Now we want to use the option `-i` to make our search case-insensitive:"
msgstr ""
"Тепер ми хочемо використати опцію `-i`, щоб зробити наш пошук нечутливим до "
"регістру:"

# code block
#: shell-novice/_episodes/07-find.md:177
msgid ""
"~~~\n"
"$ grep -n -w -i \"the\" haiku.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep -n -w -i \"the\" haiku.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:182
msgid ""
"~~~\n"
"1:The Tao that is seen\n"
"2:Is not the true Tao, until\n"
"6:and the presence of absence:\n"
"~~~"
msgstr ""
"~~~\n"
"1:The Tao that is seen\n"
"2:Is not the true Tao, until\n"
"6:and the presence of absence:\n"
"~~~"

#: shell-novice/_episodes/07-find.md:189
msgid ""
"Now, we want to use the option `-v` to invert our search, i.e., we want to output\n"
"the lines that do not contain the word 'the'."
msgstr ""
"Тепер ми хочемо використати опцію `-v` для інвертування пошуку, тобто вивести\n"
"рядки, які не містять слова 'the'."

# code block
#: shell-novice/_episodes/07-find.md:192
msgid ""
"~~~\n"
"$ grep -n -w -v \"the\" haiku.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep -n -w -v \"the\" haiku.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:197
msgid ""
"~~~\n"
"1:The Tao that is seen\n"
"3:You bring fresh toner.\n"
"4:\n"
"5:With searching comes loss\n"
"7:\"My Thesis\" not found.\n"
"8:\n"
"9:Yesterday it worked\n"
"10:Today it is not working\n"
"11:Software is like that.\n"
"~~~"
msgstr ""
"~~~\n"
"1:The Tao that is seen\n"
"3:You bring fresh toner.\n"
"4:\n"
"5:With searching comes loss\n"
"7:\"My Thesis\" not found.\n"
"8:\n"
"9:Yesterday it worked\n"
"10:Today it is not working\n"
"11:Software is like that.\n"
"~~~"

#: shell-novice/_episodes/07-find.md:211
msgid ""
"If we use the `-r` (recursive) option,\n"
"`grep` can search for a pattern recursively through a set of files in subdirectories."
msgstr ""
"Якщо ми використовуємо опцію `-r` (recursive, з англ. - рекурсивний),\n"
"`grep` може шукати шаблон рекурсивно через набір файлів у підкаталогах."

#: shell-novice/_episodes/07-find.md:214
msgid ""
"Let's search recursively for `Yesterday` in the `shell-lesson-data/exercise-"
"data/writing` directory:"
msgstr ""
"Давайте виконаємо рекурсивний пошук `Yesterday` у каталозі `shell-lesson-"
"data/exercise-data/writing`:"

# code block
#: shell-novice/_episodes/07-find.md:216
msgid ""
"```\n"
"$ grep -r Yesterday .\n"
"```"
msgstr ""
"```\n"
"$ grep -r Yesterday .\n"
"```"

# code block
#: shell-novice/_episodes/07-find.md:221
msgid ""
"```\n"
"./LittleWomen.txt:\"Yesterday, when Aunt was asleep and I was trying to be as still as a\n"
"./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then\n"
"./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my\n"
"./haiku.txt:Yesterday it worked\n"
"```"
msgstr ""
"```\n"
"./LittleWomen.txt:\"Yesterday, when Aunt was asleep and I was trying to be as still as a\n"
"./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then\n"
"./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my\n"
"./haiku.txt:Yesterday it worked\n"
"```"

#: shell-novice/_episodes/07-find.md:229
msgid ""
"`grep` has lots of other options. To find out what they are, we can type:"
msgstr ""
"У `grep` є багато інших варіантів. Щоб дізнатися, які саме, ми можемо "
"набрати їх:"

# code block
#: shell-novice/_episodes/07-find.md:231
msgid ""
"~~~\n"
"$ grep --help\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep --help\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:236
msgid ""
"~~~\n"
"Usage: grep [OPTION]... PATTERN [FILE]...\n"
"Search for PATTERN in each FILE or standard input.\n"
"PATTERN is, by default, a basic regular expression (BRE).\n"
"Example: grep -i 'hello world' menu.h main.c\n"
"\n"
"Regexp selection and interpretation:\n"
"  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n"
"  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings\n"
"  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n"
"  -P, --perl-regexp         PATTERN is a Perl regular expression\n"
"  -e, --regexp=PATTERN      use PATTERN for matching\n"
"  -f, --file=FILE           obtain PATTERN from FILE\n"
"  -i, --ignore-case         ignore case distinctions\n"
"  -w, --word-regexp         force PATTERN to match only whole words\n"
"  -x, --line-regexp         force PATTERN to match only whole lines\n"
"  -z, --null-data           a data line ends in 0 byte, not newline\n"
"\n"
"Miscellaneous:\n"
"...        ...        ...\n"
"~~~"
msgstr ""
"Використання: grep [ПАРАМЕТР]... ШАБЛОНИ [ФАЙЛ]...\n"
"Шукати ШАБЛОНИ у кожному ФАЙЛі.\n"
"Приклад: grep -i 'hello world' menu.h main.c\n"
"Запис ШАБЛОНИ може містити декілька шаблонів, які відокремлено символами нового рядка.\n"
"\n"
"Вибір за взірцем та інтерпретація:\n"
"-E, --extended-regexp ШАБЛОНИ є розширеним формальним виразом\n"
"-F, --fixed-strings ШАБЛОНИ є набором рядків\n"
"-G, --basic-regexp ШАБЛОНИ є звичайними формальними виразами\n"
"-P, --perl-regexp ШАБЛОНИ є формальними виразами Perl\n"
"-e, --regexp=ШАБЛОНИ використовувати ШАБЛОНИ для встановлення відповіднос ті\n"
"-f, --file=ФАЙЛ взяти ШАБЛОНИ із ФАЙЛа\n"
"-i, --ignore-case ігнорувати регістр літер у шаблонах і даних\n"
"--no-ignore-case не ігнорувати регістр літер (типова поведінка)\n"
"-w, --word-regexp шукати лише цілі слова\n"
"-x, --line-regexp шукати лише цілі рядки\n"
"-z, --null-data рядки даних закінчуються байтом \"0\", а не символом\n"
"кінця рядка (\\n)"

# blockquote, which can be cascaded
#: shell-novice/_episodes/07-find.md:259
msgid "> ## Using `grep`"
msgstr "> ## Використання `grep`"

#: shell-novice/_episodes/07-find.md:260
msgid ""
">\n"
"> Which command would result in the following output:\n"
">\n"
"> ~~~\n"
"> and the presence of absence:\n"
"> ~~~"
msgstr ""
">\n"
"> Яка команда призведе до наступного виводу:\n"
">\n"
"> ~~~\n"
"> and the presence of absence:\n"
"> ~~~"

#: shell-novice/_episodes/07-find.md:267
msgid ""
">\n"
"> 1. `grep \"of\" haiku.txt`\n"
"> 2. `grep -E \"of\" haiku.txt`\n"
"> 3. `grep -w \"of\" haiku.txt`\n"
"> 4. `grep -i \"of\" haiku.txt`\n"
">\n"
"> > ## Solution\n"
"> > The correct answer is 3, because the `-w` option looks only for whole-word matches.\n"
"> > The other options will also match 'of' when part of another word."
msgstr ""
">\n"
"> 1. `grep \"of\" haiku.txt`\n"
"> 2. `grep -E \"of\" haiku.txt`\n"
"> 3. `grep -w \"of\" haiku.txt`\n"
"> 4. `grep -i \"of\" haiku.txt`\n"
">\n"
"> > ## Розв'язання\n"
"> > Правильна відповідь 3, тому що опція `-w` шукає збіги лише між цілими словами.\n"
"> Інші варіанти також шукатимуть збіги зі словом 'of', якщо воно є частиною іншого слова."

#: shell-novice/_episodes/07-find.md:280
msgid ""
">\n"
"> `grep`'s real power doesn't come from its options, though; it comes from\n"
"> the fact that patterns can include wildcards. (The technical name for\n"
"> these is **regular expressions**, which\n"
"> is what the 're' in 'grep' stands for.) Regular expressions are both complex\n"
"> and powerful; if you want to do complex searches, please look at the lesson\n"
"> on [our website](http://v4.software-carpentry.org/regexp/index.html). As a taster, we can\n"
"> find lines that have an 'o' in the second position like this:\n"
">\n"
"> ~~~\n"
"> $ grep -E \"^.o\" haiku.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> You bring fresh toner.\n"
"> Today it is not working\n"
"> Software is like that.\n"
"> ~~~"
msgstr ""
">\n"
"> Проте справжня сила `grep` полягає не у його опціях, а у тому,\n"
"> що шаблони можуть містити підстановочні символи. (Технічна назва для\n"
"> цього - **регулярні вирази**, для чого\n"
"> скорочення 're' у 'grep'). Регулярні вирази є складними\n"
"> і потужніми; якщо ви хочете робити складні пошуки, будь ласка, перегляньте урок\n"
"> на [нашому сайті] (http://v4.software-carpentry.org/regexp/index.html). Для початку ми можемо\n"
"> знайти рядки, які містять \"o\" у другій позиції, наприклад, так:\n"
">\n"
"> ~~~\n"
"> $ grep -E \"^.o\" haiku.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> You bring fresh toner.\n"
"> Today it is not working\n"
"> Software is like that.\n"
"> ~~~"

#: shell-novice/_episodes/07-find.md:300
msgid ""
">\n"
"> We use the `-E` option and put the pattern in quotes to prevent the shell\n"
"> from trying to interpret it. (If the pattern contained a `*`, for\n"
"> example, the shell would try to expand it before running `grep`.) The\n"
"> `^` in the pattern anchors the match to the start of the line. The `.`\n"
"> matches a single character (just like `?` in the shell), while the `o`\n"
"> matches an actual 'o'."
msgstr ""
">\n"
"> Ми використовуємо опцію `-E` і беремо шаблон у лапки, щоб запобігти спробам терміналу\n"
"> інтерпретувати його. (Якщо шаблон містить `*`,\n"
"> наприклад, оболонка спробує розгорнути його перед запуском `grep`). Символ\n"
"> `^` у шаблоні прив'язує збіг до початку рядка. Символ `.`\n"
"> відповідає одному символу (подібно до `?` у командному рядку), тоді як `o`\n"
"> відповідає власне 'o'."

# blockquote, which can be cascaded
#: shell-novice/_episodes/07-find.md:309
msgid "> ## Tracking a Species"
msgstr "> ## Відстеження видів"

#: shell-novice/_episodes/07-find.md:310
msgid ""
">\n"
"> Leah has several hundred\n"
"> data files saved in one directory, each of which is formatted like this:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> 2012-11-06,deer,2\n"
"> 2012-11-06,fox,4\n"
"> 2012-11-07,rabbit,16\n"
"> 2012-11-07,bear,1\n"
"> ~~~"
msgstr ""
">\n"
"> Лея має кілька сотень\n"
"> файлів даних, збережених в одному каталозі, кожен з яких відформатовано таким чином:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> 2012-11-06,deer,2\n"
"> 2012-11-06,fox,4\n"
"> 2012-11-07,rabbit,16\n"
"> 2012-11-07,bear,1\n"
"> ~~~"

#: shell-novice/_episodes/07-find.md:325
msgid ""
">\n"
"> She wants to write a shell script that takes a species as the first command-line argument\n"
"> and a directory as the second argument. The script should return one file called `<species>.txt`\n"
"> containing a list of dates and the number of that species seen on each date.\n"
"> For example using the data shown above, `rabbit.txt` would contain:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,22\n"
"> 2012-11-06,19\n"
"> 2012-11-07,16\n"
"> ~~~"
msgstr ""
">\n"
"> Вона хоче написати командний скрипт, який приймає вид як перший аргумент командного рядка\n"
"> і каталог як другий аргумент. Скрипт повинен повернути один файл з назвою `<вид>.txt',\n"
"> який містить список дат і кількість особин цього виду, які були помічені у кожну дату.\n"
"> Наприклад, використовуючи дані, показані вище, `rabbit.txt` буде містити:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,22\n"
"> 2012-11-06,19\n"
"> 2012-11-07,16\n"
"> ~~~"

#: shell-novice/_episodes/07-find.md:337
msgid ""
">\n"
"> Below, each line contains an individual command, or pipe.  Arrange their\n"
"> sequence in one command in order to achieve Leah's goal:\n"
">\n"
"> ~~~\n"
"> cut -d : -f 2\n"
"> >\n"
"> |\n"
"> grep -w $1 -r $2\n"
"> |\n"
"> $1.txt\n"
"> cut -d , -f 1,3\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Hint: use `man grep` to look for how to grep text recursively in a directory\n"
"> and `man cut` to select more than one field in a line.\n"
">\n"
"> An example of such a file is provided in\n"
"> `shell-lesson-data/exercise-data/animal-counts/animals.csv`\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ```\n"
"> > grep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 > $1.txt\n"
"> > ```\n"
"> > {: .source}\n"
"> >\n"
"> > Actually, you can swap the order of the two cut commands and it still works. At the\n"
"> > command line, try changing the order of the cut commands, and have a look at the output\n"
"> > from each step to see why this is the case.\n"
"> >\n"
"> > You would call the script above like this:\n"
"> >\n"
"> > ```\n"
"> > $ bash count-species.sh bear .\n"
"> > ```\n"
"> > {: .language-bash}"
msgstr ""
">\n"
"> Нижче кожен рядок містить окрему команду або канал. Впорядкуйте їх\n"
"> послідовність в одну команду, щоб досягти мети Леї:\n"
">\n"
"> ~~~\n"
"> cut -d : -f 2\n"
"> >\n"
"> |\n"
"> grep -w $1 -r $2\n"
"> |\n"
"> $1.txt\n"
"> cut -d , -f 1,3\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Підказка: використовуйте `man grep` для пошуку того, як виконувати рекурсивний пошук тексту у каталозі\n"
"> і `man cut` для виділення декількох полів у рядку.\n"
">\n"
"> Приклад такого файлу наведено в\n"
"> `shell-lesson-data/exercise-data/animal-counts/animals.csv`\n"
">\n"
"> > ## Розв'язання\n"
"> >\n"
"> > ```\n"
"> > grep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 > $1.txt\n"
"> > ```\n"
"> > {: .source}\n"
"> >\n"
"> > Насправді, ви можете поміняти місцями порядок двох команд вирізання, і це все одно буде працювати. У командному рядку\n"
"> > спробуйте змінити порядок команд вирізання і подивіться на вивід\n"
"> > на кожному кроці, щоб зрозуміти, чому це відбувається.\n"
"> >\n"
"> > Ви можете визвати наведений вище скрипт так:\n"
"> >\n"
"> > ```\n"
"> > $ bash count-species.sh bear .\n"
"> > ```\n"
"> > {: .language-bash}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/07-find.md:378
msgid "> ## Little Women"
msgstr "> ## Маленькі жінки"

#: shell-novice/_episodes/07-find.md:379
msgid ""
">\n"
"> You and your friend, having just finished reading *Little Women* by\n"
"> Louisa May Alcott, are in an argument.  Of the four sisters in the\n"
"> book, Jo, Meg, Beth, and Amy, your friend thinks that Jo was the\n"
"> most mentioned.  You, however, are certain it was Amy.  Luckily, you\n"
"> have a file `LittleWomen.txt` containing the full text of the novel\n"
"> (`shell-lesson-data/exercise-data/writing/LittleWomen.txt`).\n"
"> Using a `for` loop, how would you tabulate the number of times each\n"
"> of the four sisters is mentioned?\n"
">\n"
"> Hint: one solution might employ\n"
"> the commands `grep` and `wc` and a `|`, while another might utilize\n"
"> `grep` options.\n"
"> There is often more than one way to solve a programming task, so a\n"
"> particular solution is usually chosen based on a combination of\n"
"> yielding the correct result, elegance, readability, and speed.\n"
">\n"
"> > ## Solutions\n"
"> > ```\n"
"> > for sis in Jo Meg Beth Amy\n"
"> > do\n"
"> >     echo $sis:\n"
"> >     grep -ow $sis LittleWomen.txt | wc -l\n"
"> > done\n"
"> > ```\n"
"> > {: .source}\n"
"> >\n"
"> > Alternative, slightly inferior solution:\n"
"> > ```\n"
"> > for sis in Jo Meg Beth Amy\n"
"> > do\n"
"> >     echo $sis:\n"
"> >     grep -ocw $sis LittleWomen.txt\n"
"> > done\n"
"> > ```\n"
"> > {: .source}\n"
"> >\n"
"> > This solution is inferior because `grep -c` only reports the number of lines matched.\n"
"> > The total number of matches reported by this method will be lower if there is more\n"
"> > than one match per line.\n"
"> >\n"
"> > Perceptive observers may have noticed that character names sometimes appear in all-uppercase\n"
"> > in chapter titles (e.g. 'MEG GOES TO VANITY FAIR').\n"
"> > If you wanted to count these as well, you could add the `-i` option for case-insensitivity\n"
"> > (though in this case, it doesn't affect the answer to which sister is mentioned\n"
"> > most frequently)."
msgstr ""
">\n"
"> Ви з другом щойно закінчили читати \"Маленьких жінок\"\n"
"> Луїзи Мей Елкотт і сперечаєтеся. З чотирьох сестер у книзі,\n"
"> Джо, Мег, Бет та Емі, ваш друг вважає, що про Джо\n"
"> найчастіше згадується. Ви, однак, впевнені, що це була Емі. На щастя, у вас\n"
"> є файл `LittleWomen.txt`, який містить повний текст роману\n"
"> (`shell-lesson-data/exercise-data/writing/LittleWomen.txt`).\n"
"> Використовуючи цикл `for`, як ви виведете в таблицю кількість разів, коли кожна\n"
"> з чотирьох сестер згадується?\n"
">\n"
"> Підказка: одне рішення може використовувати\n"
"> команди `grep`, `wc` та `|`, а інше може використовувати\n"
"> опції `grep`.\n"
"> Часто існує більше ніж один спосіб розв'язання задачі програмування, тому\n"
"> конкретний спосіб зазвичай обирається на основі комбінації\n"
"> отримання правильного результату, елегантності, читабельності та швидкості.\n"
">\n"
"> > ## Розв'язання\n"
"> > ```\n"
"> > for sis in Jo Meg Beth Amy\n"
"> > do\n"
"> >     echo $sis:\n"
"> >     grep -ow $sis LittleWomen.txt | wc -l\n"
"> > done\n"
"> > ```\n"
"> > {: .source}\n"
"> >\n"
"> > Альтернативне, трохи гірше рішення:\n"
"> > ```\n"
"> > for sis in Jo Meg Beth Amy\n"
"> > do\n"
"> >     echo $sis:\n"
"> >     grep -ocw $sis LittleWomen.txt\n"
"> > done\n"
"> > ```\n"
"> > {: .source}\n"
"> >\n"
"> > Це рішення є гіршим, оскільки `grep -c` повідомляє лише про кількість знайдених рядків.\n"
"> > Загальна кількість збігів, отриманих за допомогою цього методу, буде меншою, якщо на один рядок припадає більше,\n"
"> > ніж один збіг.\n"
"> >\n"
"> > Уважні спостерігачі могли помітити, що імена персонажів іноді з'являються з великої літери\n"
"> > у назвах розділів (наприклад, \"MEG GOES TO VANITY FAIR\").\n"
"> > Якщо ви хочете врахувати і ці випадки, ви можете додати опцію `-i` для нечутливості до регістру.\n"
"> > (хоча в цьому випадку це не впливає на відповідь, яка сестра згадується\n"
"> > найчастіше)."

#: shell-novice/_episodes/07-find.md:428
msgid ""
"While `grep` finds lines in files,\n"
"the `find` command finds files themselves.\n"
"Again,\n"
"it has a lot of options;\n"
"to show how the simplest ones work, we'll use the `shell-lesson-data/exercise-data`\n"
"directory tree shown below."
msgstr ""
"У той час як `grep` знаходить рядки у файлах,\n"
"команда `find` знаходить самі файли.\n"
"Знову ж таки,\n"
"у неї є багато опцій;\n"
"щоб показати, як працюють найпростіші з них, ми скористаємося деревом каталогів `shell-lesson-data/exercise-data`,\n"
"що наведено нижче."

# code block
#: shell-novice/_episodes/07-find.md:435
msgid ""
"~~~\n"
".\n"
"├── animal-counts/\n"
"│   └── animals.csv\n"
"├── creatures/\n"
"│   ├── basilisk.dat\n"
"│   ├── minotaur.dat\n"
"│   └── unicorn.dat\n"
"├── numbers.txt\n"
"├── proteins/\n"
"│   ├── cubane.pdb\n"
"│   ├── ethane.pdb\n"
"│   ├── methane.pdb\n"
"│   ├── octane.pdb\n"
"│   ├── pentane.pdb\n"
"│   └── propane.pdb\n"
"└── writing/\n"
"    ├── haiku.txt\n"
"    └── LittleWomen.txt\n"
"~~~"
msgstr ""
"~~~\n"
".\n"
"├── animal-counts/\n"
"│   └── animals.csv\n"
"├── creatures/\n"
"│   ├── basilisk.dat\n"
"│   ├── minotaur.dat\n"
"│   └── unicorn.dat\n"
"├── numbers.txt\n"
"├── proteins/\n"
"│   ├── cubane.pdb\n"
"│   ├── ethane.pdb\n"
"│   ├── methane.pdb\n"
"│   ├── octane.pdb\n"
"│   ├── pentane.pdb\n"
"│   └── propane.pdb\n"
"└── writing/\n"
"    ├── haiku.txt\n"
"    └── LittleWomen.txt\n"
"~~~"

#: shell-novice/_episodes/07-find.md:457
msgid ""
"The `exercise-data` directory contains one file, `numbers.txt` and four directories:\n"
"`animal-counts`, `creatures`, `proteins` and `writing` containing various files."
msgstr ""
"Каталог `exercise-data` містить один файл `numbers.txt` та чотири каталоги:\n"
"`animal-counts`, `creatures`, `proteins` і `writing`, які містять різні файли."

#: shell-novice/_episodes/07-find.md:461
msgid ""
"For our first command,\n"
"let's run `find .` (remember to run this command from the `shell-lesson-data/exercise-data` folder)."
msgstr ""
"Для нашої першої команди\n"
"давайте виконаємо `find .` (не забудьте запустити цю команду з каталогу `shell-lesson-data/exercise-data`)."

# code block
#: shell-novice/_episodes/07-find.md:464
msgid ""
"~~~\n"
"$ find .\n"
"~~~"
msgstr ""
"~~~\n"
"$ find .\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:469
msgid ""
"~~~\n"
".\n"
"./writing\n"
"./writing/LittleWomen.txt\n"
"./writing/haiku.txt\n"
"./creatures\n"
"./creatures/basilisk.dat\n"
"./creatures/unicorn.dat\n"
"./creatures/minotaur.dat\n"
"./animal-counts\n"
"./animal-counts/animals.csv\n"
"./numbers.txt\n"
"./proteins\n"
"./proteins/ethane.pdb\n"
"./proteins/propane.pdb\n"
"./proteins/octane.pdb\n"
"./proteins/pentane.pdb\n"
"./proteins/methane.pdb\n"
"./proteins/cubane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
".\n"
"./writing\n"
"./writing/LittleWomen.txt\n"
"./writing/haiku.txt\n"
"./creatures\n"
"./creatures/basilisk.dat\n"
"./creatures/unicorn.dat\n"
"./creatures/minotaur.dat\n"
"./animal-counts\n"
"./animal-counts/animals.csv\n"
"./numbers.txt\n"
"./proteins\n"
"./proteins/ethane.pdb\n"
"./proteins/propane.pdb\n"
"./proteins/octane.pdb\n"
"./proteins/pentane.pdb\n"
"./proteins/methane.pdb\n"
"./proteins/cubane.pdb\n"
"~~~"

#: shell-novice/_episodes/07-find.md:492
msgid ""
"As always, the `.` on its own means the current working directory,\n"
"which is where we want our search to start.\n"
"`find`'s output is the names of every file **and** directory\n"
"under the current working directory.\n"
"This can seem useless at first but `find` has many options\n"
"to filter the output and in this lesson we will discover some\n"
"of them."
msgstr ""
"Як завжди, символ `.` сам по собі означає поточний робочий каталог,\n"
"з якого ми хочемо почати пошук.\n"
"Результатом роботи `find` буде перелік імен усіх файлів **та** каталогів\n"
"у поточному робочому каталозі.\n"
"Спочатку це може здатися марним, але `find` має багато можливостей\n"
"для фільтрації результатів, і у цьому уроці ми розглянемо деякі\n"
"з них."

#: shell-novice/_episodes/07-find.md:500
msgid ""
"The first option in our list is\n"
"`-type d` that means 'things that are directories'.\n"
"Sure enough, `find`'s output is the names of the five directories (including `.`):"
msgstr ""
"Перший варіант у нашому списку\n"
"`-type d`, що означає 'елементи, які є каталогами'.\n"
"Звісно, команда `find` виведе назви п'яти каталогів (включно з `.`):"

# code block
#: shell-novice/_episodes/07-find.md:504
msgid ""
"~~~\n"
"$ find . -type d\n"
"~~~"
msgstr ""
"~~~\n"
"$ find . -type d\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:509
msgid ""
"~~~\n"
".\n"
"./writing\n"
"./creatures\n"
"./animal-counts\n"
"./proteins\n"
"~~~"
msgstr ""
"~~~\n"
".\n"
"./writing\n"
"./creatures\n"
"./animal-counts\n"
"./proteins\n"
"~~~"

#: shell-novice/_episodes/07-find.md:518
msgid ""
"Notice that the objects `find` finds are not listed in any particular order.\n"
"If we change `-type d` to `-type f`,\n"
"we get a listing of all the files instead:"
msgstr ""
"Зверніть увагу, що об'єкти, які знаходить `find`, не перераховано у певному порядку.\n"
"Якщо ми змінимо `-type d` на `-type f`,\n"
"ми отримаємо список усіх файлів:"

# code block
#: shell-novice/_episodes/07-find.md:522
msgid ""
"~~~\n"
"$ find . -type f\n"
"~~~"
msgstr ""
"~~~\n"
"$ find . -type f\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:527
msgid ""
"~~~\n"
"./writing/LittleWomen.txt\n"
"./writing/haiku.txt\n"
"./creatures/basilisk.dat\n"
"./creatures/unicorn.dat\n"
"./creatures/minotaur.dat\n"
"./animal-counts/animals.csv\n"
"./numbers.txt\n"
"./proteins/ethane.pdb\n"
"./proteins/propane.pdb\n"
"./proteins/octane.pdb\n"
"./proteins/pentane.pdb\n"
"./proteins/methane.pdb\n"
"./proteins/cubane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"./writing/LittleWomen.txt\n"
"./writing/haiku.txt\n"
"./creatures/basilisk.dat\n"
"./creatures/unicorn.dat\n"
"./creatures/minotaur.dat\n"
"./animal-counts/animals.csv\n"
"./numbers.txt\n"
"./proteins/ethane.pdb\n"
"./proteins/propane.pdb\n"
"./proteins/octane.pdb\n"
"./proteins/pentane.pdb\n"
"./proteins/methane.pdb\n"
"./proteins/cubane.pdb\n"
"~~~"

#: shell-novice/_episodes/07-find.md:544
msgid "Now let's try matching by name:"
msgstr "Тепер спробуємо зіставити за іменами:"

# code block
#: shell-novice/_episodes/07-find.md:546
msgid ""
"~~~\n"
"$ find . -name *.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ find . -name *.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:551
msgid ""
"~~~\n"
"./numbers.txt\n"
"~~~"
msgstr ""
"~~~\n"
"./numbers.txt\n"
"~~~"

#: shell-novice/_episodes/07-find.md:556
msgid ""
"We expected it to find all the text files,\n"
"but it only prints out `./numbers.txt`.\n"
"The problem is that the shell expands wildcard characters like `*` *before* commands run.\n"
"Since `*.txt` in the current directory expands to `./numbers.txt`,\n"
"the command we actually ran was:"
msgstr ""
"Ми очікували, що будуть знайдені усі текстові файли,\n"
"але було виведено лише `./numbers.txt`.\n"
"Проблема полягає у тому, що перед виконанням команд оболонка розширює символи підстановки, такі як `*`.\n"
"Оскільки `*.txt` у поточному каталозі розширюється до `./numbers.txt`,\n"
"команда, яку ми виконали, була такою:"

# code block
#: shell-novice/_episodes/07-find.md:562
msgid ""
"~~~\n"
"$ find . -name numbers.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ find . -name numbers.txt\n"
"~~~"

#: shell-novice/_episodes/07-find.md:567
msgid "`find` did what we asked; we just asked for the wrong thing."
msgstr ""
"Команда `find` зробила те, що ми просили; ми просто просили не те, що треба."

#: shell-novice/_episodes/07-find.md:569
msgid ""
"To get what we want,\n"
"let's do what we did with `grep`:\n"
"put `*.txt` in quotes to prevent the shell from expanding the `*` wildcard.\n"
"This way,\n"
"`find` actually gets the pattern `*.txt`, not the expanded filename `numbers.txt`:"
msgstr ""
"Щоб отримати те, що ми хочемо,\n"
"давайте зробимо те, що ми зробили з `grep`:\n"
"візьмемо `*.txt` у лапки, щоб оболонка не змогла розкрити шаблон `*`.\n"
"Таким чином,\n"
"`find` отримає шаблон `*.txt`, а не розширене ім'я файлу `numbers.txt`:"

# code block
#: shell-novice/_episodes/07-find.md:575
msgid ""
"~~~\n"
"$ find . -name \"*.txt\"\n"
"~~~"
msgstr ""
"~~~\n"
"$ find . -name \"*.txt\"\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:580
msgid ""
"~~~\n"
"./writing/LittleWomen.txt\n"
"./writing/haiku.txt\n"
"./numbers.txt\n"
"~~~"
msgstr ""
"~~~\n"
"./writing/LittleWomen.txt\n"
"./writing/haiku.txt\n"
"./numbers.txt\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/07-find.md:587
msgid "> ## Listing vs. Finding"
msgstr "> ## Порівняння результатів `ls` та `find`"

#: shell-novice/_episodes/07-find.md:588
msgid ""
">\n"
"> `ls` and `find` can be made to do similar things given the right options,\n"
"> but under normal circumstances,\n"
"> `ls` lists everything it can,\n"
"> while `find` searches for things with certain properties and shows them."
msgstr ""
">\n"
"> `ls` і `find` можна змусити робити подібні речі за допомогою правильних параметрів,\n"
"> але за звичайних обставин,\n"
"> `ls` перелічує все, що може,\n"
"> тоді як `find` шукає речі з певними властивостями і показує їх."

#: shell-novice/_episodes/07-find.md:595
msgid ""
"As we said earlier,\n"
"the command line's power lies in combining tools.\n"
"We've seen how to do that with pipes;\n"
"let's look at another technique.\n"
"As we just saw,\n"
"`find . -name \"*.txt\"` gives us a list of all text files in or below the current directory.\n"
"How can we combine that with `wc -l` to count the lines in all those files?"
msgstr ""
"Як ми вже говорили раніше,\n"
"сила командного рядка полягає у комбінуванні інструментів.\n"
"Ми бачили, як це можна зробити з каналами;\n"
"давайте подивимося на іншу техніку.\n"
"Як ми щойно бачили,\n"
"`find . -name \"*.txt\"` дає нам список усіх текстових файлів у поточному каталозі або нижче.\n"
"Як ми можемо поєднати це з `wc -l`, щоб порахувати рядки у всіх цих файлах?"

#: shell-novice/_episodes/07-find.md:603
msgid "The simplest way is to put the `find` command inside `$()`:"
msgstr "Найпростіший спосіб - помістити команду `find` всередину `$()`:"

# code block
#: shell-novice/_episodes/07-find.md:605
msgid ""
"~~~\n"
"$ wc -l $(find . -name \"*.txt\")\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l $(find . -name \"*.txt\")\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:610
msgid ""
"~~~\n"
"  21022 ./writing/LittleWomen.txt\n"
"     11 ./writing/haiku.txt\n"
"      5 ./numbers.txt\n"
"  21038 total\n"
"~~~"
msgstr ""
"~~~\n"
"  21022 ./writing/LittleWomen.txt\n"
"     11 ./writing/haiku.txt\n"
"      5 ./numbers.txt\n"
"  21038 total\n"
"~~~"

#: shell-novice/_episodes/07-find.md:618
msgid ""
"When the shell executes this command,\n"
"the first thing it does is run whatever is inside the `$()`.\n"
"It then replaces the `$()` expression with that command's output.\n"
"Since the output of `find` is the three filenames `./writing/LittleWomen.txt`,\n"
"`./writing/haiku.txt`, and `./numbers.txt`, the shell constructs the command:"
msgstr ""
"Коли термінал виконуватиме цю команду,\n"
"перше, що він зробить, це виконає все, що міститься у виразі `$()`.\n"
"Потім він замінить вираз `$()` на результати виконання цієї команди.\n"
"Оскільки результатом команди `find` є три файли `./writing/LittleWomen.txt`,\n"
"`./writing/haiku.txt` і `./numbers.txt`, термінал сконструює команду:"

# code block
#: shell-novice/_episodes/07-find.md:624
msgid ""
"~~~\n"
"$ wc -l ./writing/LittleWomen.txt ./writing/haiku.txt ./numbers.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l ./writing/LittleWomen.txt ./writing/haiku.txt ./numbers.txt\n"
"~~~"

#: shell-novice/_episodes/07-find.md:629
msgid ""
"which is what we wanted.\n"
"This expansion is exactly what the shell does when it expands wildcards like `*` and `?`,\n"
"but lets us use any command we want as our own 'wildcard'."
msgstr ""
"що ми і хотіли.\n"
"Таке розширення виконує саме те, що робить термінал, коли розширює такі символи, як `*` та `?`,\n"
"але дозволяє нам використовувати будь-яку команду як власну \"шаблонну\"."

#: shell-novice/_episodes/07-find.md:633
msgid ""
"It's very common to use `find` and `grep` together.\n"
"The first finds files that match a pattern;\n"
"the second looks for lines inside those files that match another pattern.\n"
"Here, for example, we can find txt files that contain the word \"searching\"\n"
"by looking for the string 'searching' in all the `.txt` files in the current directory:"
msgstr ""
"Дуже часто `find` і `grep` використовують разом.\n"
"Перша знаходить файли, які відповідають певному шаблону;\n"
"другий шукає рядки всередині цих файлів, які відповідають іншому шаблону.\n"
"Наприклад, ми можемо знайти txt-файли, які містять слово \"searching\"\n"
"шляхом пошуку рядка 'searching' у всіх файлах `.txt` у поточному каталозі:"

# code block
#: shell-novice/_episodes/07-find.md:639
msgid ""
"~~~\n"
"$ grep \"searching\" $(find . -name \"*.txt\")\n"
"~~~"
msgstr ""
"~~~\n"
"$ grep \"searching\" $(find . -name \"*.txt\")\n"
"~~~"

# code block
#: shell-novice/_episodes/07-find.md:644
msgid ""
"~~~\n"
"./writing/LittleWomen.txt:sitting on the top step, affected to be searching for her book, but was\n"
"./writing/haiku.txt:With searching comes loss\n"
"~~~"
msgstr ""
"~~~\n"
"./writing/LittleWomen.txt:sitting on the top step, affected to be searching for her book, but was\n"
"./writing/haiku.txt:With searching comes loss\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/07-find.md:650
msgid "> ## Matching and Subtracting"
msgstr "> ## Порівняння та віднімання"

#: shell-novice/_episodes/07-find.md:651
msgid ""
">\n"
"> The `-v` option to `grep` inverts pattern matching, so that only lines\n"
"> which do *not* match the pattern are printed. Given that, which of\n"
"> the following commands will find all .dat files in `creatures`\n"
"> except `unicorn.dat`?\n"
"> Once you have thought about your answer, you can test the commands in the\n"
"> `shell-lesson-data/exercise-data` directory.\n"
">\n"
"> 1.  `find creatures -name \"*.dat\" | grep -v unicorn`\n"
"> 2.  `find creatures -name *.dat | grep -v unicorn`\n"
"> 3.  `grep -v \"unicorn\" $(find creatures -name \"*.dat\")`\n"
"> 4.  None of the above.\n"
">\n"
"> > ## Solution\n"
"> > Option 1. is correct. Putting the match expression in quotes prevents the shell\n"
"> > expanding it, so it gets passed to the `find` command.\n"
"> >\n"
"> > Option 2 is also works in this instance because the shell tries to expand `*.dat`\n"
"> > but there are no `*.dat` files in the current directory,\n"
"> > so the wildcard expression gets passed to `find`.\n"
"> > We first encountered this in\n"
"> > [episode 3]({{ page.root }}{% link _episodes/03-create.md %}/#wildcards).\n"
"> >\n"
"> > Option 3 is incorrect because it searches the contents of the files for lines which\n"
"> > do not match 'unicorn', rather than searching the file names."
msgstr ""
">\n"
"> Параметр `-v` до `grep` інвертує відповідність шаблону, щоб виводилися лише рядки,\n"
"> які *не* збігаються з шаблоном. Враховуючи це, яка з\n"
"> наступних команд знайде усі файли .dat у `creatures`\n"
"> окрім `unicorn.dat`?\n"
"> Після того, як ви обміркуєте свою відповідь, ви можете протестувати команди у\n"
"> каталогу `shell-lesson-data/exercise-data`.\n"
">\n"
"> 1. `find creatures -name \"*.dat\" | grep -v unicorn`.\n"
"> 2. `find creatures -name *.dat | grep -v unicorn`\n"
"> 3. `grep -v \"unicorn\" $(find creatures -name \"*.dat\")`\n"
"> 4. Нічого з перерахованого вище.\n"
">\n"
"> > ## Розв'язання\n"
"> > Варіант 1 правильний. Взяття виразу збігу у лапки запобігає тому, щоб термінал\n"
"> > розгортав його перед передачею команді `find`.\n"
"> >\n"
"> > Варіант 2 також працює у цьому випадку, оскільки термінал намагається розгорнути `*.dat`.\n"
"> > але у поточному каталозі немає файлів `*.dat`,\n"
"> > тому вираз підстановки буде передано до `find`.\n"
"> > Вперше ми зіткнулися з цим у\n"
"> > [епізоді 3] ({{ page.root }}{% link _episodes/03-create.md %}/#підстановочні-символи).\n"
"> >\n"
"> > Варіант 3 є неправильним, оскільки він шукає у вмісті файлів рядки, які\n"
"> > не збігаються зі словом 'unicorn', а не імена файлів."

# blockquote, which can be cascaded
#: shell-novice/_episodes/07-find.md:679
msgid "> ## Binary Files"
msgstr "> ## Двійкові файли"

#: shell-novice/_episodes/07-find.md:680
msgid ""
">\n"
"> We have focused exclusively on finding patterns in text files. What if\n"
"> your data is stored as images, in databases, or in some other format?\n"
">\n"
"> A handful of tools extend `grep` to handle a few non text formats. But a\n"
"> more generalizable approach is to convert the data to text, or\n"
"> extract the text-like elements from the data. On the one hand, it makes simple\n"
"> things easy to do. On the other hand, complex things are usually impossible. For\n"
"> example, it's easy enough to write a program that will extract X and Y\n"
"> dimensions from image files for `grep` to play with, but how would you\n"
"> write something to find values in a spreadsheet whose cells contained\n"
"> formulas?\n"
">\n"
"> A last option is to recognize that the shell and text processing have\n"
"> their limits, and to use another programming language.\n"
"> When the time comes to do this, don't be too hard on the shell: many\n"
"> modern programming languages have borrowed a lot of\n"
"> ideas from it, and imitation is also the sincerest form of praise."
msgstr ""
">\n"
"> Ми зосередилися виключно на пошуку шаблонів у текстових файлах. Що робити, якщо\n"
"> ваші дані зберігаються у вигляді зображень, баз даних або в іншому форматі?\n"
">\n"
"> Кілька утиліт розширюють `grep` для роботи з деякими нетекстовими форматами. Але\n"
"> більш узагальненим підходом є перетворення даних у текст, або\n"
"> вилучення текстових елементів з даних. З одного боку, це робить прості\n"
"> речі легкими для виконання. З іншого боку, складні речі, як правило, неможливі. Наприклад,\n"
"> досить легко написати програму, яка буде витягувати\n"
"> розміри X та Y з файлів зображень, щоб `grep` міг погратися з ними, але як би ви\n"
"> написати щось для пошуку значень у електронній таблиці, клітинки якої містять\n"
"> формули?\n"
">\n"
"> Останній варіант - визнати, що термінал і обробка тексту мають\n"
"> свої межі, і використовувати іншу мову програмування.\n"
"> Коли прийде час це зробити, не будьте надто суворими до терміналу: багато\n"
"> сучасних мов програмування запозичили багато\n"
"> ідей з нього, а наслідування також є найщирішою формою похвали."

#: shell-novice/_episodes/07-find.md:700
msgid ""
"The Unix shell is older than most of the people who use it. It has\n"
"survived so long because it is one of the most productive programming\n"
"environments ever created --- maybe even *the* most productive. Its syntax\n"
"may be cryptic, but people who have mastered it can experiment with\n"
"different commands interactively, then use what they have learned to\n"
"automate their work. Graphical user interfaces may be easier to use at\n"
"first, but once learned, the productivity in the shell is unbeatable.\n"
"And as Alfred North Whitehead wrote in 1911, 'Civilization advances by\n"
"extending the number of important operations which we can perform\n"
"without thinking about them.'"
msgstr ""
"Термінал Unix старіший за більшість людей, які нею користуються. Він\n"
"проіснував так довго, тому що це одне з найпродуктивніших середовищ для програмування,\n"
"коли-небудь створених - можливо, навіть *найпродуктивнішим*. Його синтаксис\n"
"може бути незрозумілим, але люди, які його опанували, можуть експериментувати з\n"
"різними командами в інтерактивному режимі, а потім використовувати те, чого вони навчилися, для\n"
"автоматизації своєї роботи. Графічні інтерфейси користувача можуть бути простішими у використанні\n"
"спочатку, але після того, як після опанування терміналу, продуктивність роботи в ньому буде неперевершеною.\n"
"І як писав Альфред Норт Уайтхед у 1911 році: \"Цивілізація розвивається шляхом\n"
"збільшення кількості важливих операцій, які ми можемо виконувати,\n"
"не замислюючись про них\"."

# blockquote, which can be cascaded
#: shell-novice/_episodes/07-find.md:711
msgid "> ## `find` Pipeline Reading Comprehension"
msgstr "> ## Розуміння читання конвеєру `find`"

# blockquote, which can be cascaded
#: shell-novice/_episodes/07-find.md:712
msgid "> "
msgstr "> "

# blockquote, which can be cascaded
#: shell-novice/_episodes/07-find.md:713
msgid "> Write a short explanatory comment for the following shell script:"
msgstr ""
"> Напишіть короткий пояснювальний коментар до наступного скрипту термінала:"

#: shell-novice/_episodes/07-find.md:714
msgid ""
">\n"
"> ~~~\n"
"> wc -l $(find . -name \"*.dat\") | sort -n\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Solution\n"
"> > 1. Find all files with a `.dat` extension recursively from the current directory\n"
"> > 2. Count the number of lines each of these files contains\n"
"> > 3. Sort the output from step 2. numerically"
msgstr ""
">\n"
"> ~~~\n"
"> wc -l $(find . -name \"*.dat\") | sort -n\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Розв'язання\n"
"> > 1. Рекурсивно знайти всі файли з розширенням `.dat` у поточному каталозі\n"
"> > 2. Підрахувати кількість рядків у кожному з цих файлів\n"
"> > 3. Відсортувати вивід з пункту 2. за числовим значенням"

# Front Matter
#: shell-novice/_extras/about.md:1
msgid ""
"---\n"
"layout: page\n"
"title: About\n"
"---"
msgstr ""
"---\n"
"layout: page\n"
"title: Про курс\n"
"---"

#: shell-novice/_extras/about.md:5
msgid "{% include carpentries.html %}"
msgstr "{% include carpentries.html %}"

# Front Matter
#: shell-novice/_extras/discuss.md:1
msgid ""
"---\n"
"layout: page\n"
"title: \"Discussion\"\n"
"---"
msgstr ""
"---\n"
"layout: page\n"
"title: \"Обговорення\"\n"
"---"

# header
#: shell-novice/_extras/discuss.md:5
msgid "## Alphabet Soup"
msgstr "## Алфавітний суп"

#: shell-novice/_extras/discuss.md:7
msgid ""
"If the command to find out who we are is `whoami`, the command to find\n"
"out where we are ought to be called `whereami`, so why is it `pwd`\n"
"instead? The usual answer is that in the early 1970s, when Unix was\n"
"first being developed, every keystroke counted: the devices of the day\n"
"were slow, and backspacing on a teletype was so painful that cutting the\n"
"number of keystrokes in order to cut the number of typing mistakes was\n"
"actually a win for usability. The reality is that commands were added to\n"
"Unix one by one, without any master plan, by people who were immersed in\n"
"its jargon. The result is as inconsistent as the roolz uv Inglish\n"
"speling, but we're stuck with it now."
msgstr ""
"Якщо команда дізнатися, хто ми є, називається `whoami`, то команда дізнатися,\n"
"де ми є, повинна називатися `whereami`, так чому ж тоді вона зветься `pwd`\n"
"натомість? Звичайна відповідь полягає в тому, що на початку 1970-х років, коли Unix\n"
"тільки розроблявся, враховувалося кожне натискання клавіш: тодішні пристрої\n"
"були повільними, а переноси на телетайпі були настільки болючими, що скорочення\n"
"кількості натискань клавіш, щоб зменшити кількість помилок при наборі тексту, було\n"
"насправді виграшем для зручності використання. Реальність така, що команди додавалися до\n"
"Unix одна за одною, без жодного генерального плану, людьми, які були занурені в\n"
"його жаргон. Результат настільки ж непослідовний, як і англійський правопис 'roolz uv Inglish'\n"
"але ми застрягли з цим зараз."

# header
#: shell-novice/_extras/discuss.md:18
msgid "## Job Control Codes"
msgstr "## Коди керування завданнями"

#: shell-novice/_extras/discuss.md:20
msgid ""
"The shell accepts a few special commands that allow users to interact\n"
"with running processes or programs. You can enter each of these\n"
"\"control codes\" by holding down the `Ctrl` key and then pressing one\n"
"of the control characters. In other tutorials, you may see the term\n"
"`Control` or the `^` used to represent the `Ctrl` key (e.g. the\n"
"following are all equivalent `Ctrl-C`, `Ctrl+C`, `Control-C`, `Control+C`, `^C`)."
msgstr ""
"Термінал приймає кілька спеціальних команд, які дозволяють користувачам взаємодіяти\n"
"з запущеними процесами або програмами. Ви можете ввести кожен з цих\n"
"\"кодів керування\", утримуючи клавішу `Ctrl`, а потім натиснувши один\n"
"з керуючих символів. В інших підручниках ви можете зустріти термін\n"
"`Control` або `^`, який використовується для позначення клавіші `Ctrl` (наприклад\n"
"наведені нижче комбінації є еквівалентними `Ctrl-C`, `Ctrl+C`, `Control-C`, `Control+C`, `^C`)."

# unordered list
#: shell-novice/_extras/discuss.md:27
msgid "*   `Ctrl-C`:"
msgstr "*   `Ctrl-C`:"

#: shell-novice/_extras/discuss.md:28
msgid ""
"    interrupts and cancels a running program.\n"
"    This is useful if you want to cancel a command that is taking too long to execute."
msgstr ""
"    перериває і скасовує запущену програму.\n"
"    Це корисно, якщо ви хочете скасувати команду, яка виконується надто довго."

# unordered list
#: shell-novice/_extras/discuss.md:31
msgid "*   `Ctrl-D`:"
msgstr "*   `Ctrl-D`:"

#: shell-novice/_extras/discuss.md:32
msgid ""
"    indicates the end of a file or stream of characters that you are entering on the command line.\n"
"    For example, we saw earlier that the `wc` command counts lines, words, and characters in a file.\n"
"    If we just type `wc` and hit the Enter key without providing a file name,\n"
"    then `wc` will assume we want it to analyze all the stuff we type next.\n"
"    After typing our magnum opus directly into the shell prompt,\n"
"    we can then type Ctrl-D to tell `wc` that we're done\n"
"    and we'd like to see the results of the word count."
msgstr ""
"    вказує на кінець файлу або потоку символів, які ви вводите у командному рядку.\n"
"    Наприклад, раніше ми бачили, що команда `wc` підраховує рядки, слова і символи у файлі.\n"
"    Якщо ми просто введемо `wc` і натиснемо клавішу Enter, не вказавши назву файлу,\n"
"    то `wc` вважатиме, що ми хочемо, щоб вона проаналізувала все, що ми введемо далі.\n"
"    Після введення нашого грандіозного опусу безпосередньо у командний рядок,\n"
"    ми можемо натиснути Ctrl-D, щоб сказати `wc`, що ми закінчили\n"
"    і хочемо побачити результати підрахунку слів."

# unordered list
#: shell-novice/_extras/discuss.md:40
msgid "*   `Ctrl-Z`:"
msgstr "*   `Ctrl-Z`:"

#: shell-novice/_extras/discuss.md:41
msgid ""
"    Suspends a process but does not terminate it.\n"
"    You can then use the command `fg` to restart the job in the foreground."
msgstr ""
"    Призупиняє процес, але не завершує його.\n"
"    Потім ви можете скористатися командою `fg`, щоб перезапустити завдання на передньому плані."

#: shell-novice/_extras/discuss.md:44
msgid ""
"For new shell users, these control codes can all appear to have\n"
"the same effect: they make things \"go away.\" But it is helpful to\n"
"understand the differences. In general, if something went wrong and\n"
"you just want to get your shell prompt back, it is better to use\n"
"`Ctrl-C`."
msgstr ""
"Для нових користувачів терміналу всі ці контрольні коди можуть мати\n"
"однаковий ефект: вони змушують все \"зникнути\". Але корисно\n"
"розуміти відмінності. Загалом, якщо щось пішло не так\n"
"і ви просто хочете повернути командний рядок, краще скористатися комбінацією\n"
"`Ctrl-C`."

# header
#: shell-novice/_extras/discuss.md:50
msgid "## Other Shells"
msgstr "## Інші термінали"

#: shell-novice/_extras/discuss.md:52
msgid ""
"Before Bash became popular in the end of nineties, scientists widely\n"
"used (and some still use) another shell, C-shell, or Csh. Bash and Csh\n"
"have similar feature sets, but their syntax rules are different and\n"
"this makes them incompatible with each other. A few other shells have\n"
"appeared since, including ksh, zsh, and a number of others; they are\n"
"mostly compatible with Bash, and Bash is the default shell on most\n"
"modern implementations of Unix (including most packages that provide\n"
"Unix-like tools for Windows) but if you get strange errors in shell\n"
"scripts written by colleagues, check to see which shell they were\n"
"written for."
msgstr ""
"До того, як Bash став популярним наприкінці дев'яностих, вчені широко\n"
"використовували (а дехто й досі використовує) інший термінал, C-термінал, або Csh. Bash і Csh\n"
"мають схожі набори функцій, але їх синтаксичні правила відрізняються, і\n"
"це робить їх несумісними один з одним. Кілька інших терміналів\n"
"з'явилося з тих пір, включаючи ksh, zsh і ряд інших; вони\n"
"здебільшого сумісні з Bash, а Bash - це термінал за замовчуванням у більшості\n"
"сучасних реалізацій Unix (включаючи більшість пакунків, які надають\n"
"Unix-подібні інструменти для Windows), але якщо ви отримуєте дивні помилки у\n"
"скриптах, написаних колегами, перевірте, для якого терміналу\n"
"вони були написані."

# header
#: shell-novice/_extras/discuss.md:63
msgid "## Bash Configurations"
msgstr "## Конфігурації Bash"

#: shell-novice/_extras/discuss.md:65
msgid ""
"Want to customize paths, environment variables, aliases,\n"
"and other behaviors of your shell?\n"
"This excellent blog post \"[Bash Configurations Demystified][bash-demystified]\"\n"
"from Dalton Hubble\n"
"covers tips, tricks, and how to avoid dangers."
msgstr ""
"Хочете налаштувати шляхи, змінні оточення, псевдоніми,\n"
"та інші параметри вашого терміналу?\n"
"Ця чудова стаття в блозі \"[Bash Configurations Demystified][bash-demystified]\"\n"
"від Далтона Хаббла\n"
"містить поради, підказки та способи уникнення небезпек."

#: shell-novice/_extras/discuss.md:71
msgid ""
"[bash-demystified]: https://blog.dghubble.io/posts/.bashprofile-.profile-"
"and-.bashrc-conventions/"
msgstr ""
"[bash-demystified]: https://blog.dghubble.io/posts/.bashprofile-.profile-"
"and-.bashrc-conventions/"

# Front Matter
#: shell-novice/_extras/figures.md:1
msgid ""
"---\n"
"title: Figures\n"
"---"
msgstr ""
"---\n"
"title: Рисунки\n"
"---"

# inline html
#: shell-novice/_extras/figures.md:4
msgid ""
"<script>\n"
"  window.onload = function() {\n"
"    var lesson_episodes = [\n"
"    {% for episode in site.episodes %}\n"
"    \"{{ episode.url}}\"{% unless forloop.last %},{% endunless %}\n"
"    {% endfor %}\n"
"    ];\n"
"    var xmlHttp = [];  /* Required since we are going to query every episode. */\n"
"    for (i=0; i < lesson_episodes.length; i++) {\n"
"      xmlHttp[i] = new XMLHttpRequest();\n"
"      xmlHttp[i].episode = lesson_episodes[i];  /* To enable use this later. */\n"
"      xmlHttp[i].onreadystatechange = function() {\n"
"        if (this.readyState == 4 && this.status == 200) {\n"
"          var article_here = document.getElementById(this.episode);\n"
"          var parser = new DOMParser();\n"
"          var htmlDoc = parser.parseFromString(this.responseText,\"text/html\");\n"
"          var htmlDocArticle = htmlDoc.getElementsByTagName(\"article\")[0];\n"
"          article_here.appendChild(htmlDocArticle.getElementsByTagName(\"h1\")[0]);\n"
"          for (let image of htmlDocArticle.getElementsByTagName(\"img\")) {\n"
"            article_here.appendChild(image);\n"
"          }\n"
"        }\n"
"      }\n"
"      episode_url = \"{{ page.root }}\" + lesson_episodes[i];\n"
"      xmlHttp[i].open(\"GET\", episode_url);\n"
"      xmlHttp[i].send(null);\n"
"    }\n"
"  }\n"
"</script>"
msgstr ""
"<script>\n"
"  window.onload = function() {\n"
"    var lesson_episodes = [\n"
"    {% for episode in site.episodes %}\n"
"    \"{{ episode.url}}\"{% unless forloop.last %},{% endunless %}\n"
"    {% endfor %}\n"
"    ];\n"
"    var xmlHttp = [];  /* Необхідно, оскільки ми збираємося запитувати кожну серію. */\n"
"    for (i=0; i < lesson_episodes.length; i++) {\n"
"      xmlHttp[i] = new XMLHttpRequest();\n"
"      xmlHttp[i].episode = lesson_episodes[i];  /* Щоб використовувати це пізніше. */\n"
"      xmlHttp[i].onreadystatechange = function() {\n"
"        if (this.readyState == 4 && this.status == 200) {\n"
"          var article_here = document.getElementById(this.episode);\n"
"          var parser = new DOMParser();\n"
"          var htmlDoc = parser.parseFromString(this.responseText,\"text/html\");\n"
"          var htmlDocArticle = htmlDoc.getElementsByTagName(\"article\")[0];\n"
"          article_here.appendChild(htmlDocArticle.getElementsByTagName(\"h1\")[0]);\n"
"          for (let image of htmlDocArticle.getElementsByTagName(\"img\")) {\n"
"            article_here.appendChild(image);\n"
"          }\n"
"        }\n"
"      }\n"
"      episode_url = \"{{ page.root }}\" + lesson_episodes[i];\n"
"      xmlHttp[i].open(\"GET\", episode_url);\n"
"      xmlHttp[i].send(null);\n"
"    }\n"
"  }\n"
"</script>"

#: shell-novice/_extras/figures.md:33
msgid ""
"{% comment %}\n"
"Create anchor for each one of the episodes.\n"
"{% endcomment %}\n"
"{% for episode in site.episodes %}\n"
"<article id=\"{{ episode.url }}\"></article>\n"
"{% endfor %}"
msgstr ""
"{% comment %}\n"
"Create anchor for each one of the episodes.\n"
"{% endcomment %}\n"
"{% for episode in site.episodes %}\n"
"<article id=\"{{ episode.url }}\"></article>\n"
"{% endfor %}"

# Front Matter
#: shell-novice/_extras/guide.md:1
msgid ""
"---\n"
"layout: page\n"
"title: \"Instructor Notes\"\n"
"---"
msgstr ""
"---\n"
"layout: page\n"
"title: \"Примітки інструктора\"\n"
"---"

# unordered list
#: shell-novice/_extras/guide.md:5
msgid "*   Why do we learn to use the shell?"
msgstr "*   Навіщо ми вчимося користуватися терміналом?"

# unordered list
#: shell-novice/_extras/guide.md:6
msgid "    *   Allows users to automate repetitive tasks"
msgstr "    *   Дозволяє користувачам автоматизувати повторювані завдання"

# unordered list
#: shell-novice/_extras/guide.md:7
msgid ""
"    *   And capture small data manipulation steps that are normally not "
"recorded"
msgstr ""
"    *   І фіксує невеликі кроки маніпуляцій з даними, які зазвичай не "
"записуються"

#: shell-novice/_extras/guide.md:8
msgid ""
"        to make research reproducible\n"
"*   The Problem\n"
"    *   Running the same workflow on several samples can be unnecessarily labour intensive\n"
"    *   Manual manipulation of data files:\n"
"        *   is often not captured in documentation\n"
"        *   is hard to reproduce\n"
"        *   is hard to troubleshoot, review, or improve\n"
"*   The Shell\n"
"    *   Workflows can be automated through the use of shell scripts\n"
"    *   Built-in commands allow for easy data manipulation (e.g. sort, grep, etc.)\n"
"    *   Every step can be captured in the shell script and allow reproducibility and\n"
"        easy troubleshooting"
msgstr ""
"        для того, щоб зробити дослідження відтворюваними\n"
"*   Проблема\n"
"    *   Запуск одного і того ж робочого процесу для декількох зразків може бути невиправдано трудомістким\n"
"    *   Ручна маніпуляція з файлами даних:\n"
"        *   часто не відображається в документації\n"
"        *   важко відтворити\n"
"        *   важко усунути несправності, переглянути або вдосконалити\n"
"*   Термінал\n"
"    *   Робочі процеси можна автоматизувати за допомогою скриптів терміналу\n"
"    *   Вбудовані команди дозволяють легко маніпулювати даними (наприклад, sort, grep тощо).\n"
"    *   Кожен крок може бути зафіксований у скрипті терміналу, що забезпечує відтворюваність та\n"
"        легке усунення несправностей"

# header
#: shell-novice/_extras/guide.md:21
msgid "## Overall"
msgstr "## Загальний підсумок"

#: shell-novice/_extras/guide.md:23
msgid ""
"Many people have questioned whether we should still teach the shell.\n"
"After all,\n"
"anyone who wants to rename several thousand data files\n"
"can easily do so interactively in the Python interpreter,\n"
"and anyone who's doing serious data analysis\n"
"is probably going to do most of their work inside the IPython Notebook or R Studio.\n"
"So why teach the shell?"
msgstr ""
"Багато хто ставить під сумнів, чи варто продовжувати вчити термінал.\n"
"Зрештою,\n"
"будь-хто, хто хоче перейменувати кілька тисяч файлів даних,\n"
"може легко зробити це інтерактивно в інтерпретаторі Python,\n"
"і будь-хто, хто займається серйозним аналізом даних\n"
"швидше за все, буде виконувати більшу частину своєї роботи в IPython Notebook або в R Studio.\n"
"Тож навіщо навчатися роботі в терміналі?"

#: shell-novice/_extras/guide.md:31
msgid ""
"The first answer is,\n"
"\"Because so much else depends on it.\"\n"
"Installing software,\n"
"configuring your default editor,\n"
"and controlling remote machines frequently assume a basic familiarity with the shell,\n"
"and with related ideas like standard input and output.\n"
"Many tools also use its terminology\n"
"(for example, the `%ls` and `%cd` magic commands in IPython)."
msgstr ""
"Перша відповідь така:\n"
"\"Тому що від цього залежить так багато іншого\".\n"
"Встановлення програмного забезпечення,\n"
"налаштування редактора за замовчуванням\n"
"та керування віддаленими комп'ютерами часто вимагають базового знайомства з командним терміналом\n"
"та пов'язаними з ним поняттями, такими як стандартний ввід та вивід.\n"
"Багато інструментів також використовують його термінологію\n"
"(наприклад, магічні команди `%ls` та `%cd` в IPython)."

#: shell-novice/_extras/guide.md:40
msgid ""
"The second answer is,\n"
"\"Because it's an easy way to introduce some fundamental ideas about how to use computers.\"\n"
"As we teach people how to use the Unix shell,\n"
"we teach them that they should get the computer to repeat things\n"
"(via tab completion,\n"
"`!` followed by a command number,\n"
"and `for` loops)\n"
"rather than repeating things themselves.\n"
"We also teach them to take things they've discovered they do frequently\n"
"and save them for later re-use\n"
"(via shell scripts),\n"
"to give things sensible names,\n"
"and to write a little bit of documentation\n"
"(like comment at the top of shell scripts)\n"
"to make their future selves' lives better."
msgstr ""
"Друга відповідь така:\n"
"\"Тому що це простий спосіб представити деякі фундаментальні ідеї про те, як користуватися комп'ютером\".\n"
"Коли ми вчимо людей користуватися терміналом Unix,\n"
"ми вчимо їх, що вони повинні змусити комп'ютер повторювати дії\n"
"(за допомогою завершення клавішею табуляції,\n"
"знаком `!`, за яким йде номер команди,\n"
"та циклів \"for\").\n"
"замість того, щоб повторювати щось самому.\n"
"Ми також вчимо їх брати речі, які, як вони виявили, вони роблять часто,\n"
"і зберігати їх для подальшого використання\n"
"(за допомогою скриптів терміналу),\n"
"давати речам розумні назви\n"
"і писати невелику документацію\n"
"(наприклад, коментар у верхній частині скрипта терміналу)\n"
"щоб покращити життя своїх майбутніх поколінь."

#: shell-novice/_extras/guide.md:56
msgid ""
"The third answer is,\n"
"\"Because it enables use of many domain-specific tools and compute resources researchers\n"
"cannot access otherwise.\"\n"
"Familiarity with the shell is very useful for remote accessing machines,\n"
"using high-performance computing infrastructure,\n"
"and running new specialist tools in many disciplines.\n"
"We do not teach HPC or domain-specific skills here\n"
"but lay the groundwork for further development of these skills.\n"
"In particular,\n"
"understanding the syntax of commands, flags, and help systems is useful for domain specific tools\n"
"and understanding the file system (and how to navigate it) is useful for remote access."
msgstr ""
"Третя відповідь така:\n"
"\"Тому що це дозволяє використовувати багато специфічних інструментів та обчислювальних ресурсів,\n"
"до яких дослідники не можуть отримати доступ інакше\".\n"
"Знайомство з терміналом дуже корисне для віддаленого доступу до машин,\n"
"використання високопродуктивної обчислювальної інфраструктури\n"
"та запуску нових спеціалізованих інструментів у багатьох дисциплінах.\n"
"Ми не навчаємо навичкам роботи з високопродуктивними обчислювальними системами або роботі в конкретних галузях,\n"
"але закладаємо основу для подальшого розвитку цих навичок.\n"
"Зокрема,\n"
"розуміння синтаксису команд, прапорів та довідкових систем є корисним для роботи з специфічними інструментами,\n"
"а розуміння файлової системи (та способів навігації по ній) корисне для віддаленого доступу."

#: shell-novice/_extras/guide.md:68
msgid ""
"Finally,\n"
"and perhaps most importantly,\n"
"teaching people the shell lets us teach them\n"
"to think about programming in terms of function composition.\n"
"In the case of the shell,\n"
"this takes the form of pipelines rather than nested function calls,\n"
"but the core idea of \"small pieces, loosely joined\" is the same."
msgstr ""
"Нарешті,\n"
"і, можливо, найважливіше,\n"
"навчання людей терміналу дозволяє нам навчити їх\n"
"думати про програмування з точки зору композиції функцій.\n"
"У випадку з терміналом\n"
"це має форму конвеєрів, а не вкладених викликів функцій,\n"
"але основна ідея \"маленьких шматочків, нещільно з'єднаних між собою\" залишається тією ж самою."

#: shell-novice/_extras/guide.md:76
msgid ""
"All of this material can be covered in three hours\n"
"as long as learners using Windows do not run into roadblocks such as:"
msgstr ""
"Весь цей матеріал можна охопити за три години\n"
"за умови, що учні, які використовують Windows, не натраплять на такі перешкоди, як:"

# unordered list
#: shell-novice/_extras/guide.md:79
msgid "*   not being able to figure out where their home directory is"
msgstr "*   неможливысть з'ясувати, де знаходиться їхня домашня директорія"

#: shell-novice/_extras/guide.md:80
msgid ""
"    (particularly if they're using Cygwin);\n"
"*   not being able to run a plain text editor;\n"
"    and\n"
"*   the shell refusing to run scripts that include DOS line endings."
msgstr ""
"    (особливо якщо вони використовують Cygwin);\n"
"*   невміння запустити звичайний текстовий редактор;\n"
"    та\n"
"*   відмова терміналу виконувати скрипти, які містять закінчення рядків DOS."

# header
#: shell-novice/_extras/guide.md:85
msgid "## Preparing to Teach"
msgstr "## Підготовка до викладання"

# unordered list
#: shell-novice/_extras/guide.md:87
msgid ""
"*   Use the `data` directory for in-workshop exercises and live coding "
"examples."
msgstr ""
"*   Використовуйте каталог `data` для вправ на семинарах та прикладів "
"кодування в реальному часі."

#: shell-novice/_extras/guide.md:88
msgid ""
"    You can clone the shell-novice directory or use the *Download ZIP*\n"
"    button on the right to get the entire\n"
"    [Git repository](https://github.com/swcarpentry/shell-novice). We also now provide\n"
"    a zip file of the `data` directory\n"
"    at the [Setup page]({{ page.root }}{% link setup.md %})."
msgstr ""
"    Ви можете клонувати каталог shell-novice або використати *Завантажити ZIP*.\n"
"    кнопку праворуч, щоб отримати увесь\n"
"    [Git репозиторій](https://github.com/swcarpentry/shell-novice). Також тепер ми надаємо\n"
"    zip-файл каталогу `data`\n"
"    на [Сторінці налаштування]({{ page.root }}{% link setup.md %})."

# unordered list
#: shell-novice/_extras/guide.md:94
msgid "*   Website: various practices have been used."
msgstr "*   Веб-сайт: використовувалися різні практики."

# unordered list
#: shell-novice/_extras/guide.md:95
msgid ""
"    *   Option 1: Can give links to learners before the lesson so they can "
"follow along,"
msgstr ""
"    *   Варіант 1: Ви можете дати учням посилання перед початком уроку, щоб "
"вони могли слідувати за ним,"

#: shell-novice/_extras/guide.md:96
msgid ""
"        catch up,\n"
"\tand see exercises (particularly if you're following the lesson content without many changes).\n"
"    *   Option 2: Don't show the website to the learners during the lesson,\n"
"        as it can be distracting:\n"
"        students may read instead of listen, and having another window open is an additional\n"
"        cognitive load.\n"
"\t*   In any case, make sure to point to website as a post-workshop reference."
msgstr ""
"        надолужити пропущене\n"
"\tта переглянути вправи (особливо якщо ви дотримуєтесь змісту уроку без особливих змін).\n"
"    *   Варіант 2: Не показуйте веб-сайт учням під час уроку,\n"
"        оскільки це може відволікати:\n"
"        учні можуть читати замість того, щоб слухати, а відкрите вікно - це додаткове\n"
"        когнітивне навантаження.\n"
"\t*   У будь-якому випадку, не забудьте вказати на веб-сайт як на джерело інформації після воркшопу."

# unordered list
#: shell-novice/_extras/guide.md:104
msgid "*   Content:"
msgstr "*   Зміст:"

#: shell-novice/_extras/guide.md:105
msgid ""
"    Unless you have a truly generous amount of time (4+ hours),\n"
"    it is likely that you will not cover ALL the material in this lesson in a single half-day\n"
"    session.\n"
"    Plan ahead on what you might skip, what you really want to emphasize, etc."
msgstr ""
"    Якщо ви не маєте справді щедрої кількості часу (4+ години),\n"
"    швидше за все, ви не зможете охопити весь матеріал цього уроку за один урок тривалістю у половину дня.\n"
"    Заздалегідь сплануйте, що ви можете пропустити, на чому хочете наголосити тощо."

# unordered list
#: shell-novice/_extras/guide.md:110
msgid "*   Exercises:"
msgstr "*   Вправи:"

#: shell-novice/_extras/guide.md:111
msgid ""
"    Think in advance about how you might want to handle exercises during the lesson.\n"
"    How are you assigning them (website, slide, handout)?\n"
"    Do you want everyone to try it and then you show the solution?\n"
"    Have a learner show the solution?\n"
"    Have groups each do a different exercise and present their solutions?"
msgstr ""
"    Заздалегідь продумайте, як ви будете працювати з вправами під час уроку.\n"
"    Як ви їх роздаєте (веб-сайт, слайд, роздатковий матеріал)?\n"
"    Ви хочете, щоб кожен спробував, а потім ви показали розв'язання?\n"
"    Чи попросити когось з учнів показати розв'язання?\n"
"    Доручити групам виконати різні вправи і презентувати свої рішення?"

# unordered list
#: shell-novice/_extras/guide.md:117
msgid ""
"*   The [Reference page]({{ page.root }}{% link reference.md %}) can be "
"printed out"
msgstr ""
"*   Сторінку [Посилання]({{ page.root }}{% link reference.md %}) можна "
"роздрукувати"

#: shell-novice/_extras/guide.md:118
msgid "    and given to students as a reference, your choice."
msgstr "    і дати студентам для ознайомлення, на ваш вибір."

# unordered list
#: shell-novice/_extras/guide.md:120
msgid "*   Other preparation:"
msgstr "*   Інші приготування:"

#: shell-novice/_extras/guide.md:121
msgid ""
"    Feel free to add your own examples or side comments,\n"
"    but know that it shouldn't be necessary:\n"
"    the topics and commands can be taught as given on the lesson pages.\n"
"    If you think there is a place where the lesson is lacking,\n"
"    feel free to file an issue or submit a pull request."
msgstr ""
"    Не соромтеся додавати власні приклади чи коментарі,\n"
"    але знайте, що це не обов'язково:\n"
"    теми і команди можна викладати так, як вони подані на сторінках уроків.\n"
"    Якщо ви вважаєте, що в уроці чогось не вистачає,\n"
"    не соромтеся повідомити про проблему або створити запит на зміну матеріалу."

# header
#: shell-novice/_extras/guide.md:127
msgid "## Teaching Notes"
msgstr "## Викладацькі нотатки"

# unordered list
#: shell-novice/_extras/guide.md:129
msgid "*   Super cool online resource!"
msgstr "*   Супер крутий онлайн-ресурс!"

#: shell-novice/_extras/guide.md:130
msgid ""
"    <http://explainshell.com/> will dissect any shell command you type in\n"
"    and display help text for each piece.\n"
"    Additional nice manual tool could be <http://tldr-pages.github.io/>\n"
"    with short very descriptive manuals for shell commands,\n"
"    useful especially on Windows while using Git BASH where `man` could not work."
msgstr ""
"    <http://explainshell.com/> детально проаналізує будь-яку команду оболонки, яку ви введете,\n"
"    і покаже текст довідки для кожного фрагмента.\n"
"    Додатковим чудовим посібником може бути <http://tldr-pages.github.io/>\n"
"    з короткими дуже докладними інструкціями для команд командного рядка,\n"
"    особливо корисним у Windows під час використання Git Bash, де `man` не може працювати."

# unordered list
#: shell-novice/_extras/guide.md:136
msgid "*   Another super cool online resource is <http://www.shellcheck.net>,"
msgstr ""
"*   Ще один супер крутий онлайн-ресурс - це <http://www.shellcheck.net>,"

#: shell-novice/_extras/guide.md:137
msgid ""
"    which will check shell scripts (both uploaded and typed in) for common "
"errors."
msgstr ""
"    який перевірить скрипти оболонки (як завантажені, так і введені) на "
"наявність типових помилок."

# unordered list
#: shell-novice/_extras/guide.md:139
msgid "*   Resources for \"splitting\" your shell so that recent commands"
msgstr ""
"*   Ресурси для \"розщеплення\" вашої терміналу так, щоб нещодавні команди"

#: shell-novice/_extras/guide.md:140
msgid ""
"    remain in view: <https://github.com/rgaiacs/swc-shell-split-window>."
msgstr ""
"    залишалися в полі зору: <https://github.com/rgaiacs/swc-shell-split-"
"window>."

# unordered list
#: shell-novice/_extras/guide.md:142
msgid ""
"*   Learners can sometimes get trapped within command-line text editors such"
" as"
msgstr ""
"*   Іноді учні можуть потрапити в пастку в текстових редакторах командного "
"рядка, таких як"

#: shell-novice/_extras/guide.md:143
msgid ""
"    Vim, Emacs, or Nano.\n"
"    Closing the terminal emulator and opening a new one can be frustrating\n"
"    as learners will have to navigate to the correct folder again.\n"
"    Our recommendation to mitigate this problem is that instructors should use\n"
"    the same text editor as the learners during workshops (in most cases Nano)."
msgstr ""
"    Vim, Emacs або Nano.\n"
"    Закриття емулятора терміналу та відкриття нового може викликати розчарування\n"
"    оскільки учням доведеться знову переходити до потрібної папки.\n"
"    Для пом'якшення цієї проблеми ми радимо викладачам використовувати\n"
"    той самий текстовий редактор, що й учні під час семінарів (у більшості випадків Nano)."

# unordered list
#: shell-novice/_extras/guide.md:149
msgid "*   Introducing and navigating the filesystem in the shell (covered in"
msgstr ""
"*   Знайомство з файловою системою в терміналі та навігація нею (розглянуто "
"в"

#: shell-novice/_extras/guide.md:150
msgid ""
"    [Navigating Files and Directories]({{ page.root }}{% link _episodes/02-filedir.md %}) section)\n"
"    can be confusing.\n"
"    You may have both terminal and GUI file explorer open side by side so learners can see the\n"
"    content and file structure while they're using terminal to navigate the system."
msgstr ""
"    секції [Навігація файлами та каталогами]({{ page.root }}{% link _episodes/02-filedir.md %}))\n"
"    можуть плутати.\n"
"    Ви можете мати відкриті термінал і графічний провідник файлів поруч, щоб учні могли бачити\n"
"    вміст і структуру файлів, коли вони використовують термінал для навігації системою."

# unordered list
#: shell-novice/_extras/guide.md:155
msgid "*   Tab completion sounds like a small thing: it isn't."
msgstr "*   Завершення клавішею табуляції звучить як дрібниця: це не так."

#: shell-novice/_extras/guide.md:156
msgid ""
"    Re-running old commands using `!123` or `!wc`\n"
"    isn't a small thing either,\n"
"    and neither are wildcard expansion and `for` loops.\n"
"    Each one is an opportunity to repeat one of the big ideas of Software Carpentry:\n"
"    if the computer *can* repeat it,\n"
"    some programmer somewhere will almost certainly have built\n"
"    some way for the computer *to* repeat it."
msgstr ""
"    Повторний запуск старих команд за допомогою `!123` або `!wc`\n"
"    теж не дрібниця,\n"
"    і також дрібницями не є розгортання підстановочних символів та цикли `for`.\n"
"    Кожен із них — це можливість повторити одну з великих ідей Software Carpentry:\n"
"    якщо комп'ютер *може* це повторити,\n"
"    якийсь програміст десь майже напевно створить\n"
"    якийсь спосіб для комп’ютера *повторити* це."

# unordered list
#: shell-novice/_extras/guide.md:164
msgid "*   Building up a pipeline with four or five stages,"
msgstr "*   Побудова конвеєру з чотирма або п'ятьма ступенями,"

#: shell-novice/_extras/guide.md:165
msgid ""
"    then putting it in a shell script for re-use\n"
"    and calling that script inside a `for` loop,\n"
"    is a great opportunity to show how\n"
"    \"seven plus or minus two\"\n"
"    connects to programming.\n"
"    Once we have figured out how to do something moderately complicated,\n"
"    we make it re-usable and give it a name\n"
"    so that it only takes up one slot in working memory\n"
"    rather than several.\n"
"    It is also a good opportunity to talk about exploratory programming:\n"
"    rather than designing a program up front,\n"
"    we can do a few useful things\n"
"    and then retroactively decide which are worth encapsulating\n"
"    for future re-use."
msgstr ""
"    з подальшим розміщенням його в скрипт терміналу для повторного використання\n"
"    і виклик цього сценарію всередині циклу `for`,\n"
"    це чудова можливість показати, як\n"
"    \"сім плюс-мінус два\"\n"
"    пов'язано з програмуванням.\n"
"    Коли ми з’ясували, як зробити щось помірно складне,\n"
"    ми робимо його придатним для повторного використання та даємо йому назву\n"
"    так що він займає лише один слот у робочій пам’яті,\n"
"    а не кілька\n"
"    Це також гарна можливість поговорити про пошукове програмування:\n"
"    замість того, щоб розробляти програму заздалегідь,\n"
"    ми можемо зробити кілька корисних речей\n"
"    а потім заднім числом вирішити, які варті інкапсуляції\n"
"    для майбутнього повторного використання."

# unordered list
#: shell-novice/_extras/guide.md:180
msgid ""
"*   If everything is going well, you can drive home the point that file"
msgstr "*   Якщо все йде добре, ви можете переконати, що розширення файлів"

#: shell-novice/_extras/guide.md:181
msgid ""
"    extensions are essentially there to help computers (and human\n"
"    readers) understand file content and are not a requirement of files\n"
"    (covered briefly in\n"
"    [Navigating Files and Directories]({{ page.root }}{% link _episodes/02-filedir.md %})).\n"
"    This can be done in the\n"
"    [Pipes and Filters]({{ page.root }}{% link _episodes/04-pipefilter.md %}) section by showing\n"
"    that you can redirect standard output to a file without the .txt extension\n"
"    (e.g., lengths), and that the resulting file is still a perfectly usable text file.\n"
"    Make the point that if double-clicked in the GUI, the computer will\n"
"    probably ask you what you want to do."
msgstr ""
"    по суті існують, щоб допомогти комп’ютерам (і людям-\n"
"    читачам) зрозуміти вміст файлів, і не є вимогою для файлів\n"
"    (коротко висвітлено в секції\n"
"    [Навігація файлами та каталогами]({{ page.root }}{% link _episodes/02-filedir.md %})).\n"
"    Це можна зробити в\n"
"    секції [Канали та фільтри]({{ page.root }}{% link _episodes/04-pipefilter.md %}) шляхом демонстрації\n"
"    що ви можете перенаправити стандартний вихід у файл без розширення .txt\n"
"    (наприклад, lengths), і що отриманий файл все ще є цілком придатним для використання текстовим файлом.\n"
"    Зауважте, що у разі подвійного кліку в графічному інтерфейсі комп’ютер буде,\n"
"    напевно, запитувати вас, що ви хочете зробити."

# unordered list
#: shell-novice/_extras/guide.md:192
msgid ""
"*   We have to leave out many important things because of time constraints,"
msgstr "*   Через брак часу нам доводиться пропускати багато важливих речей,"

#: shell-novice/_extras/guide.md:193
msgid ""
"    including file permissions, job control, and SSH.\n"
"    If learners already understand the basic material,\n"
"    this can be covered instead using the online lessons as guidelines.\n"
"    These limitations also have follow-on consequences:"
msgstr ""
"    включаючи дозволи на файли, керування завданнями та SSH.\n"
"    Якщо учні вже розуміють базовий матеріал,\n"
"    цей матеріал можна розглянути, використовуючи онлайн-уроки як орієнтири.\n"
"    Ці обмеження також мають подальші наслідки:"

# unordered list
#: shell-novice/_extras/guide.md:198
msgid "*   It's hard to discuss `#!` (shebang) without first discussing"
msgstr "*   Важко обговорювати `#!` (шебанг), не обговоривши попередньо"

#: shell-novice/_extras/guide.md:199
msgid ""
"    permissions, which we don't do.  `#!` is also [pretty\n"
"    complicated][shebang], so even if we did discuss permissions, we\n"
"    probably still wouldn't want to discuss `#!`."
msgstr ""
"    дозволів, чого ми не робимо. `#!` також [доволі\n"
"    складний][shebang], тож навіть якби ми обговорювали дозволи,\n"
"    ми, мабуть, все одно б не захотіли обговорювати `#!`."

# unordered list
#: shell-novice/_extras/guide.md:203
msgid "*   Installing Bash and a reasonable set of Unix commands on Windows"
msgstr "*   Встановлення Bash та доцільного набору команд Unix на Windows"

#: shell-novice/_extras/guide.md:204
msgid ""
"    always involves some fiddling and frustration.\n"
"    Please see the latest set of installation guidelines for advice,\n"
"    and try it out yourself *before* teaching a class."
msgstr ""
"    завжди пов'язане з деякими клопотами та розчаруваннями.\n"
"    Будь ласка, зверніться до останнього набору інструкцій щодо встановлення для отримання порад,\n"
"    і спробуйте самі, перш ніж викладати у класі."

# unordered list
#: shell-novice/_extras/guide.md:208
msgid "*   On Windows machines"
msgstr "*   На машинах Windows"

#: shell-novice/_extras/guide.md:209
msgid ""
"    if `nano` hasn't been properly installed with the\n"
"    [Software Carpentry Windows Installer][windows-installer]\n"
"    it is possible to use `notepad` as an alternative.  There will be a GUI\n"
"    interface and line endings are treated differently, but otherwise, for\n"
"    the purposes of this lesson, `notepad` and `nano` can be used almost interchangeably."
msgstr ""
"    якщо `nano` не було належним чином встановлено за допомогою\n"
"    [Software Carpentry Windows Installer][windows-installer]\n"
"    можна скористатися `notepad` як альтернативою. У цьому випадку буде використано графічний інтерфейс\n"
"    і закінчення рядків обробляються по-різному, але для\n"
"    цілей цього уроку `notepad` і `nano` можна використовувати майже як взаємозамінні."

# unordered list
#: shell-novice/_extras/guide.md:215
msgid "*   On Windows, it appears that:"
msgstr "*   На машинах Windows, виявляється, наступні команди:"

#: shell-novice/_extras/guide.md:217
msgid ""
"    ~~~\n"
"    $ cd\n"
"    $ cd Desktop\n"
"    ~~~\n"
"    {: .language-bash}"
msgstr ""
"    ~~~\n"
"    $ cd\n"
"    $ cd Desktop\n"
"    ~~~\n"
"    {: .language-bash}"

#: shell-novice/_extras/guide.md:223
msgid ""
"    will always put someone on their desktop\n"
"    (unless their machine is backed up using enterprise OneDrive, see next point).\n"
"    Have them create the example directory for the shell exercises there\n"
"    so that they can find it easily\n"
"    and watch it evolve."
msgstr ""
"    завжди відправлять когось у каталог свого робочого столу\n"
"    (якщо на їхньому комп'ютері не створено резервну копію за допомогою корпоративного OneDrive, див. наступний пункт).\n"
"    Попросіть їх створити там каталог прикладів для вправ у командному рядку\n"
"    щоб вони могли легко його знайти\n"
"    і спостерігати за його розвитком."

# unordered list
#: shell-novice/_extras/guide.md:229
msgid ""
"*   If a Windows machine is backed up with enterprise OneDrive, their GUI "
"desktop may"
msgstr ""
"*   Якщо на комп'ютері з Windows створено резервну копію корпоративного "
"OneDrive, його робочий стіл із графічним інтерфейсом може"

#: shell-novice/_extras/guide.md:230
msgid ""
"    be rendered from a folder within OneDrive, which will not match the contents of `~/Desktop`.\n"
"    The OneDrive desktop should be accessible using one of the following commands\n"
"    (if the name of the enterprise isn't clear, look through the output of `ls` to find\n"
"    the right folder):"
msgstr ""
"    буде відображено з каталогу у OneDrive, який не збігатиметься із вмістом `~/Desktop`.\n"
"    Доступ до робочого столу OneDrive має бути забезпечено за допомогою однієї з наведених нижче команд\n"
"    (якщо назва підприємства незрозуміла, перегляньте виведення `ls`, щоб знайти\n"
"    потрібний каталог):"

#: shell-novice/_extras/guide.md:235
msgid ""
"    ~~~\n"
"    $ cd \"~/OneDrive - Name Of Enterprise/Desktop\"\n"
"    $ cd \"C:/Users/Username/OneDrive - Name Of Enterprise/Desktop\"\n"
"    ~~~\n"
"    {: .language-bash}"
msgstr ""
"    ~~~\n"
"    $ cd \"~/OneDrive - Name Of Enterprise/Desktop\"\n"
"    $ cd \"C:/Users/Username/OneDrive - Name Of Enterprise/Desktop\"\n"
"    ~~~\n"
"    {: .language-bash}"

#: shell-novice/_extras/guide.md:241
msgid ""
"    One way to spot if the computer is using this kind of configuration is to look at files,\n"
"    folders or links on the desktop. Usually the icon contains a shortcut/arrow symbol if it\n"
"    is a link, or just the plain icon if the file is just saved in the `Desktop` folder.\n"
"    Files synced with OneDrive contain an additional symbol indicating the sync status\n"
"    (typically blue arrows for 'sync pending' or a green tick for 'synced')."
msgstr ""
"    Один із способів визначити, чи використовує комп'ютер таку конфігурацію, - це переглянути файли,\n"
"    каталоги або посилання на робочому столі. Зазвичай піктограма містить символ ярлика/стрілки, якщо це\n"
"    посилання, або просто піктограму, якщо файл просто збережено в папці \"Робочий стіл\".\n"
"    Файли, синхронізовані зі службою OneDrive, містять додатковий символ, що вказує на стан синхронізації\n"
"    (зазвичай сині стрілки для \"очікує синхронізації\" або зелена галочка для \"синхронізовано\")."

# unordered list
#: shell-novice/_extras/guide.md:247
msgid ""
"*  Stay within POSIX-compliant commands, as all the teaching materials do."
msgstr ""
"*  Дотримуйтесь POSIX-сумісних команд, як і в усіх навчальних матеріалах."

#: shell-novice/_extras/guide.md:248
msgid ""
"   Your particular shell may have extensions beyond POSIX that are not available\n"
"   on other machines, especially the default macOS bash and Windows bash emulators.\n"
"   For example, POSIX `ls` does not have an `--ignore=` or `-I` option, and POSIX\n"
"   `head` takes `-n 10` or `-10`, but not the long form of `--lines=10`."
msgstr ""
"   Ваша конкретна оболонка може мати розширення за межами POSIX, які недоступні\n"
"   на інших машинах, особливо у типових емуляторах bash для macOS і bash для Windows.\n"
"   Наприклад, POSIX `ls` не має опції `--ignore=` або `-I`, а POSIX\n"
"   `head` приймає `-n 10` або `-10`, але не довгу форму `--lines=10`."

# header
#: shell-novice/_extras/guide.md:253
msgid "## Windows"
msgstr "## Windows"

#: shell-novice/_extras/guide.md:255
msgid ""
"Installing Bash and a reasonable set of Unix commands on Windows\n"
"always involves some fiddling and frustration.\n"
"Please see the latest set of installation guidelines for advice,\n"
"and try it out yourself *before* teaching a class.\n"
"Options we have explored include:"
msgstr ""
"Встановлення Bash та доцільного набору команд Unix на Windows\n"
"завжди пов'язане з деякими клопотами та розчаруваннями.\n"
"Будь ласка, зверніться до останнього набору інструкцій щодо встановлення для отримання порад,\n"
"і спробуйте самі, перш ніж викладати у класі.\n"
"Ми розглянули такі варіанти:"

# ordered list
#: shell-novice/_extras/guide.md:261
msgid "1.  [msysGit](http://msysgit.github.io/) (also called \"Git Bash\"),"
msgstr "1.  [msysGit](http://msysgit.github.io/) (також відомий як \"Git Bash\"),"

# ordered list
#: shell-novice/_extras/guide.md:262
msgid "2.  [Cygwin](http://www.cygwin.com/),"
msgstr "2.  [Cygwin](http://www.cygwin.com/),"

# ordered list
#: shell-novice/_extras/guide.md:263
msgid "3.  using a desktop virtual machine, and"
msgstr "3.  використання віртуальної машини, та"

# ordered list
#: shell-novice/_extras/guide.md:264
msgid ""
"4.  having learners connect to a remote Unix machine (typically a VM in the "
"cloud)."
msgstr ""
"4.  підключення учнів до віддаленої Unix-машини (як правило, віртуальної "
"машини в хмарі)."

#: shell-novice/_extras/guide.md:266
msgid ""
"Cygwin was the preferred option until mid-2013,\n"
"but once we started teaching Git,\n"
"msysGit proved to work better.\n"
"Desktop virtual machines and cloud-based VMs work well for technically sophisticated learners,\n"
"and can reduce installation and configuration at the start of the workshop,\n"
"but:"
msgstr ""
"Cygwin був найкращим варіантом до середини 2013 року,\n"
"але як тільки ми почали викладати Git,\n"
"msysGit виявився кращим.\n"
"Настільні віртуальні машини та хмарні віртуальні машини добре підходять для технічно-підкованих учнів\n"
"і можуть скоротити час на встановлення та налаштування на початку семінару,\n"
"але:"

# ordered list
#: shell-novice/_extras/guide.md:273
msgid "1.  they don't work well on underpowered machines,"
msgstr "1.  вони погано працюють на малопотужних машинах,"

# ordered list
#: shell-novice/_extras/guide.md:274
msgid ""
"2.  they're confusing for novices (because simple things like copy and paste"
" work differently),"
msgstr ""
"2.  вони збивають з пантелику новачків (тому що такі прості речі, як "
"копіювання та вставка, працюють по-різному),"

# ordered list
#: shell-novice/_extras/guide.md:275
msgid ""
"3.  learners leave the workshop without a working environment on their "
"operating system of choice,"
msgstr ""
"3.  учні залишають семінар без робочого середовища на обраній ними "
"операційній системі,"

#: shell-novice/_extras/guide.md:276
msgid ""
"    and\n"
"4.  learners may show up without having downloaded the VM or the wireless will go down\n"
"    (or become congested) during the lesson."
msgstr ""
"    та\n"
"4.  учні можуть з'явитися, не завантаживши віртуальну машину, або бездротовий зв'язок зникне\n"
"    (або стане перевантаженим) під час уроку.\n"
"    "

#: shell-novice/_extras/guide.md:280
msgid ""
"Whatever you use,\n"
"please *test it yourself* on a Windows machine *before* your workshop:\n"
"things may always have changed behind your back since your last workshop.\n"
"And please also make use of our\n"
"[Software Carpentry Windows Installer][windows-installer]."
msgstr ""
"Що б ви не використовували,\n"
"будь ласка, *протестуйте його власноруч* на комп'ютері з Windows *до* початку семінару:\n"
"з часу вашого останнього семінару все могло змінитися за вашою спиною.\n"
"І, будь ласка, також скористайтеся нашим\n"
"[Software Carpentry Windows Installer][windows-installer]."

#: shell-novice/_extras/guide.md:286
msgid ""
"[shebang]: http://www.in-ulm.de/~mascheck/various/shebang/\n"
"[windows-installer]: {{ site.swc_github }}/windows-installer"
msgstr ""
"[shebang]: http://www.in-ulm.de/~mascheck/various/shebang/\n"
"[windows-installer]: {{ site.swc_github }}/windows-installer"

# Front Matter
#: shell-novice/aio.md:1
msgid ""
"---\n"
"layout: page\n"
"permalink: /aio/\n"
"permalink: /aio/index.html\n"
"---"
msgstr ""
"---\n"
"layout: page\n"
"permalink: /aio/\n"
"permalink: /aio/index.html\n"
"---"

#: shell-novice/aio.md:7
msgid ""
"{% comment %}\n"
"As a maintainer, you do not need to edit this file.\n"
"If you notice that something does not work, please \n"
"open an issue: https://github.com/carpentries/styles/issues/new\n"
"{% endcomment %}"
msgstr ""
"{% comment %}\n"
"Як супровідник, вам не потрібно редагувати цей файл.\n"
"Якщо ви помітили, що щось не працює, будь ласка\n"
"створіть заявку про проблему: https://github.com/carpentries/styles/issues/new\n"
"{% endcomment %}"

#: shell-novice/aio.md:13
msgid "{% include base_path.html %}"
msgstr "{% include base_path.html %}"

#: shell-novice/aio.md:15
msgid "{% include aio-script.md %}"
msgstr "{% include aio-script.md %}"

# Front Matter
#: shell-novice/index.md:1
msgid ""
"---\n"
"layout: lesson\n"
"root: .\n"
"---"
msgstr ""
"---\n"
"layout: lesson\n"
"root: .\n"
"---"

#: shell-novice/index.md:6
msgid ""
"The Unix shell has been around longer than most of its users\n"
"have been alive. It has survived because it's a powerful tool that\n"
"allows users to perform complex and powerful tasks, often with just\n"
" a few keystrokes or lines of code. It helps users automate repetitive\n"
" tasks and easily combine smaller tasks into larger, more powerful workflows."
msgstr ""
"Термінал Unix існує довше, ніж більшість її користувачів\n"
"живуть на світі. Вона вижила, тому що це потужний інструмент, який\n"
"дозволяє користувачам виконувати складні та потужні завдання, часто за допомогою лише\n"
"кількох натискань клавіш або кількох рядків коду. Він допомагає користувачам автоматизувати\n"
"завдання, що повторюються, і легко об'єднувати менші завдання у більші та потужніші робочі процеси."

#: shell-novice/index.md:12
msgid ""
"Use of the shell is fundamental to a wide range of advanced computing\n"
"tasks, including high-performance computing. These lessons will introduce\n"
"you to this powerful tool."
msgstr ""
"Використання терміналу є фундаментальним для широкого спектру сучасних обчислювальних\n"
"завдань, включаючи високопродуктивні обчислення. Ці уроки познайомлять\n"
"вас з цим потужним інструментом."

# blockquote, which can be cascaded
#: shell-novice/index.md:16
msgid "> ## Prerequisites"
msgstr "> ## Передумови"

#: shell-novice/index.md:17
msgid ""
">\n"
"> This lesson guides you through the basics of file systems and the\n"
"> shell. If you have stored files on a computer at all and recognize\n"
"> the word \"file\" and either \"directory\" or \"folder\" (two common words\n"
"> for the same thing), you're ready for this lesson.\n"
">\n"
"> If you're already comfortable manipulating files and directories,\n"
"> searching for files with `grep` and `find`, and writing simple loops\n"
"> and scripts, you probably want to explore the next lesson:\n"
"> [shell-extras](https://carpentries-incubator.github.io/shell-extras/)."
msgstr ""
">\n"
"> У цьому уроці ви дізнаєтеся про основи файлових систем та\n"
"> термінал. Якщо ви коли-небудь зберігали файли на комп'ютері і розпізнаєте\n"
"> слово \"файл\" і \"каталог\" або \"тека\" (два загальновживаних слова,\n"
"> що позначають одне й те саме), ви готові до цього уроку.\n"
">\n"
"> Якщо ви вже впевнено маніпулюєте файлами та каталогами,\n"
"> шукаєте файли за допомогою команд `grep` і `find`, а також пишете прості цикли\n"
"> та скрипти, вам, ймовірно, буде цікаво перейти до наступного уроку:\n"
"> [shell-додаток](https://carpentries-incubator.github.io/shell-extras/)."

# SC/DC Template label
#: shell-novice/index.md:27
msgid "{: .prereq}"
msgstr "{: .prereq}"

# Front Matter
#: shell-novice/reference.md:1
msgid ""
"---\n"
"layout: reference\n"
"---"
msgstr ""
"---\n"
"layout: reference\n"
"---"

# header
#: shell-novice/reference.md:5
msgid "## Summary of Basic Commands"
msgstr "## Короткий опис основних команд"

#: shell-novice/reference.md:7
msgid ""
"| Action      | Files | Folders      |\n"
"|-------------|-------|--------------|\n"
"| Inspect     | ls    | ls           |\n"
"| View content| cat   | ls           |\n"
"| Navigate to |       | cd           |\n"
"| Move        | mv    | mv           |\n"
"| Copy        | cp    | cp -r        |\n"
"| Create      | nano  | mkdir        |\n"
"| Delete      | rm    | rmdir, rm -r |"
msgstr ""
"| Операція         | Файли | Каталоги     |\n"
"|------------------|-------|--------------|\n"
"| Перелічити       | ls | ls |\n"
"| Проглянути вміст | cat | ls |\n"
"| Перейти до ...   | | cd |\n"
"| Перемістити      | mv | mv |\n"
"| Копіювати        | cp | cp -r |\n"
"| Створити         | nano | mkdir |\n"
"| Видалити         | rm | rmdir, rm -r |"

# header
#: shell-novice/reference.md:17
msgid "## Filesystem hierarchy"
msgstr "## Ієрархія файлової системи"

#: shell-novice/reference.md:19
msgid ""
"The following is an overview of a standard Unix filesystem.\n"
"The exact hierarchy depends on the platform. Your file/directory structure may differ slightly:"
msgstr ""
"Нижче наведено огляд стандартної файлової системи Unix.\n"
"Точна ієрархія залежить від платформи. Ваша структура файлів/каталогу може дещо відрізнятися:"

#: shell-novice/reference.md:22
msgid "![Linux filesystem hierarchy](fig/standard-filesystem-hierarchy.svg)"
msgstr ""
"![Ієрархія файлової системи Linux](fig/standard-filesystem-hierarchy.svg)"

# header
#: shell-novice/reference.md:24
msgid "## Glossary"
msgstr "## Словник"

#: shell-novice/reference.md:26
msgid ""
"{:auto_ids}\n"
"absolute path\n"
":   A [path](#path) that refers to a particular location in a file system.\n"
"    Absolute paths are usually written with respect to the file system's\n"
"    [root directory](#root-directory),\n"
"    and begin with either \"/\" (on Unix) or \"\\\\\" (on Microsoft Windows).\n"
"    See also: [relative path](#relative-path)."
msgstr ""
"{:auto_ids}\n"
"абсолютний шлях\n"
":   [Шлях](#шлях), який посилається на певне місце у файловій системі.\n"
"    Абсолютні шляхи зазвичай записуються відносно [кореневого каталогу](#кореневий-каталог) файлової системи\n"
"    і починаються з символів \"/\" (у Unix) або \"\\\\\" (у Microsoft Windows).\n"
"    Дивись також: [відносний шлях](#відносний-шлях)."

#: shell-novice/reference.md:34
msgid ""
"argument\n"
":   A value given to a function or program when it runs.\n"
"    The term is often used interchangeably (and inconsistently) with [parameter](#parameter)."
msgstr ""
"аргумент\n"
":   Значення, яке передається до функції або програми під час її запуску.\n"
"    Цей термін часто використовується як взаємозамінний (і неузгоджено) з [параметр](#параметр)."

#: shell-novice/reference.md:38
msgid ""
"command shell\n"
":   See [shell](#shell)"
msgstr ""
"командна оболонка\n"
":   Дивись [термінал](#термінал)"

#: shell-novice/reference.md:41
msgid ""
"command-line interface\n"
":   A user interface based on typing commands,\n"
"    usually at a [REPL](#read-evaluate-print-loop).\n"
"    See also: [graphical user interface](#graphical-user-interface)."
msgstr ""
"інтерфейс командного рядка\n"
":   Інтерфейс користувача, заснований на введенні команд,\n"
"    зазвичай у циклі [REPL](#цикл-read-evaluate-print).\n"
"    Дивись також: [графічний інтерфейс користувача](#графічний-інтерфейс-користувача)."

#: shell-novice/reference.md:46
msgid ""
"comment\n"
":   A remark in a program that is intended to help human readers understand what is going on,\n"
"    but is ignored by the computer.\n"
"    Comments in Python, R, and the Unix shell start with a `#` character\n"
"    and run to the end of the line;\n"
"    comments in SQL start with `--`,\n"
"    and other languages have other conventions."
msgstr ""
"коментар\n"
":   Зауваження в програмі, яке має на меті допомогти людині-читачеві зрозуміти, що відбувається,\n"
"    але ігнорується комп'ютером.\n"
"    Коментарі у мовах Python, R та в терміналі Unix починаються з символу `#'\n"
"    та йдуть до кінця відповідного рядка\n"
"    коментарі в SQL починаються з `--`,\n"
"    а в інших мовах існують інші домовленості."

#: shell-novice/reference.md:55
msgid ""
"current working directory\n"
":   The directory that [relative paths](#relative-path) are calculated from;\n"
"    equivalently,\n"
"    the place where files referenced by name only are searched for.\n"
"    Every [process](#process) has a current working directory.\n"
"    The current working directory is usually referred to using the shorthand notation `.`\n"
"    (pronounced \"dot\")."
msgstr ""
"поточний робочий каталог\n"
":   Каталог, з якого обчислюються [відносні шляхи](#відносний-шлях);\n"
"    еквівалентно,\n"
"    місце, де шукаються файли, на які посилаються лише за іменами.\n"
"    Кожен [процес](#процес) має поточний робочий каталог.\n"
"    На поточний робочий каталог зазвичай посилаються за допомогою скороченого позначення `.`\n"
"    (вимовляється як \"крапка\")."

#: shell-novice/reference.md:63
msgid ""
"file system\n"
":   A set of files, directories, and I/O devices (such as keyboards and screens).\n"
"    A file system may be spread across many physical devices,\n"
"    or many file systems may be stored on a single physical device;\n"
"    the [operating system](#operating-system) manages access."
msgstr ""
"файлова система\n"
":   Набір файлів, каталогів та пристроїв вводу/виводу (таких як клавіатури та екрани).\n"
"    Файлова система може бути розподілена на багатьох фізичних пристроях,\n"
"    або багато файлових систем можуть зберігатися на одному фізичному пристрої;\n"
"    [операційна система](#операційна-система) керує доступом."

#: shell-novice/reference.md:69
msgid ""
"filename extension\n"
":   The portion of a file's name that comes after the final \".\" character.\n"
"    By convention this identifies the file's type:\n"
"    `.txt` means \"text file\", `.png` means \"Portable Network Graphics file\",\n"
"    and so on. These conventions are not enforced by most operating systems:\n"
"    it is perfectly possible (but confusing!) to name an MP3 sound file `homepage.html`.\n"
"    Since many applications use filename extensions to identify the\n"
"    [MIME type](#mime-type) of the file,\n"
"    misnaming files may cause those applications to fail."
msgstr ""
"розширення імені файлу\n"
":   Частина імені файлу, яка йде після останнього символу \".\".\n"
"    За домовленістю це визначає тип файлу:\n"
"    `.txt` означає \"текстовий файл\" (від англ. \"TeXT\"), `.png` означає \"файл портативної мережевої графіки\" (від англ. \"Portable Network Graphics file\"),\n"
"    і так далі. Більшість операційних систем не дотримуються цих домовленостей:\n"
"    цілком можливо (але заплутано!) назвати звуковий файл MP3 `homepage.html`.\n"
"    Оскільки багато програм використовують розширення назв файлів для ідентифікації\n"
"    [MIME типу](#mime-тип) файлу,\n"
"    неправильне називання файлів може призвести до збою у роботі відповідних програм."

#: shell-novice/reference.md:79
msgid ""
"filter\n"
":   A program that transforms a stream of data.\n"
"    Many Unix command-line tools are written as filters:\n"
"    they read data from [standard input](#standard-input),\n"
"    process it, and write the result to [standard output](#standard-output)."
msgstr ""
"фільтр\n"
":   Програма, яка перетворює потік даних.\n"
"    Багато інструментів командного рядка Unix написано у вигляді фільтрів:\n"
"    вони зчитують дані зі [стандартного вводу](#стандартний-ввод),\n"
"    обробляють їх і записують результат у [стандартний вивід](#стандартний-вивід)."

#: shell-novice/reference.md:85
msgid ""
"for loop\n"
":   A loop that is executed once for each value in some kind of set, list, or range.\n"
"    See also: [while loop](#while-loop)."
msgstr ""
"цикл FOR\n"
":   Цикл, який виконується один раз для кожного значення в деякому наборі, списку або діапазоні.\n"
"    Дивись також: [цикл while] (#цикл-while)."

#: shell-novice/reference.md:89
msgid ""
"graphical user interface\n"
":   A user interface based on selecting items and actions from a graphical display,\n"
"    usually controlled by using a mouse.\n"
"    See also: [command-line interface](#command-line-interface)."
msgstr ""
"графічний інтерфейс користувача\n"
":   Інтерфейс користувача, заснований на виборі елементів і дій з графічного дисплея,\n"
"    зазвичай керований за допомогою миші.\n"
"    Дивись також: [інтерфейс командного рядка](#інтерфейс-командного-рядка)."

#: shell-novice/reference.md:94
msgid ""
"home directory\n"
":   The default directory associated with an account on a computer system.\n"
"    By convention, all of a user's files are stored in or below her home directory."
msgstr ""
"домашній каталог\n"
":   Каталог за замовчуванням, пов'язаний з обліковим записом у комп'ютерній системі.\n"
"    За домовленістю усі файли користувача зберігаються у домашньому каталозі або нижче нього."

#: shell-novice/reference.md:98
msgid ""
"loop\n"
":   A set of instructions to be executed multiple times.\n"
"    Consists of a [loop body](#loop-body) and (usually) a\n"
"    condition for exiting the loop. See also [for loop](#for-loop) and [while loop](#while-loop)."
msgstr ""
"цикл\n"
":   Набір інструкцій, що виконується декілька разів.\n"
"    Складається з [тіла циклу](#тіло-циклу) і (зазвичай)\n"
"    умови виходу з циклу.\n"
"    Дивись також: [цикл for](#цикл-for) та [цикл while](#цикл-while)."

#: shell-novice/reference.md:103
msgid ""
"loop body\n"
":   The set of statements or commands that are repeated inside a [for loop](#for-loop)\n"
"    or [while loop](#while-loop)."
msgstr ""
"тіло циклу\n"
":   Набір операторів або команд, які повторюються всередині [циклу for](#цикл-for)\n"
"    чи [циклу while](#цикл-while)."

#: shell-novice/reference.md:107
msgid ""
"MIME type\n"
":   MIME (Multi-Purpose Internet Mail Extensions) types describe different file types for exchange\n"
"    on the Internet, for example, images, audio, and documents."
msgstr ""
"MIME тип\n"
":   Типи MIME (Multi-Purpose Internet Mail Extensions, з англ. багатоцільові розширення інтернет-пошти) описують різні типи файлів для обміну\n"
"    в Інтернеті, наприклад, зображення, аудіо та документи."

#: shell-novice/reference.md:111
msgid ""
"operating system\n"
":   Software that manages interactions between users, hardware, and software [processes](#process).\n"
"    Common examples are Linux, macOS, and Windows."
msgstr ""
"операційна система\n"
":   Програмне забезпечення, яке керує взаємодією між користувачами, обладнанням та [процесами] (#процес) програмного забезпечення.\n"
"    Поширеними прикладами є Linux, macOS та Windows."

#: shell-novice/reference.md:115
msgid ""
"option\n"
":   A way to specify an argument or setting to a command-line program.\n"
"    By convention Unix applications use a dash followed by a single letter,\n"
"    such as `-v`, or two dashes followed by a word, such as `--verbose`,\n"
"    while DOS applications use a slash, such as `/V`.\n"
"    Depending on the application, an option may be followed by a single argument,\n"
"    as in `-o /tmp/output.txt`."
msgstr ""
"опція\n"
":   Спосіб вказати аргумент або параметр у програмі командного рядка.\n"
"    Зазвичай у Unix-програмах використовується тире, за яким слідує одна літера,\n"
"    наприклад, `-v`, або два тире з наступним словом, наприклад, `--verbose`,\n"
"    у той час як програми для DOS використовують косу риску, наприклад `/V`.\n"
"    Залежно від програми, опція може супроводжуватися одним аргументом,\n"
"    як у `-o /tmp/output.txt`."

#: shell-novice/reference.md:123
msgid ""
"parameter\n"
":   A variable named in a function's declaration that is used to hold a value passed into the call.\n"
"    The term is often used interchangeably (and inconsistently) with [argument](#argument)."
msgstr ""
"параметр\n"
": Змінна, названа в оголошенні функції, яка використовується для зберігання значення, переданого у виклик.\n"
"    Цей термін часто використовується як взаємозамінний (і неузгоджено) з [аргумент](#аргумент)."

#: shell-novice/reference.md:127
msgid ""
"parent directory\n"
":   The directory that \"contains\" the one in question.\n"
"    Every directory in a file system except the [root directory](#root-directory) has a parent.\n"
"    A directory's parent is usually referred to using the shorthand notation `..`\n"
"    (pronounced \"dot dot\")."
msgstr ""
"батьківський каталог\n"
":   Каталог, який \"містить\" каталог, про який йде мова.\n"
"    Кожен каталог у файловій системі, окрім [кореневого каталогу] (#кореневий-каталог), має батька.\n"
"    На батьківський каталог зазвичай посилаються за допомогою скороченого позначення `..`\n"
"    (вимовляється як \"крапка крапка\")."

#: shell-novice/reference.md:133
msgid ""
"path\n"
":   A description that specifies the location of a file or directory within a\n"
"    [file system](#file-system).\n"
"    See also: [absolute path](#absolute-path), [relative path](#relative-path)."
msgstr ""
"шлях\n"
":   Опис, який вказує місцезнаходження файлу або каталогу у\n"
"    [файловій системі](#файлова-система).\n"
"    Дивись також: [абсолютний шлях](#абсолютний-шлях), [відносний шлях](#відносний-шлях)."

#: shell-novice/reference.md:139
msgid ""
"pipe\n"
":   A connection from the output of one program to the input of another.\n"
"    When two or more programs are connected in this way, they are called a \"pipeline\"."
msgstr ""
"канал\n"
":   З'єднання виходу однієї програми з входом іншої.\n"
"    Коли дві або більше програм з'єднані таким чином, вони називаються \"конвеєром\"."

#: shell-novice/reference.md:143
msgid ""
"process\n"
":   A running instance of a program, containing code, variable values,\n"
"    open files and network connections, and so on.\n"
"    Processes are the \"actors\" that the [operating system](#operating-system) manages;\n"
"    it typically runs each process for a few milliseconds at a time\n"
"    to give the impression that they are executing simultaneously."
msgstr ""
"процес\n"
":   Екземпляр програми, що виконується; містить код, значення змінних,\n"
"    відкриті файли, мережеві з'єднання тощо.\n"
"    Процеси - це \"актори\", якими керує [операційна система](#операційна-система);\n"
"    зазвичай вона виконує кожен процес по кілька мілісекунд за раз\n"
"    щоб створити враження, що вони виконуються одночасно."

#: shell-novice/reference.md:151
msgid ""
"prompt\n"
":   A character or characters display by a [REPL](#read-evaluate-print-loop) to show that\n"
"    it is waiting for its next command."
msgstr ""
"запит на введення\n"
":   Символ або символи, які виводяться циклом [REPL](#цикл-read-evaluate-print), щоб показати,\n"
"    що він чекає на наступну команду."

#: shell-novice/reference.md:155
msgid ""
"quoting\n"
":   (in the shell):\n"
"    Using quotation marks of various kinds to prevent the shell from interpreting special\n"
"    characters.\n"
"    For example, to pass the string `*.txt` to a program,\n"
"    it is usually necessary to write it as `'*.txt'` (with single quotes)\n"
"    so that the shell will not try to expand the `*` wildcard."
msgstr ""
"цитува́ння\n"
":   (в терміналі):\n"
"    Використання лапок різного типу для запобігання інтерпретації оболонки спеціальних\n"
"    символів.\n"
"    Наприклад, щоб передати програмі рядок `*.txt`,\n"
"    зазвичай потрібно записати його як `'*.txt'` (з одинарними лапками),\n"
"    щоб термінал не намагався розгорнути символ підстановки `*`"

#: shell-novice/reference.md:163
msgid ""
"read-evaluate-print loop\n"
":   (REPL): A [command-line interface](#command-line-interface) that reads a command from the user,\n"
"    executes it, prints the result, and waits for another command."
msgstr ""
"цикл read-evaluate-print\n"
":   (REPL): [інтерфейс командного рядка](#інтерфейс-командного-рядка), який читає команду від користувача,\n"
"    виконує її, виводить результат і чекає на наступну команду."

#: shell-novice/reference.md:167
msgid ""
"redirect\n"
":   To send a command's output to a file rather than to the screen or another command,\n"
"    or equivalently to read a command's input from a file."
msgstr ""
"перенаправляти\n"
":   Надіслати вивід команди до файлу, а не на екран або іншій команді,\n"
"    або, еквівалентно, прочитати вхідні дані команди з файлу."

#: shell-novice/reference.md:171
msgid ""
"regular expression\n"
":   A pattern that specifies a set of character strings.\n"
"    REs are most often used to find sequences of characters in strings."
msgstr ""
"регулярний вираз\n"
":   Шаблон, який визначає набір рядків символів.\n"
"    Найчастіше використовуються для пошуку послідовностей символів у рядках."

#: shell-novice/reference.md:175
msgid ""
"relative path\n"
":   A [path](#path) that specifies the location of a file or directory\n"
"    with respect to the [current working directory](#current-working-directory).\n"
"    Any path that does not begin with a separator character (\"/\" or \"\\\\\") is a relative path.\n"
"    See also: [absolute path](#absolute-path)."
msgstr ""
"відносний шлях\n"
":   [Шлях](#шлях), який вказує місцезнаходження файлу або каталогу\n"
"    відносно [поточного робочого каталогу](#поточний-робочий-каталог).\n"
"    Будь-який шлях, який не починається з символу-розділювача (\"/\" або \"\\\\\"), є відносним шляхом.\n"
"    Дивись також: [абсолютний шлях](#абсолютний-шлях)."

#: shell-novice/reference.md:181
msgid ""
"root directory\n"
":   The top-most directory in a [file system](#file-system).\n"
"    Its name is \"/\" on Unix (including Linux and macOS) and \"\\\\\" on Microsoft Windows."
msgstr ""
"кореневий каталог\n"
":   Найвищий каталог у [файловій системі](#файлова-система).\n"
"    Його назва \"/\" у Unix (включаючи Linux і macOS) і \"\\\\\" у Microsoft Windows."

#: shell-novice/reference.md:185
msgid ""
"shell\n"
":   A [command-line interface](#cli) such as Bash (the Bourne-Again Shell)\n"
"    or the Microsoft Windows DOS shell\n"
"    that allows a user to interact with the [operating system](#operating-system)."
msgstr ""
"термінал\n"
":   [інтерфейс командного рядка](#інтерфейс-командного-рядка), наприклад, Bash (the Bourne-Again Shell)\n"
"    або термінал Microsoft Windows DOS\n"
"    яка дозволяє користувачеві взаємодіяти з [операційною системою] (#операційна-система)."

#: shell-novice/reference.md:190
msgid ""
"shell script\n"
":   A set of [shell](#shell) commands stored in a file for re-use.\n"
"    A shell script is a program executed by the shell;\n"
"    the name \"script\" is used for historical reasons."
msgstr ""
"скрипт терміналу\n"
":   Набір команд [терміналу](#термінал), збережений у файлі для повторного використання.\n"
"    Скрипт терміналу - це програма, яку виконує термінал;\n"
"    назва \"скрипт\" використовується з історичних причин."

#: shell-novice/reference.md:196
msgid ""
"standard input\n"
":   A process's default input stream.\n"
"    In interactive command-line applications,\n"
"    it is typically connected to the keyboard;\n"
"    in a [pipe](#pipe),\n"
"    it receives data from the [standard output](#standard-output) of the preceding process."
msgstr ""
"стандартний ввід\n"
":   Потік вводу процесу за замовчуванням.\n"
"    В інтерактивних програмах командного рядка,\n"
"    він зазвичай підключається до клавіатури;\n"
"    у [канал](#канал)\n"
"    він отримує дані зі [стандартного виводу](#стандартний-вивід) попереднього процесу."

#: shell-novice/reference.md:204
msgid ""
"standard output\n"
":   A process's default output stream.\n"
"    In interactive command-line applications,\n"
"    data sent to standard output is displayed on the screen;\n"
"    in a [pipe](#pipe),\n"
"    it is passed to the [standard input](#standard-input) of the next process."
msgstr ""
"стандартний вивід\n"
":   Потік виведення процесу за замовчуванням.\n"
"    В інтерактивних програмах командного рядка,\n"
"    дані, надіслані на стандартний вивід, виводяться на екран;\n"
"    в [каналі](#канал)\n"
"    вони передаються до [стандартного вводу](#стандартний-ввід) наступного процесу."

#: shell-novice/reference.md:212
msgid ""
"sub-directory\n"
":   A directory contained within another directory."
msgstr ""
"підкаталог\n"
":   Каталог, що міститься у іншому каталозі."

#: shell-novice/reference.md:215
msgid ""
"tab completion\n"
":   A feature provided by many interactive systems in which\n"
"    pressing the Tab key triggers automatic completion of the current word or command."
msgstr ""
"завершення клавішею табуляції\n"
":   Функція, що надається багатьма інтерактивними системами, в яких\n"
"    натискання клавіші Tab запускає автоматичне завершення поточного слова або команди."

#: shell-novice/reference.md:219
msgid ""
"variable\n"
":   A name in a program that is associated with a value or a collection of values."
msgstr ""
"змінна\n"
":   Ім'я у програмі, яке асоціюється зі значенням або колекцією значень."

#: shell-novice/reference.md:222
msgid ""
"while loop\n"
":   A loop that keeps executing as long as some condition is true.\n"
"    See also: [for loop](#for-loop)."
msgstr ""
"цикл while\n"
":   Цикл, який виконується до тих пір, поки істинна певна умова.\n"
"    Дивись також: [цикл for](#цикл-for)."

#: shell-novice/reference.md:226
msgid ""
"wildcard\n"
":   A character used in pattern matching.\n"
"    In the Unix shell,\n"
"    the wildcard `*` matches zero or more characters,\n"
"    so that `*.txt` matches all files whose names end in `.txt`."
msgstr ""
"підстановочний символ\n"
":   Символ, який використовується у співставленні з шаблоном.\n"
"    У терміналі Unix,\n"
"    шаблон `*` відповідає нулю або більше символів,\n"
"    таким чином, `*.txt` відповідає усім файлам, назви яких закінчуються на `.txt`."

# header
#: shell-novice/reference.md:232
msgid "## External references"
msgstr "## Зовнішні посилання"

# header
#: shell-novice/reference.md:234
msgid "### Opening a terminal"
msgstr "### Відкриття терміналу"

# unordered list
#: shell-novice/reference.md:235
msgid ""
"* [How to Use Terminal on a Mac](http://www.macworld.co.uk/feature/mac-"
"software/how-use-terminal-on-mac-3608274/)"
msgstr ""
"* [Як користуватися терміналом на "
"Mac](http://www.macworld.co.uk/feature/mac-software/how-use-terminal-on-"
"mac-3608274/) (матеріал англійською мовою)"

# unordered list
#: shell-novice/reference.md:236
msgid "* [Git for Windows](https://git-for-windows.github.io/)"
msgstr ""
"* [Git для Windows](https://git-for-windows.github.io/) (матеріал "
"англійською мовою)"

# unordered list
#: shell-novice/reference.md:237
msgid ""
"* [How to Install Bash shell command-line tool on Windows "
"10](https://www.windowscentral.com/how-install-bash-shell-command-line-"
"windows-10)"
msgstr ""
"* [Як встановити термінал Bash на Windows "
"10](https://www.windowscentral.com/how-install-bash-shell-command-line-"
"windows-10) (матеріал англійською мовою)"

# unordered list
#: shell-novice/reference.md:238
msgid ""
"* [Install and Use the Linux Bash Shell on Windows "
"10](https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-"
"shell-on-windows-10/)"
msgstr ""
"* [Встановлення та використання терміналу Linux Bash у Windows "
"10](https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-"
"shell-on-windows-10/) (матеріал англійською мовою)"

# unordered list
#: shell-novice/reference.md:239
msgid ""
"* [Using the Windows 10 Bash "
"Shell](https://www.howtogeek.com/265900/everything-you-can-do-with-"
"windows-10s-new-bash-shell/)"
msgstr ""
"* [Використання Windows 10 терміналу "
"Bash](https://www.howtogeek.com/265900/everything-you-can-do-with-"
"windows-10s-new-bash-shell/) (матеріал англійською мовою)"

# unordered list
#: shell-novice/reference.md:240
msgid ""
"* [Using a UNIX/Linux emulator (Cygwin) or Secure Shell (SSH) client "
"(Putty)](http://faculty.smu.edu/reynolds/unixtut/windows.html)"
msgstr ""
"* [Використання емулятора UNIX/Linux (Cygwin) або клієнта Secure Shell (SSH)"
" (Putty)](http://faculty.smu.edu/reynolds/unixtut/windows.html) (матеріал "
"англійською мовою)"

# header
#: shell-novice/reference.md:242
msgid "### Manuals"
msgstr "### Посібники"

# unordered list
#: shell-novice/reference.md:243
msgid "* [GNU manuals](http://www.gnu.org/manual/manual.html)"
msgstr ""
"* [Керівництва з GNU](http://www.gnu.org/manual/manual.html) (матеріал "
"англійською мовою)"

# unordered list
#: shell-novice/reference.md:244
msgid ""
"* [Core GNU "
"utilities](http://www.gnu.org/software/coreutils/manual/coreutils.html)"
msgstr ""
"* [Ключові утіліти "
"GNU](http://www.gnu.org/software/coreutils/manual/coreutils.html) (матеріал "
"англійською мовою)"

# header
#: shell-novice/reference.md:246
msgid "### Miscellaneous"
msgstr "### Різне"

# unordered list
#: shell-novice/reference.md:247
msgid ""
"* [North Pacific Gyre](http://en.wikipedia.org/wiki/North_Pacific_Gyre)"
msgstr ""
"* [Північнотихоокеанська "
"течія](https://uk.wikipedia.org/wiki/Північнотихоокеанська_течія)"

# unordered list
#: shell-novice/reference.md:248
msgid ""
"* [Great Pacific Garbage "
"Patch](http://en.wikipedia.org/wiki/Great_Pacific_Garbage_Patch)"
msgstr ""
"* [Велика тихоокеанська сміттєва "
"пляма](https://uk.wikipedia.org/wiki/Велика_тихоокеанська_сміттєва_пляма)"

# unordered list
#: shell-novice/reference.md:249
msgid ""
"* ['Ensuring the longevity of digital information' by Jeff "
"Rothenberg](http://www.clir.org/pubs/archives/ensuring.pdf)"
msgstr ""
"* ['Забезпечення довговічності цифрової інформації', автор Jeff "
"Rothenberg](http://www.clir.org/pubs/archives/ensuring.pdf) (матеріал "
"англійською мовою)"

# unordered list
#: shell-novice/reference.md:250
msgid "* [Computer error haikus](http://wiki.c2.com/?ComputerErrorHaiku)"
msgstr ""
"* [Хайку про комп'ютерні помилки](http://wiki.c2.com/?ComputerErrorHaiku) "
"(матеріал англійською мовою)"

# unordered list
#: shell-novice/reference.md:251
msgid ""
"* [How to name files nicely, by Jenny "
"Bryan](https://speakerdeck.com/jennybc/how-to-name-files)"
msgstr ""
"* ['Як правильно називати файли', автор Jenny "
"Bryan](https://speakerdeck.com/jennybc/how-to-name-files) (матеріал "
"англійською мовою)"

# Front Matter
#: shell-novice/setup.md:1
msgid ""
"---\n"
"layout: page\n"
"title: Setup\n"
"root: .\n"
"---"
msgstr ""
"---\n"
"layout: page\n"
"title: Встановлення\n"
"root: .\n"
"---"

# header
#: shell-novice/setup.md:7
msgid "## Download files"
msgstr "## Завантаження файлів"

#: shell-novice/setup.md:8
msgid "You need to download some files to follow this lesson."
msgstr "Для перегляду цього уроку вам потрібно завантажити деякі файли."

# ordered list
#: shell-novice/setup.md:10
msgid ""
"1. Download [shell-lesson-data.zip][zip-file] and move the file to your "
"Desktop."
msgstr ""
"1. Завантажте [shell-lesson-data.zip][zip-file] і перемістіть файл на "
"робочий стіл."

# ordered list
#: shell-novice/setup.md:11
msgid "2. Unzip/extract the file."
msgstr "2. Розархівуйте файл."

#: shell-novice/setup.md:12
msgid ""
"   **Let your instructor know if you need help with this step**.\n"
"   You should end up with a new folder called **`shell-lesson-data`** on your Desktop."
msgstr ""
"   **Повідомте інструктора, якщо вам потрібна допомога на цьому етапі**.\n"
"   У вас має з'явитися новий каталог з назвою **`shell-lesson-data`** на робочому столі."

# header
#: shell-novice/setup.md:15
msgid "## Install software"
msgstr "## Встановлення програмного забезпечення"

#: shell-novice/setup.md:16
msgid ""
"If you do not already have the shell software installed, you will need to\n"
"[download and install][install_shell] it."
msgstr ""
"Якщо у вас ще не встановлено програму-термінал, вам потрібно\n"
"[завантажити і встановити] [install_shell] її."

# header
#: shell-novice/setup.md:19
msgid "## Open a new shell"
msgstr "## Відкрити новий термінал"

#: shell-novice/setup.md:20
msgid ""
"After installing the software\n"
"3. Open a terminal.\n"
"   If you're not sure how to open a terminal on your operating system, see the instructions below.\n"
"4. In the terminal type `cd` then press the <kbd>Return</kbd> key.\n"
"   This step will make sure you start with your home folder as your working directory."
msgstr ""
"Після встановлення програмного забезпечення\n"
"3. Відкрити термінал.\n"
"   Якщо ви не знаєте, як відкрити термінал у вашій операційній системі, див. інструкції нижче.\n"
"4. У терміналі введіть `cd` і натисніть клавішу <kbd>Return</kbd>.\n"
"   Цей крок гарантує, що ви почнете з вашого домашнього каталогу як робочого каталогу."

#: shell-novice/setup.md:26
msgid ""
"In the lesson, you will find out how to access the data files in this "
"folder."
msgstr ""
"У цьому уроці ви дізнаєтеся, як отримати доступ до файлів даних у цій папці."

# blockquote, which can be cascaded
#: shell-novice/setup.md:28
msgid "> ## Where to type commands: How to open a new shell"
msgstr "> ## Де вводити команди: Як відкрити новий термінал"

#: shell-novice/setup.md:29
msgid ""
">\n"
"> The shell is a program that enables us to send commands to the computer and receive output.\n"
"> It is also referred to as the terminal or command line.\n"
">\n"
"> Some computers include a default Unix Shell program.\n"
"> The steps below describe some methods for identifying and opening\n"
"> a Unix Shell program if you already have one installed.\n"
"> There are also options for identifying and downloading a Unix Shell program,\n"
"> a Linux/UNIX emulator, or a program to access a Unix Shell on a server.\n"
">\n"
"> If none of the options below address your circumstances,\n"
"> try an online search for: Unix shell [your computer model] [your operating system]."
msgstr ""
">\n"
"> Термінал - це програма, за допомогою якої ми можемо надсилати команди комп'ютеру та отримувати результати.\n"
"> Її також називають оболонкою або командним рядком.\n"
">\n"
"> На деяких комп'ютерах за замовчуванням встановлено програму Unix Shell.\n"
"> Нижче описано деякі способи визначення та відкриття\n"
"> програми Unix Shell, якщо її вже встановлено.\n"
"> Також існують способи визначення та завантаження програми Unix Shell,\n"
"> емулятора Linux/UNIX або програми для доступу до оболонки Unix на сервері.\n"
">\n"
"> Якщо жоден із наведених нижче варіантів не відповідає вашим обставинам,\n"
"> спробуйте скористатися пошуком в Інтернеті: Unix shell [модель вашого комп'ютера] [ваша операційна система]."

#: shell-novice/setup.md:43
msgid ""
"{::options parse_block_html=\"true\" /}\n"
"<div>\n"
"<ul class=\"nav nav-tabs nav-justified\" role=\"tablist\">\n"
"<li role=\"presentation\" class=\"active\"><a data-os=\"windows\" href=\"#windows\" aria-controls=\"Windows\"\n"
"role=\"tab\" data-toggle=\"tab\">Windows</a></li>\n"
"<li role=\"presentation\"><a data-os=\"macos\" href=\"#macos\" aria-controls=\"macOS\" role=\"tab\"\n"
"data-toggle=\"tab\">macOS</a></li>\n"
"<li role=\"presentation\"><a data-os=\"linux\" href=\"#linux\" aria-controls=\"Linux\" role=\"tab\"\n"
"data-toggle=\"tab\">Linux</a></li>\n"
"</ul>"
msgstr ""
"{::options parse_block_html=\"true\" /}\n"
"<div>\n"
"<ul class=\"nav nav-tabs nav-justified\" role=\"tablist\">\n"
"<li role=\"presentation\" class=\"active\"><a data-os=\"windows\" href=\"#windows\" aria-controls=\"Windows\"\n"
"role=\"tab\" data-toggle=\"tab\">Windows</a></li>\n"
"<li role=\"presentation\"><a data-os=\"macos\" href=\"#macos\" aria-controls=\"macOS\" role=\"tab\"\n"
"data-toggle=\"tab\">macOS</a></li>\n"
"<li role=\"presentation\"><a data-os=\"linux\" href=\"#linux\" aria-controls=\"Linux\" role=\"tab\"\n"
"data-toggle=\"tab\">Linux</a></li>\n"
"</ul>"

#: shell-novice/setup.md:54
msgid ""
"<div class=\"tab-content\">\n"
"<article role=\"tabpanel\" class=\"tab-pane active\" id=\"windows\">\n"
"Computers with Windows operating systems do not automatically have a Unix Shell program\n"
"installed.\n"
"In this lesson, we encourage you to use an emulator included in [Git for Windows][install_shell],\n"
"which gives you access to both Bash shell commands and Git."
msgstr ""
"<div class=\"tab-content\">\n"
"<article role=\"tabpanel\" class=\"tab-pane active\" id=\"windows\">\n"
"На комп'ютерах з операційною системою Windows автоматично не встановлюється програма Unix Shell\n"
"У цьому уроці ми рекомендуємо вам скористатися емулятором, що входить до складу [Git for Windows][install_shell],\n"
"який надає доступ як до команд оболонки Bash, так і до Git'у."

#: shell-novice/setup.md:61
msgid ""
"Once installed, you can open a terminal by running the program Git Bash from the Windows start\n"
"menu."
msgstr ""
"Після встановлення ви можете відкрити термінал, запустивши програму Git Bash зі стартового\n"
"меню Windows."

#: shell-novice/setup.md:64
msgid "**For advanced users:**"
msgstr "**Для досвідчених користувачів:**"

#: shell-novice/setup.md:66
msgid ""
"As an alternative to Git for Windows you may wish to [Install the Windows Subsystem for Linux][wsl]\n"
"which gives access to a Bash shell command-line tool in Windows 10."
msgstr ""
"Як альтернативу Git'у для Windows ви можете [Встановити підсистему Windows для Linux][wsl]\n"
"яка надає доступ до інструменту командного рядка Bash у Windows 10."

#: shell-novice/setup.md:69
msgid ""
"Please note that commands in the Windows Subsystem for Linux (WSL) may differ slightly\n"
"from those shown in the lesson or presented in the workshop.\n"
"</article>"
msgstr ""
"Зверніть увагу, що команди у підсистемі Windows для Linux (WSL) можуть дещо відрізнятися\n"
"від тих, що показані в уроці або представлені на семінарі.\n"
"</article>"

#: shell-novice/setup.md:73
msgid ""
"<article role=\"tabpanel\" class=\"tab-pane\" id=\"macos\">\n"
"For a Mac computer running macOS Mojave or earlier releases, the default Unix Shell is Bash.\n"
"For a Mac computer running macOS Catalina or later releases, the default Unix Shell is Zsh.\n"
"Your default shell is available via the Terminal program within your Utilities folder."
msgstr ""
"<article role=\"tabpanel\" class=\"tab-pane\" id=\"macos\">\n"
"На комп'ютерах Mac з macOS Mojave або більш ранніми версіями за замовчуванням використовується Unix-термінал Bash.\n"
"На комп'ютерах Mac з macOS Catalina або пізніших версій стандартним терміналом Unix є Zsh.\n"
"Ваша стандартний термінал доступний за допомогою програми Terminal у каталозі Utilities."

#: shell-novice/setup.md:78
msgid ""
"To open Terminal, try one or both of the following:\n"
"* In Finder, select the Go menu, then select Utilities.\n"
"  Locate Terminal in the Utilities folder and open it.\n"
"* Use the Mac 'Spotlight' computer search function.\n"
"  Search for: `Terminal` and press <kbd>Return</kbd>."
msgstr ""
"Щоб відкрити Термінал, спробуйте один або обидва з наведених нижче способів:\n"
"* У Finder виберіть меню \"Перехід\", а потім виберіть \"Утиліти\".\n"
"Знайдіть програму Terminal у папці Utilities і відкрийте її.\n"
"* Використовуйте функцію пошуку на комп'ютері Mac 'Spotlight'.\n"
"Знайдіть `Термінал` і натисніть <kbd>Return</kbd>."

#: shell-novice/setup.md:84
msgid ""
"To check if your machine is set up to use something other than Bash,\n"
"type `echo $SHELL` in your terminal window."
msgstr ""
"Щоб перевірити, чи налаштовано на вашому комп'ютері використання чогось іншого, окрім Bash,\n"
"введіть `echo $SHELL` у вікні вашого терміналу."

#: shell-novice/setup.md:87
msgid ""
"If your machine is set up to use something other than Bash,\n"
"you can run it by opening a terminal and typing `bash`."
msgstr ""
"Щоб перевірити, чи налаштовано ваш комп'ютер на використання чогось іншого, окрім Bash,\n"
"введіть `echo $SHELL` у вікні вашого терміналу."

#: shell-novice/setup.md:90
msgid ""
"[How to Use Terminal on a Mac][mac-terminal]\n"
"</article>"
msgstr ""
"[Як користуватися терміналом на Mac][mac-terminal]\n"
"</article>"

#: shell-novice/setup.md:93
msgid ""
"<article role=\"tabpanel\" class=\"tab-pane\" id=\"linux\">\n"
"The default Unix Shell for Linux operating systems is usually Bash.\n"
"On most versions of Linux, it is accessible by running the\n"
"[Gnome Terminal][gnome-terminal] or [KDE Konsole][kde-konsole] or [xterm][xterm],\n"
"which can be found via the applications menu or the search bar.\n"
"If your machine is set up to use something other than Bash,\n"
"you can run it by opening a terminal and typing `bash`.\n"
"</article>\n"
"</div>\n"
"</div>"
msgstr ""
"<article role=\"tabpanel\" class=\"tab-pane\" id=\"linux\">\n"
"Терміналом Unix для операційних систем Linux за замовчуванням зазвичай є Bash.\n"
"У більшості версій Linux він доступний за допомогою команд\n"
"[Gnome Terminal][gnome-terminal], [KDE Konsole][kde-konsole] або [xterm][xterm],\n"
"які можна знайти за допомогою меню програм або рядка пошуку.\n"
"Якщо на вашому комп'ютері налаштовано використання інших програм, окрім Bash,\n"
"ви можете запустити її, відкривши термінал і набравши `bash`.\n"
"</div>\n"
"</div>"

#: shell-novice/setup.md:104
msgid ""
"[zip-file]: {{ page.root }}/data/shell-lesson-data.zip\n"
"[wsl]: https://docs.microsoft.com/en-us/windows/wsl/install-win10\n"
"[mac-terminal]: http://www.macworld.co.uk/feature/mac-software/how-use-terminal-on-mac-3608274/\n"
"[gnome-terminal]: https://help.gnome.org/users/gnome-terminal/stable/\n"
"[kde-konsole]: https://konsole.kde.org/\n"
"[xterm]: https://en.wikipedia.org/wiki/Xterm\n"
"[install_shell]: https://carpentries.github.io/workshop-template/#shell"
msgstr ""
"[zip-file]: {{ page.root }}/data/shell-lesson-data.zip\n"
"[wsl]: https://docs.microsoft.com/en-us/windows/wsl/install-win10\n"
"[mac-terminal]: http://www.macworld.co.uk/feature/mac-software/how-use-terminal-on-mac-3608274/\n"
"[gnome-terminal]: https://help.gnome.org/users/gnome-terminal/stable/\n"
"[kde-konsole]: https://konsole.kde.org/\n"
"[xterm]: https://en.wikipedia.org/wiki/Xterm\n"
"[install_shell]: https://carpentries.github.io/workshop-template/#shell"

