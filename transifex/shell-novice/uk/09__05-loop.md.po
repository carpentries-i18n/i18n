# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Oleksandr Miroshkin <miroshkinan@gmail.com>, 2023
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2023-02-12 19:32:08+0000\n"
"PO-Revision-Date: 2023-02-12 19:38+0000\n"
"Last-Translator: Oleksandr Miroshkin <miroshkinan@gmail.com>, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/carpentries-i18n/teams/98915/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

# Front Matter
#: shell-novice/_episodes/05-loop.md:1
msgid ""
"---\n"
"title: \"Loops\"\n"
"teaching: 40\n"
"exercises: 10\n"
"questions:\n"
"- \"How can I perform the same actions on many different files?\"\n"
"objectives:\n"
"- \"Write a loop that applies one or more commands separately to each file in a set of files.\"\n"
"- \"Trace the values taken on by a loop variable during execution of the loop.\"\n"
"- \"Explain the difference between a variable's name and its value.\"\n"
"- \"Explain why spaces and some punctuation characters shouldn't be used in file names.\"\n"
"- \"Demonstrate how to see what commands have recently been executed.\"\n"
"- \"Re-run recently executed commands without retyping them.\"\n"
"keypoints:\n"
"- \"A `for` loop repeats commands once for every thing in a list.\"\n"
"- \"Every `for` loop needs a variable to refer to the thing it is currently operating on.\"\n"
"- \"Use `$name` to expand a variable (i.e., get its value). `${name}` can also be used.\"\n"
"- \"Do not use spaces, quotes, or wildcard characters such as '*' or '?' in filenames, as it complicates variable expansion.\"\n"
"- \"Give files consistent names that are easy to match with wildcard patterns to make it easy to select them for looping.\"\n"
"- \"Use the up-arrow key to scroll up through previous commands to edit and repeat them.\"\n"
"- \"Use <kbd>Ctrl</kbd>+<kbd>R</kbd> to search through the previously entered commands.\"\n"
"- \"Use `history` to display recent commands, and `![number]` to repeat a command by number.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Цикли\"\n"
"teaching: 40\n"
"exercises: 10\n"
"questions:\n"
"- \"Як виконати одні й ті ж дії над різними файлами?\"\n"
"objectives:\n"
"- \"Написати цикл, який застосовує одну або декілька команд окремо до кожного файлу в наборі файлів\".\n"
"- \"Простежити, яких значень набуває змінна циклу під час виконання циклу\".\n"
"- \"Пояснити різницю між ім'ям змінної та її значенням\".\n"
"- \"Пояснити, чому в іменах файлів не можна використовувати пробіли та деякі розділові знаки\".\n"
"- \"Продемонструвати, як побачити, які команди були виконані останнім часом\".\n"
"- \"Повторно запустити нещодавно виконані команди без повторного введення\".\n"
"keypoints:\n"
"- \"Цикл `for` повторює команди один раз для кожного елемента списку.\"\n"
"- \"Кожному циклу `for` потрібна змінна для посилання на об'єкт, над яким він зараз працює.\"\n"
"- \"Використовуйте `$name` для розкриття змінної (тобто отримання її значення). Також можна використовувати `${name}`.\"\n"
"- \"Не використовуйте у назвах файлів пробіли, лапки або символи підстановки, такі як '*' або '?', оскільки це ускладнює розширення змінних.\"\n"
"- \"Надавайте файлам однакові імена, які легко співпадають із шаблонами підстановок, щоб полегшити їх вибір для циклів\".\n"
"- \"Використовуйте клавішу зі стрілкою вгору для прокрутки попередніх команд, щоб редагувати та повторювати їх.\"\n"
"- \"Використовуйте <kbd>Ctrl</kbd>+<kbd>R</kbd> для пошуку попередньо введених команд.\"\n"
"- \"Використовуйте `history` для відображення останніх команд і `![номер]` для повторення команди за номером.\"\n"
"---"

#: shell-novice/_episodes/05-loop.md:25
msgid ""
"**Loops** are a programming construct which allow us to repeat a command or set of commands\n"
"for each item in a list.\n"
"As such they are key to productivity improvements through automation.\n"
"Similar to wildcards and tab completion, using loops also reduces the\n"
"amount of typing required (and hence reduces the number of typing mistakes)."
msgstr ""
"**Цикли** - це конструкція програмування, яка дозволяє повторювати команду або набір команд\n"
"для кожного елемента у списку.\n"
"Таким чином, вони є ключем до підвищення продуктивності за рахунок автоматизації.\n"
"Подібно до підстановочних символів і завершення клавішею табуляції, використання циклів також зменшує\n"
"кількість необхідного набору тексту (а отже, зменшує кількість помилок)."

#: shell-novice/_episodes/05-loop.md:31
msgid ""
"Suppose we have several hundred genome data files named `basilisk.dat`, `minotaur.dat`, and\n"
"`unicorn.dat`.\n"
"For this example, we'll use the `exercise-data/creatures` directory which only has three\n"
"example files,\n"
"but the principles can be applied to many many more files at once."
msgstr ""
"Припустимо, у нас є кілька сотень файлів геномних даних з іменами `basilisk.dat`, `minotaur.dat` та\n"
"`unicorn.dat`.\n"
"Для цього прикладу ми використаємо каталог `exercise-data/creatures`, який містить лише три\n"
"файли з прикладами,\n"
"але ці принципи можна застосувати до набагато більшої кількості файлів одночасно."

#: shell-novice/_episodes/05-loop.md:37
msgid ""
"The structure of these files is the same: the common name, classification, and updated date are\n"
"presented on the first three lines, with DNA sequences on the following lines.\n"
"Let's look at the files:"
msgstr ""
"Структура цих файлів однакова: загальна назва, класифікація та дата оновлення\n"
"у перших трьох рядках, а в наступних - послідовності ДНК.\n"
"Давайте подивимось на файли:"

# code block
#: shell-novice/_episodes/05-loop.md:41
msgid ""
"```\n"
"$ head -n 5 basilisk.dat minotaur.dat unicorn.dat\n"
"```"
msgstr ""
"```\n"
"$ head -n 5 basilisk.dat minotaur.dat unicorn.dat\n"
"```"

#: shell-novice/_episodes/05-loop.md:46
msgid ""
"We would like to print out the classification for each species, which is given on the second\n"
"line of each file.\n"
"For each file, we would need to execute the command `head -n 2` and pipe this to `tail -n 1`.\n"
"We’ll use a loop to solve this problem, but first let’s look at the general form of a loop,\n"
"using the pseudo-code below:"
msgstr ""
"Ми хотіли б роздрукувати класифікацію для кожного виду, яка наведена у другому\n"
"рядку кожного файлу.\n"
"Для кожного файлу нам потрібно виконати команду `head -n 2` і з'єднати її каналом з командою `tail -n 1`.\n"
"Для вирішення цієї задачі ми скористаємося циклом, але спочатку розглянемо загальну форму циклу,\n"
"використовуючи псевдокод нижче:"

# code block
#: shell-novice/_episodes/05-loop.md:52
msgid ""
"```\n"
"for thing in list_of_things\n"
"do\n"
"    operation_using $thing    # Indentation within the loop is not required, but aids legibility\n"
"done\n"
"```"
msgstr ""
"```\n"
"for thing in list_of_things\n"
"do\n"
"    operation_using $thing    # Відступ усередині циклу не є обов'язковим, але полегшує читабельність\n"
"done\n"
"```"

#: shell-novice/_episodes/05-loop.md:60
msgid "and we can apply this to our example like this:"
msgstr "і ми можемо застосувати це до нашого прикладу наступним чином:"

# code block
#: shell-novice/_episodes/05-loop.md:62
msgid ""
"```\n"
"$ for filename in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $filename | tail -n 1\n"
"> done\n"
"```"
msgstr ""
"```\n"
"$ for filename in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $filename | tail -n 1\n"
"> done\n"
"```"

# code block
#: shell-novice/_episodes/05-loop.md:70
msgid ""
"```\n"
"CLASSIFICATION: basiliscus vulgaris\n"
"CLASSIFICATION: bos hominus\n"
"CLASSIFICATION: equus monoceros\n"
"```"
msgstr ""
"```\n"
"CLASSIFICATION: basiliscus vulgaris\n"
"CLASSIFICATION: bos hominus\n"
"CLASSIFICATION: equus monoceros\n"
"```"

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:78
msgid "> ## Follow the Prompt"
msgstr "> ## Слідкуйте за підказкою"

#: shell-novice/_episodes/05-loop.md:79
msgid ""
">\n"
"> The shell prompt changes from `$` to `>` and back again as we were\n"
"> typing in our loop. The second prompt, `>`, is different to remind\n"
"> us that we haven't finished typing a complete command yet. A semicolon, `;`,\n"
"> can be used to separate two commands written on a single line."
msgstr ""
">\n"
"> Запрошення до введення в терміналі змінюється з `$` на `>` і назад, коли ми\n"
"> вводили команди всередині нашого циклу. Друге запрошення до введення, `>`, відрізняється, щоб нагадати\n"
"> нам, що ми ще не закінчили введення повної команди. Крапка з комою `;`\n"
"> використовується для розділення двох команд, написаних в одному рядку."

#: shell-novice/_episodes/05-loop.md:86
msgid ""
"When the shell sees the keyword `for`,\n"
"it knows to repeat a command (or group of commands) once for each item in a list.\n"
"Each time the loop runs (called an iteration), an item in the list is assigned in sequence to\n"
"the **variable**, and the commands inside the loop are executed, before moving on to\n"
"the next item in the list.\n"
"Inside the loop,\n"
"we call for the variable's value by putting `$` in front of it.\n"
"The `$` tells the shell interpreter to treat\n"
"the variable as a variable name and substitute its value in its place,\n"
"rather than treat it as text or an external command."
msgstr ""
"Коли термінал бачить ключове слово `for`,\n"
"він знає, що потрібно повторити команду (або групу команд) один раз для кожного елемента списку.\n"
"Кожного разу, коли вміст циклу виконується (одне виконання команд всередині циклу називається ітерацією), елемент списку послідовно присвоюється\n"
"**змінній**, і команди всередині циклу виконуються, перш ніж перейти\n"
"до наступного елементу списку.\n"
"Усередині циклу\n"
"ми звертаємося до значення змінної, ставлячи `$` перед ї іменем.\n"
"Символ `$` вказує інтерпретатору командного рядка розглядати\n"
"змінну як ім'я змінної і підставити замість неї її значення,\n"
"замість того, щоб розглядати її як текст або зовнішню команду."

#: shell-novice/_episodes/05-loop.md:97
msgid ""
"In this example, the list is three filenames: `basilisk.dat`, `minotaur.dat`, and `unicorn.dat`.\n"
"Each time the loop iterates, it will assign a file name to the variable `filename`\n"
"and run the `head` command.\n"
"The first time through the loop,\n"
"`$filename` is `basilisk.dat`.\n"
"The interpreter runs the command `head` on `basilisk.dat`\n"
"and pipes the first two lines to the `tail` command,\n"
"which then prints the second line of `basilisk.dat`.\n"
"For the second iteration, `$filename` becomes\n"
"`minotaur.dat`. This time, the shell runs `head` on `minotaur.dat`\n"
"and pipes the first two lines to the `tail` command,\n"
"which then prints the second line of `minotaur.dat`.\n"
"For the third iteration, `$filename` becomes\n"
"`unicorn.dat`, so the shell runs the `head` command on that file,\n"
"and `tail` on the output of that.\n"
"Since the list was only three items, the shell exits the `for` loop."
msgstr ""
"У цьому прикладі список складається з трьох файлів: `basilisk.dat`, `minotaur.dat` та `unicorn.dat`.\n"
"Кожного разу, коли виконанується цикл, він присвоює чергове ім'я файлу змінній `filename`\n"
"і виконає команду `head`.\n"
"При першому проходженні циклу\n"
"`$filename` дорівнює `basilisk.dat`.\n"
"Інтерпретатор виконує команду `head` на `basilisk.dat`\n"
"і передає перші два рядки команді `tail`,\n"
"яка виводить другий рядок файлу `basilisk.dat`.\n"
"Для другої ітерації `$filename` стає\n"
"`minotaur.dat`. Цього разу термінал виконує команду `head` на `minotaur.dat`\n"
"і передає перші два рядки команді `tail`,\n"
"яка виводить другий рядок `minotaur.dat`.\n"
"На третій ітерації `$filename` стає\n"
"`unicorn.dat`, тому термінал виконує команду `head` для цього файлу,\n"
"і `tail` на виході цього.\n"
"Оскільки у списку було лише три елементи, термінал вийде з циклу `for`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:114
msgid "> ## Same Symbols, Different Meanings"
msgstr "> ## Однакові символи, різні значення"

#: shell-novice/_episodes/05-loop.md:115
msgid ""
">\n"
"> Here we see `>` being used as a shell prompt, whereas `>` is also\n"
"> used to redirect output.\n"
"> Similarly, `$` is used as a shell prompt, but, as we saw earlier,\n"
"> it is also used to ask the shell to get the value of a variable.\n"
">\n"
"> If the *shell* prints `>` or `$` then it expects you to type something,\n"
"> and the symbol is a prompt.\n"
">\n"
"> If *you* type `>` or `$` yourself, it is an instruction from you that\n"
"> the shell should redirect output or get the value of a variable."
msgstr ""
">\n"
"> Тут ми бачимо, що символ `>` використовується як запрошення командного рядка, тоді як `>` також\n"
"> використовується для перенаправлення виводу.\n"
"> Аналогічно, символ `$` використовується як запрошення до командного рядка, але, як ми бачили раніше,\n"
"> він також використовується для запиту до оболонки про значення змінної.\n"
">\n"
"> Якщо *термінал* виводить `>` або `$`, то він очікує, що ви щось введете,\n"
"> і цей символ є підказкою.\n"
">\n"
"> Якщо *ви* вводите `>` або `$` самостійно, це є вашою вказівкою про те, що\n"
"> оболонці перенаправити вивід або отримати значення змінної."

#: shell-novice/_episodes/05-loop.md:128
msgid ""
"When using variables it is also\n"
"possible to put the names into curly braces to clearly delimit the variable\n"
"name: `$filename` is equivalent to `${filename}`, but is different from\n"
"`${file}name`. You may find this notation in other people's programs."
msgstr ""
"При використанні змінних також\n"
"можна брати імена у фігурні дужки, щоб чітко розмежувати імена змінних:\n"
"`$filename` еквівалентно `${filename}`, але відрізняється від\n"
"`${file}name`. Ви можете зустріти таку форму запису у програмах інших людей."

#: shell-novice/_episodes/05-loop.md:133
msgid ""
"We have called the variable in this loop `filename`\n"
"in order to make its purpose clearer to human readers.\n"
"The shell itself doesn't care what the variable is called;\n"
"if we wrote this loop as:"
msgstr ""
"Ми назвали змінну у цьому циклі `filename` (ім'я файлу)\n"
"для того, щоб зробити її призначення більш зрозумілим для читачів-людей.\n"
"Самій оболонці байдуже, як називається змінна;\n"
"якщо ми напишемо цей цикл наступним чином:"

# code block
#: shell-novice/_episodes/05-loop.md:138
msgid ""
"~~~\n"
"$ for x in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $x | tail -n 1\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for x in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $x | tail -n 1\n"
"> done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:146
msgid "or:"
msgstr "чи:"

# code block
#: shell-novice/_episodes/05-loop.md:148
msgid ""
"~~~\n"
"$ for temperature in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $temperature | tail -n 1\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for temperature in basilisk.dat minotaur.dat unicorn.dat\n"
"> do\n"
">     head -n 2 $temperature | tail -n 1\n"
"> done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:156
msgid ""
"it would work exactly the same way.\n"
"*Don't do this.*\n"
"Programs are only useful if people can understand them,\n"
"so meaningless names (like `x`) or misleading names (like `temperature`)\n"
"increase the odds that the program won't do what its readers think it does."
msgstr ""
"це спрацювало б точно так само.\n"
"*Не роби цього.*\n"
"Програми корисні лише тоді, коли люди можуть їх розуміти,\n"
"тому беззмістовні назви (наприклад, `x`) або назви, що вводять в оману (наприклад, `temperature`)\n"
"збільшують ймовірність того, що програма не буде робити те, що читачі думають, що вона робить."

#: shell-novice/_episodes/05-loop.md:162
msgid ""
"In the above examples, the variables (`thing`, `filename`, `x` and `temperature`)\n"
"could have been given any other name, as long as it is meaningful to both the person\n"
"writing the code and the person reading it."
msgstr ""
"У наведених вище прикладах змінним (`thing`, `filename`, `x` та `temperature`)\n"
"можна було б назвати будь-якою іншою назвою, аби вона була зрозумілою як для того,\n"
"хто пише код, так і для того, хто його читає."

#: shell-novice/_episodes/05-loop.md:166
msgid ""
"Note also that loops can be used for other things than filenames, like a list of numbers\n"
"or a subset of data."
msgstr ""
"Зауважте також, що цикли можна використовувати для інших речей, окрім імен файлів, наприклад, для списку чисел\n"
"або підмножини даних."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:169
msgid "> ## Write your own loop"
msgstr "> ## Напишіть власний цикл"

#: shell-novice/_episodes/05-loop.md:170
msgid ""
">\n"
"> How would you write a loop that echoes all 10 numbers from 0 to 9?\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > $ for loop_variable in 0 1 2 3 4 5 6 7 8 9\n"
"> > > do\n"
"> > >     echo $loop_variable\n"
"> > > done\n"
"> > ~~~\n"
"> > {: .language-bash}\n"
"> >\n"
"> > ```\n"
"> > 0\n"
"> > 1\n"
"> > 2\n"
"> > 3\n"
"> > 4\n"
"> > 5\n"
"> > 6\n"
"> > 7\n"
"> > 8\n"
"> > 9\n"
"> > ```\n"
"> > {: .output}"
msgstr ""
">\n"
"> Як би ви написали цикл, який виводить всі 10 чисел від 0 до 9?\n"
">\n"
"> > ## Розв'язання\n"
"> >\n"
"> > ~~~\n"
"> > $ for loop_variable in 0 1 2 3 4 5 6 7 8 9\n"
"> > > do\n"
"> > >     echo $loop_variable\n"
"> > > done\n"
"> > ~~~\n"
"> > {: .language-bash}\n"
"> >\n"
"> > ```\n"
"> > 0\n"
"> > 1\n"
"> > 2\n"
"> > 3\n"
"> > 4\n"
"> > 5\n"
"> > 6\n"
"> > 7\n"
"> > 8\n"
"> > 9\n"
"> > ```\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:199
msgid "> ## Variables in Loops"
msgstr "> ## Змінні в циклах"

#: shell-novice/_episodes/05-loop.md:200
msgid ""
">\n"
"> This exercise refers to the `shell-lesson-data/exercise-data/proteins` directory.\n"
"> `ls *.pdb` gives the following output:\n"
">\n"
"> ~~~\n"
"> cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> ~~~"
msgstr ""
">\n"
"> Ця вправа звертається до каталогу `shell-lesson-data/exercise-data/proteins`.\n"
"> `ls *.pdb` видає наступний результат:\n"
">\n"
"> ~~~\n"
"> cubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:208
msgid ""
">\n"
"> What is the output of the following code?\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     ls *.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Now, what is the output of the following code?\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     ls $datafile\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Why do these two loops give different outputs?\n"
">\n"
"> > ## Solution\n"
"> > The first code block gives the same output on each iteration through\n"
"> > the loop.\n"
"> > Bash expands the wildcard `*.pdb` within the loop body (as well as\n"
"> > before the loop starts) to match all files ending in `.pdb`\n"
"> > and then lists them using `ls`.\n"
"> > The expanded loop would look like this:\n"
"> > ```\n"
"> > $ for datafile in cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > > do\n"
"> > >     ls cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > > done\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> >\n"
"> > ```\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > ```\n"
"> > {: .output}\n"
"> >\n"
"> > The second code block lists a different file on each loop iteration.\n"
"> > The value of the `datafile` variable is evaluated using `$datafile`,\n"
"> > and then listed using `ls`.\n"
"> >\n"
"> > ```\n"
"> > cubane.pdb\n"
"> > ethane.pdb\n"
"> > methane.pdb\n"
"> > octane.pdb\n"
"> > pentane.pdb\n"
"> > propane.pdb\n"
"> > ```\n"
"> > {: .output}"
msgstr ""
">\n"
"> Що виводить наступний код?\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     ls *.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Тепер, що виводить наступний код?\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     ls $datafile\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Чому ці два цикли дають різні результати?\n"
">\n"
"> > ## Розв'язання\n"
"> > Перший блок коду дає однаковий результат на кожній ітерації\n"
"> > циклу.\n"
"> > Bash розширює шаблон `*.pdb` в тілі циклу (а також\n"
"> > перед початком циклу), щоб знайти всі файли, що закінчуються на `.pdb`.\n"
"> > а потім перераховує їх за допомогою `ls`.\n"
"> > Розширений цикл матиме такий вигляд:\n"
"> > ```\n"
"> > $ for datafile in cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > > do\n"
"> > >     ls cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > > done\n"
"> > ```\n"
"> > {: .language-bash}\n"
"> >\n"
"> > ```\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n"
"> > ```\n"
"> > {: .output}\n"
"> >\n"
"> > Другий блок коду перераховує різні файли на кожній ітерації циклу.\n"
"> > Значення змінної `datafile` обчислюється за допомогою `$datafile`,\n"
"> > а потім перераховується за допомогою `ls`.\n"
"> >\n"
"> > ```\n"
"> > cubane.pdb\n"
"> > ethane.pdb\n"
"> > methane.pdb\n"
"> > octane.pdb\n"
"> > pentane.pdb\n"
"> > propane.pdb\n"
"> > ```\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:272
msgid "> ## Limiting Sets of Files"
msgstr "> ## Обмеження набору файлів"

#: shell-novice/_episodes/05-loop.md:273
msgid ""
">\n"
"> What would be the output of running the following loop in the\n"
"> `shell-lesson-data/exercise-data/proteins` directory?\n"
">\n"
"> ~~~\n"
"> $ for filename in c*\n"
"> > do\n"
"> >     ls $filename\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1.  No files are listed.\n"
"> 2.  All files are listed.\n"
"> 3.  Only `cubane.pdb`, `octane.pdb` and `pentane.pdb` are listed.\n"
"> 4.  Only `cubane.pdb` is listed.\n"
">\n"
"> > ## Solution\n"
"> > 4 is the correct answer. `*` matches zero or more characters, so any file name starting with\n"
"> > the letter c, followed by zero or more other characters will be matched."
msgstr ""
">\n"
"> Що буде виведено у результаті виконання наступного циклу в каталозі\n"
"> `shell-lesson-data/exercise-data/proteins`?>\n"
"> ~~~\n"
"> $ for filename in c*\n"
"> > do\n"
"> >     ls $filename\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Жодної назви файлу не буде виведено.\n"
"> 2. Будуть перелічені всі файли.\n"
"> 3. Будуть перелічені лише `cubane.pdb`, `octane.pdb` та `pentane.pdb`.\n"
"> 4. Буде виведено лише `cubane.pdb`.\n"
">\n"
"> > ## Розв'язання\n"
"> > 4 - правильна відповідь. Підстановочний символ `*` відповідає нулю або більшій кількості символів, тому будь-яке ім'я файлу, що починається з\n"
"> > літери 'c', за якою йдуть нуль або більша кількість символів, підійде."

#: shell-novice/_episodes/05-loop.md:294
msgid ""
">\n"
"> How would the output differ from using this command instead?\n"
">\n"
"> ~~~\n"
"> $ for filename in *c*\n"
"> > do\n"
"> >     ls $filename\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1.  The same files would be listed.\n"
"> 2.  All the files are listed this time.\n"
"> 3.  No files are listed this time.\n"
"> 4.  The files `cubane.pdb` and `octane.pdb` will be listed.\n"
"> 5.  Only the file `octane.pdb` will be listed.\n"
">\n"
"> > ## Solution\n"
"> > 4 is the correct answer. `*` matches zero or more characters, so a file name with zero or more\n"
"> > characters before a letter c and zero or more characters after the letter c will be matched."
msgstr ""
">\n"
"> Як зміниться результат, якщо замість неї використати цю команду?\n"
">\n"
"> ~~~\n"
"> $ for filename in *c*\n"
"> > do\n"
"> >     ls $filename\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Будуть перераховані ті ж файли.\n"
"> 2. Цього разу перераховані всі файли.\n"
"> 3. Цього разу не виведено жодного файла.\n"
"> 4. Будуть перераховані файли `cubane.pdb` і `octane.pdb`.\n"
"> 5. Буде перераховано лише файл `octane.pdb`.\n"
">\n"
"> > ## Розв'язання\n"
"> > 4 - правильна відповідь. Підстановочний символ `*` відповідає нулю або більшій кількості символів, тому всі імена файлів з нулем або більшою кількістю\n"
"> > символів перед літерою 'c' і нулем або більшою кількістю символів після літери 'c' підійдуть."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:317
msgid "> ## Saving to a File in a Loop - Part One"
msgstr "> ## Збереження у файл в циклі - Частина перша"

#: shell-novice/_episodes/05-loop.md:318
msgid ""
">\n"
"> In the `shell-lesson-data/exercise-data/proteins` directory, what is the effect of this loop?\n"
">\n"
"> ~~~\n"
"> for alkanes in *.pdb\n"
"> do\n"
">     echo $alkanes\n"
">     cat $alkanes > alkanes.pdb\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1.  Prints `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb` and\n"
">    `propane.pdb`, and the text from `propane.pdb` will be saved to a file called `alkanes.pdb`.\n"
"> 2.  Prints `cubane.pdb`, `ethane.pdb`, and `methane.pdb`, and the text from all three files\n"
">     would be concatenated and saved to a file called `alkanes.pdb`.\n"
"> 3.  Prints `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, and `pentane.pdb`,\n"
">     and the text from `propane.pdb` will be saved to a file called `alkanes.pdb`.\n"
"> 4.  None of the above.\n"
">\n"
"> > ## Solution\n"
"> > 1. The text from each file in turn gets written to the `alkanes.pdb` file.\n"
"> > However, the file gets overwritten on each loop iteration, so the final content of\n"
"> > `alkanes.pdb`\n"
"> > is the text from the `propane.pdb` file."
msgstr ""
">\n"
"> В каталозі `shell-lesson-data/exercise-data/proteins`, який результат роботи цього циклу?\n"
">\n"
"> ~~~\n"
"> for alkanes in *.pdb\n"
"> do\n"
">     echo $alkanes\n"
">     cat $alkanes > alkanes.pdb\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Буде виведено `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb` і\n"
"> `propane.pdb`, а текст з `propane.pdb` буде збережено у файлі з назвою `alkanes.pdb`.\n"
"> 2. Буде виведено `cubane.pdb`, `ethane.pdb` і `methane.pdb`, і текст з усіх трьох файлів\n"
"> буде об'єднано і збережено у файл з назвою `alkanes.pdb`.\n"
"> 3. Буде виведено `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb` і `pentane.pdb`,\n"
"> а текст з `propane.pdb` буде збережено до файлу з назвою `alkanes.pdb`.\n"
"> 4. Нічого з перерахованого вище.\n"
">\n"
"> > ## Розв'язання\n"
"> > 1. Текст з кожного файлу по черзі записується у файл `alkanes.pdb`.\n"
"> Однак, файл перезаписується на кожній ітерації циклу, тому кінцевий вміст\n"
"> > `alkanes.pdb'\n"
"> > буде дорівнювати тексту з файлу `propane.pdb`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:346
msgid "> ## Saving to a File in a Loop - Part Two"
msgstr "> ## Збереження у файл в циклі - Частина друга"

#: shell-novice/_episodes/05-loop.md:347
msgid ""
">\n"
"> Also in the `shell-lesson-data/exercise-data/proteins` directory,\n"
"> what would be the output of the following loop?\n"
">\n"
"> ~~~\n"
"> for datafile in *.pdb\n"
"> do\n"
">     cat $datafile >> all.pdb\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1.  All of the text from `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, and\n"
">     `pentane.pdb` would be concatenated and saved to a file called `all.pdb`.\n"
"> 2.  The text from `ethane.pdb` will be saved to a file called `all.pdb`.\n"
"> 3.  All of the text from `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb`\n"
">     and `propane.pdb` would be concatenated and saved to a file called `all.pdb`.\n"
"> 4.  All of the text from `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb`\n"
">     and `propane.pdb` would be printed to the screen and saved to a file called `all.pdb`.\n"
">\n"
"> > ## Solution\n"
"> > 3 is the correct answer. `>>` appends to a file, rather than overwriting it with the redirected\n"
"> > output from a command.\n"
"> > Given the output from the `cat` command has been redirected, nothing is printed to the screen."
msgstr ""
">\n"
"> Також у каталозі `shell-lesson-data/exercise-data/proteins`,\n"
"> що буде виведено у наступному циклі?>\n"
"> ~~~\n"
"> for datafile in *.pdb\n"
"> do\n"
">     cat $datafile >> all.pdb\n"
"> done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Весь текст з файлів `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb` та\n"
"> `pentane.pdb` буде об'єднано і збережено у файлі з назвою `all.pdb`.\n"
"> 2. Текст з файлу `ethane.pdb` буде збережено до файлу з назвою `all.pdb`.\n"
"> 3. Весь текст з файлів `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb`\n"
"> та `propane.pdb` буде об'єднано та збережено у файл з назвою `all.pdb`.\n"
"> 4. Весь текст з файлів `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb`\n"
"> і `propane.pdb` буде виведено на екран і збережено у файлі з назвою `all.pdb`.\n"
">\n"
"> > ## Розв'язання\n"
"> > 3 - правильна відповідь. Оператор `>>` додає вміст до файлу, а не перезаписує його перенаправленим\n"
"> > виводом команди.\n"
"> > Оскільки вивід команди `cat` було перенаправлено, на екран нічого не буде виведено."

#: shell-novice/_episodes/05-loop.md:374
msgid ""
"Let's continue with our example in the `shell-lesson-data/exercise-data/creatures` directory.\n"
"Here's a slightly more complicated loop:"
msgstr ""
"Давайте продовжимо наш приклад у каталозі `shell-lesson-data/exercise-data/creatures`.\n"
"Тут цикл трохи складніший:"

# code block
#: shell-novice/_episodes/05-loop.md:377
msgid ""
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     echo $filename\n"
">     head -n 100 $filename | tail -n 20\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     echo $filename\n"
">     head -n 100 $filename | tail -n 20\n"
"> done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:386
msgid ""
"The shell starts by expanding `*.dat` to create the list of files it will process.\n"
"The **loop body**\n"
"then executes two commands for each of those files.\n"
"The first command, `echo`, prints its command-line arguments to standard output.\n"
"For example:"
msgstr ""
"Термінал розпочинає роботу з розгортання `*.dat` для створення списку файлів, які він буде обробляти.\n"
"**Тіло циклу**\n"
"виконує дві команди для кожного з цих файлів.\n"
"Перша команда, `echo`, виводить аргументи командного рядка у стандартний вивід.\n"
"Наприклад:"

# code block
#: shell-novice/_episodes/05-loop.md:392
msgid ""
"~~~\n"
"$ echo hello there\n"
"~~~"
msgstr ""
"~~~\n"
"$ echo hello there\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:397
msgid "prints:"
msgstr "виводить:"

# code block
#: shell-novice/_episodes/05-loop.md:399
msgid ""
"~~~\n"
"hello there\n"
"~~~"
msgstr ""
"~~~\n"
"hello there\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:404
msgid ""
"In this case,\n"
"since the shell expands `$filename` to be the name of a file,\n"
"`echo $filename` prints the name of the file.\n"
"Note that we can't write this as:"
msgstr ""
"У цьому випадку,\n"
"оскільки термінал розширює `$filename` до імені файлу,\n"
"`echo $filename` виводить ім'я файлу.\n"
"Зауважте, що ми не можемо написати це як:"

# code block
#: shell-novice/_episodes/05-loop.md:409
msgid ""
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     $filename\n"
">     head -n 100 $filename | tail -n 20\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     $filename\n"
">     head -n 100 $filename | tail -n 20\n"
"> done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:418
msgid ""
"because then the first time through the loop,\n"
"when `$filename` expanded to `basilisk.dat`, the shell would try to run `basilisk.dat` as\n"
"a program.\n"
"Finally,\n"
"the `head` and `tail` combination selects lines 81-100\n"
"from whatever file is being processed\n"
"(assuming the file has at least 100 lines)."
msgstr ""
"тому що при першому проходженні через цикл,\n"
"коли `$filename` розшириться до `basilisk.dat`, оболонка спробує запустити `basilisk.dat`\n"
"як програму.\n"
"Нарешті,\n"
"комбінація `head` і `tail` виділить рядки 81-100\n"
"з будь-якого файлу, який обробляється\n"
"(за умови, що у відповідному файлі є принаймні 100 рядків)."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:426
msgid "> ## Spaces in Names"
msgstr "> ## Пробіли в іменах"

#: shell-novice/_episodes/05-loop.md:427
msgid ""
">\n"
"> Spaces are used to separate the elements of the list\n"
"> that we are going to loop over. If one of those elements\n"
"> contains a space character, we need to surround it with\n"
"> quotes, and do the same thing to our loop variable.\n"
"> Suppose our data files are named:\n"
">\n"
"> ~~~\n"
"> red dragon.dat\n"
"> purple unicorn.dat\n"
"> ~~~"
msgstr ""
">\n"
"> Пробіли використовуються для відокремлення елементів списку\n"
"> які ми будемо перебирати у циклі. Якщо один з цих елементів\n"
"> містить пробіл, нам потрібно взяти його в\n"
"> лапки і зробити те ж саме зі змінною циклу.\n"
"> Припустимо, що наші файли даних мають імена:\n"
">\n"
"> ~~~\n"
"> red dragon.dat\n"
"> purple unicorn.dat\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:439
msgid ""
">\n"
"> To loop over these files, we would need to add double quotes like so:\n"
">\n"
"> ~~~\n"
"> $ for filename in \"red dragon.dat\" \"purple unicorn.dat\"\n"
"> > do\n"
"> >     head -n 100 \"$filename\" | tail -n 20\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> It is simpler to avoid using spaces (or other special characters) in filenames.\n"
">\n"
"> The files above don't exist, so if we run the above code, the `head` command will be unable\n"
"> to find them, however the error message returned will show the name of the files it is\n"
"> expecting:\n"
">\n"
"> ~~~\n"
"> head: cannot open ‘red dragon.dat’ for reading: No such file or directory\n"
"> head: cannot open ‘purple unicorn.dat’ for reading: No such file or directory\n"
"> ~~~"
msgstr ""
">\n"
"> Щоб виконати цикл над цими файлами, нам потрібно додати подвійні лапки, ось так:\n"
">\n"
"> ~~~\n"
"> $ for filename in \"red dragon.dat\" \"purple unicorn.dat\"\n"
"> > do\n"
"> >     head -n 100 \"$filename\" | tail -n 20\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Простіше уникати використання пробілів (або інших спеціальних символів) у назвах файлів.\n"
">\n"
"> Вищевказані файли не існують, тому якщо ми виконаємо вищенаведений код, команда `head` не зможе\n"
"> знайти їх, однак у повідомленні про помилку буде показано назви цих файлів,\n"
"> що очікувалися:\n"
">\n"
"> ~~~\n"
"> head: cannot open ‘red dragon.dat’ for reading: No such file or directory\n"
"> head: cannot open ‘purple unicorn.dat’ for reading: No such file or directory\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:461
msgid ""
">\n"
"> Try removing the quotes around `$filename` in the loop above to see the effect of the quote\n"
"> marks on spaces. Note that we get a result from the loop command for unicorn.dat\n"
"> when we run this code in the `creatures` directory:\n"
">\n"
"> ~~~\n"
"> head: cannot open ‘red’ for reading: No such file or directory\n"
"> head: cannot open ‘dragon.dat’ for reading: No such file or directory\n"
"> head: cannot open ‘purple’ for reading: No such file or directory\n"
"> CGGTACCGAA\n"
"> AAGGGTCGCG\n"
"> CAAGTGTTCC\n"
"> ...\n"
"> ~~~"
msgstr ""
">\n"
"> Спробуйте видалити лапки навколо `$filename` у наведеному вище циклі, щоб побачити ефект лапок\n"
"> позначки на пробілах. Зверніть увагу, що ми отримуємо результат команди циклу для unicorn.dat\n"
"> коли ми запускаємо цей код у каталозі `creatures`:\n"
">\n"
"> ~~~\n"
"> head: cannot open ‘red’ for reading: No such file or directory\n"
"> head: cannot open ‘dragon.dat’ for reading: No such file or directory\n"
"> head: cannot open ‘purple’ for reading: No such file or directory\n"
"> CGGTACCGAA\n"
"> AAGGGTCGCG\n"
"> CAAGTGTTCC\n"
"> ...\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:478
msgid ""
"We would like to modify each of the files in `shell-lesson-data/exercise-data/creatures`,\n"
"but also save a version\n"
"of the original files, naming the copies `original-basilisk.dat` and `original-unicorn.dat`.\n"
"We can't use:"
msgstr ""
"Ми б хотіли змінити кожен з файлів у `shell-lesson-data/exercise-data/creatures`,\n"
"але також зберегти версію\n"
"оригінальних файлів, назвавши копії `original-basilisk.dat` і `original-unicorn.dat`.\n"
"Ми не можемо використовувати:"

# code block
#: shell-novice/_episodes/05-loop.md:483
msgid ""
"~~~\n"
"$ cp *.dat original-*.dat\n"
"~~~"
msgstr ""
"~~~\n"
"$ cp *.dat original-*.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:488
msgid "because that would expand to:"
msgstr "тому що це буде розширено до:"

# code block
#: shell-novice/_episodes/05-loop.md:490
msgid ""
"~~~\n"
"$ cp basilisk.dat minotaur.dat unicorn.dat original-*.dat\n"
"~~~"
msgstr ""
"~~~\n"
"$ cp basilisk.dat minotaur.dat unicorn.dat original-*.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:495
msgid "This wouldn't back up our files, instead we get an error:"
msgstr ""
"Це не створить резервну копію наших файлів, натомість ми отримаємо помилку:"

# code block
#: shell-novice/_episodes/05-loop.md:497
msgid ""
"~~~\n"
"cp: target `original-*.dat' is not a directory\n"
"~~~"
msgstr ""
"~~~\n"
"cp: target `original-*.dat' is not a directory\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:502
msgid ""
"This problem arises when `cp` receives more than two inputs. When this happens, it\n"
"expects the last input to be a directory where it can copy all the files it was passed.\n"
"Since there is no directory named `original-*.dat` in the `creatures` directory we get an\n"
"error."
msgstr ""
"Ця проблема виникає, коли команда `cp` отримує більше двох входів. Коли це відбувається, вона\n"
"очікує, що останнім вхідним параметром буде каталог, куди вона зможе скопіювати всі файли, які їй було передано.\n"
"Оскільки у каталозі `creatures` немає каталогу з назвою `original-*.dat`, ми отримаємо\n"
"помилку."

#: shell-novice/_episodes/05-loop.md:507
msgid ""
"Instead, we can use a loop:\n"
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     cp $filename original-$filename\n"
"> done\n"
"~~~\n"
"{: .language-bash}"
msgstr ""
"Замість цього ми можемо використати цикл:\n"
"~~~\n"
"$ for filename in *.dat\n"
"> do\n"
">     cp $filename original-$filename\n"
"> done\n"
"~~~\n"
"{: .language-bash}"

#: shell-novice/_episodes/05-loop.md:516
msgid ""
"This loop runs the `cp` command once for each filename.\n"
"The first time,\n"
"when `$filename` expands to `basilisk.dat`,\n"
"the shell executes:"
msgstr ""
"Цей цикл виконує команду `cp` один раз для кожного імені файлу.\n"
"Перший раз,\n"
"коли змінна `$filename` має значення до `basilisk.dat`,\n"
"термінал виконає:"

# code block
#: shell-novice/_episodes/05-loop.md:521
msgid ""
"~~~\n"
"cp basilisk.dat original-basilisk.dat\n"
"~~~"
msgstr ""
"~~~\n"
"cp basilisk.dat original-basilisk.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:526
msgid "The second time, the command is:"
msgstr "У другий раз команда наступна:"

# code block
#: shell-novice/_episodes/05-loop.md:528
msgid ""
"~~~\n"
"cp minotaur.dat original-minotaur.dat\n"
"~~~"
msgstr ""
"~~~\n"
"cp minotaur.dat original-minotaur.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:533
msgid "The third and last time, the command is:"
msgstr "В третій, останній раз, команда буде такою:"

# code block
#: shell-novice/_episodes/05-loop.md:535
msgid ""
"~~~\n"
"cp unicorn.dat original-unicorn.dat\n"
"~~~"
msgstr ""
"~~~\n"
"cp unicorn.dat original-unicorn.dat\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:540
msgid ""
"Since the `cp` command does not normally produce any output, it's hard to check\n"
"that the loop is doing the correct thing.\n"
"However, we learned earlier how to print strings using `echo`, and we can modify the loop\n"
"to use `echo` to print our commands without actually executing them.\n"
"As such we can check what commands *would be* run in the unmodified loop."
msgstr ""
"Оскільки команда `cp` зазвичай не виводить нічого, важко перевірити\n"
"що цикл працює правильно.\n"
"Однак раніше ми дізналися, як виводити рядки за допомогою `echo`, і ми можемо модифікувати цикл\n"
"щоб використовувати `echo` для виведення наших команд без їхнього виконання.\n"
"Таким чином, ми можемо перевірити, які команди виконувалися *би* у немодифікованому циклі."

#: shell-novice/_episodes/05-loop.md:546
msgid ""
"The following diagram\n"
"shows what happens when the modified loop is executed, and demonstrates how the\n"
"judicious use of `echo` is a good debugging technique."
msgstr ""
"Наступна діаграма\n"
"показує, що відбувається при виконанні модифікованого циклу, і демонструє, як\n"
"розумне використання `echo` є гарною технікою зневадження."

#: shell-novice/_episodes/05-loop.md:550
msgid ""
"![The for loop \"for filename in *.dat; do echo cp $filename original-$filename;\n"
"done\" will successively assign the names of all \"*.dat\" files in your current\n"
"directory to the variable \"$filename\" and then execute the command. With the\n"
"files \"basilisk.dat\", \"minotaur.dat\" and \"unicorn.dat\" in the current directory\n"
"the loop will successively call the echo command three times and print three\n"
"lines: \"cp basislisk.dat original-basilisk.dat\", then \"cp minotaur.dat\n"
"original-minotaur.dat\" and finally \"cp unicorn.dat\n"
"original-unicorn.dat\"](../fig/shell_script_for_loop_flow_chart.svg)"
msgstr ""
"![Цикл for \"for filename in *.dat; do echo cp $filename original-$filename;\n"
"done\" послідовно присвоїть змінній \"$filename\" імена всіх \"*.dat\" файлів у вашому поточному\n"
"каталозі змінній \"$filename\" та після цього виконає команду. Для\n"
"файлів \"basilisk.dat\", \"minotaur.dat\" та \"unicorn.dat\" в поточному каталозі\n"
"цикл тричі послідовно викличе команду echo і виведе три\n"
"рядки: \"cp basislisk.dat original-basilisk.dat\", потім \"cp minotaur.dat\n"
"original-minotaur.dat\" та нарешті \"cp unicorn.dat\n"
"original-unicorn.dat\"](../fig/shell_script_for_loop_flow_chart.svg)"

# header
#: shell-novice/_episodes/05-loop.md:559
msgid "## Nelle's Pipeline: Processing Files"
msgstr "## Конвеєр Неллі: Обробка файлів"

#: shell-novice/_episodes/05-loop.md:561
msgid ""
"Nelle is now ready to process her data files using `goostats.sh` ---\n"
"a shell script written by her supervisor.\n"
"This calculates some statistics from a protein sample file, and takes two arguments:"
msgstr ""
"Тепер Неллі готова обробити свої файли даних за допомогою `goostats.sh` ---\n"
"скрипта терміналу, написаного її керівником.\n"
"Він обчислює деякі статистичні дані з файлу зразка білка і приймає два аргументи:"

# ordered list
#: shell-novice/_episodes/05-loop.md:565
msgid "1. an input file (containing the raw data)"
msgstr "1. вхідний файл (що містить вихідні дані)"

# ordered list
#: shell-novice/_episodes/05-loop.md:566
msgid "2. an output file (to store the calculated statistics)"
msgstr "2. вихідний файл (для збереження розрахованої статистики)"

#: shell-novice/_episodes/05-loop.md:568
msgid ""
"Since she's still learning how to use the shell,\n"
"she decides to build up the required commands in stages.\n"
"Her first step is to make sure that she can select the right input files --- remember,\n"
"these are ones whose names end in 'A' or 'B', rather than 'Z'.\n"
"Starting from her home directory, Nelle types:"
msgstr ""
"Оскільки вона все ще вчиться користуватися терміналом,\n"
"вона вирішує створювати необхідні команди поетапно.\n"
"Першим кроком буде переконатися, що вона може вибирати правильні вхідні файли - запам'ятайте,\n"
"це ті, назви яких закінчуються на 'A' або 'B', а не на 'Z'.\n"
"Починаючи з домашнього каталогу, Неллі набирає:"

# code block
#: shell-novice/_episodes/05-loop.md:574
msgid ""
"~~~\n"
"$ cd north-pacific-gyre\n"
"$ for datafile in NENE*A.txt NENE*B.txt\n"
"> do\n"
">     echo $datafile\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd north-pacific-gyre\n"
"$ for datafile in NENE*A.txt NENE*B.txt\n"
"> do\n"
">     echo $datafile\n"
"> done\n"
"~~~"

# code block
#: shell-novice/_episodes/05-loop.md:583
msgid ""
"~~~\n"
"NENE01729A.txt\n"
"NENE01729B.txt\n"
"NENE01736A.txt\n"
"...\n"
"NENE02043A.txt\n"
"NENE02043B.txt\n"
"~~~"
msgstr ""
"~~~\n"
"NENE01729A.txt\n"
"NENE01729B.txt\n"
"NENE01736A.txt\n"
"...\n"
"NENE02043A.txt\n"
"NENE02043B.txt\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:593
msgid ""
"Her next step is to decide\n"
"what to call the files that the `goostats.sh` analysis program will create.\n"
"Prefixing each input file's name with 'stats' seems simple,\n"
"so she modifies her loop to do that:"
msgstr ""
"Наступним кроком буде вирішити\n"
"як назвати файли, які створить програма аналізу `goostats.sh`.\n"
"Додавання до імені кожного вхідного файлу префікса \"stats\" здається простим,\n"
"тому вона модифікує свій цикл для цього:"

# code block
#: shell-novice/_episodes/05-loop.md:598
msgid ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt\n"
"> do\n"
">     echo $datafile stats-$datafile\n"
"> done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt\n"
"> do\n"
">     echo $datafile stats-$datafile\n"
"> done\n"
"~~~"

# code block
#: shell-novice/_episodes/05-loop.md:606
msgid ""
"~~~\n"
"NENE01729A.txt stats-NENE01729A.txt\n"
"NENE01729B.txt stats-NENE01729B.txt\n"
"NENE01736A.txt stats-NENE01736A.txt\n"
"...\n"
"NENE02043A.txt stats-NENE02043A.txt\n"
"NENE02043B.txt stats-NENE02043B.txt\n"
"~~~"
msgstr ""
"~~~\n"
"NENE01729A.txt stats-NENE01729A.txt\n"
"NENE01729B.txt stats-NENE01729B.txt\n"
"NENE01736A.txt stats-NENE01736A.txt\n"
"...\n"
"NENE02043A.txt stats-NENE02043A.txt\n"
"NENE02043B.txt stats-NENE02043B.txt\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:616
msgid ""
"She hasn't actually run `goostats.sh` yet,\n"
"but now she's sure she can select the right files and generate the right output filenames."
msgstr ""
"Насправді, вона ще не запускала `goostats.sh`,\n"
"але тепер вона впевнена, що може вибрати правильні файли і згенерувати правильні назви вихідних файлів."

#: shell-novice/_episodes/05-loop.md:619
msgid ""
"Typing in commands over and over again is becoming tedious,\n"
"though,\n"
"and Nelle is worried about making mistakes,\n"
"so instead of re-entering her loop,\n"
"she presses <kbd>↑</kbd>.\n"
"In response,\n"
"the shell redisplays the whole loop on one line\n"
"(using semi-colons to separate the pieces):"
msgstr ""
"Введення команд знову і знову стає нудним,\n"
"і Неллі хвилюється через можливі помилки,\n"
"тож замість того, щоб перенабирати свій цикл,\n"
"вона натискає <kbd>↑</kbd>.\n"
"У відповідь\n"
"оболонка відобразить весь цикл в одному рядку\n"
"(використовуючи крапку з комою для розділення частин):"

# code block
#: shell-novice/_episodes/05-loop.md:628
msgid ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:633
msgid ""
"Using the left arrow key,\n"
"Nelle backs up and changes the command `echo` to `bash goostats.sh`:"
msgstr ""
"За допомогою клавіші зі стрілкою ліворуч,\n"
"Неллі створює резервну копію і змінює команду `echo` на `bash goostats.sh`:"

# code block
#: shell-novice/_episodes/05-loop.md:636
msgid ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:641
msgid ""
"When she presses <kbd>Enter</kbd>,\n"
"the shell runs the modified command.\n"
"However, nothing appears to happen --- there is no output.\n"
"After a moment, Nelle realizes that since her script doesn't print anything to the screen\n"
"any longer, she has no idea whether it is running, much less how quickly.\n"
"She kills the running command by typing <kbd>Ctrl</kbd>+<kbd>C</kbd>,\n"
"uses <kbd>↑</kbd> to repeat the command,\n"
"and edits it to read:"
msgstr ""
"Коли вона натискає <kbd>Enter</kbd>,\n"
"термінал виконає змінену команду.\n"
"Однак, здається, нічого не відбувається - немає ніякого виводу.\n"
"За мить Неллі розуміє, що оскільки її скрипт більше нічого не виводить на екран,\n"
"вона не має жодного уявлення про те, чи виконується він, а тим паче, як швидко.\n"
"Вона перериває команду виконання, набравши <kbd>Ctrl</kbd>+<kbd>C</kbd>,\n"
"використовує <kbd>↑</kbd> для повтору команди,\n"
"і редагує її, щоб читати:"

# code block
#: shell-novice/_episodes/05-loop.md:650
msgid ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile;\n"
"bash goostats.sh $datafile stats-$datafile; done\n"
"~~~"
msgstr ""
"~~~\n"
"$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile;\n"
"bash goostats.sh $datafile stats-$datafile; done\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:656
msgid "> ## Beginning and End"
msgstr "> ## Початок і кінець"

#: shell-novice/_episodes/05-loop.md:657
msgid ""
">\n"
"> We can move to the beginning of a line in the shell by typing <kbd>Ctrl</kbd>+<kbd>A</kbd>\n"
"> and to the end using <kbd>Ctrl</kbd>+<kbd>E</kbd>."
msgstr ""
">\n"
"> Перехід на початок рядка в оболонці здійснюється за допомогою комбінації клавіш <kbd>Ctrl</kbd>+<kbd>A</kbd>\n"
"> і в кінець рядка - за допомогою <kbd>Ctrl</kbd>+<kbd>E</kbd>."

#: shell-novice/_episodes/05-loop.md:662
msgid ""
"When she runs her program now,\n"
"it produces one line of output every five seconds or so:"
msgstr ""
"Коли вона запускає свою програму зараз,\n"
"програма виводить один рядок кожні п'ять секунд або близько того:"

# code block
#: shell-novice/_episodes/05-loop.md:665
msgid ""
"~~~\n"
"NENE01729A.txt\n"
"NENE01729B.txt\n"
"NENE01736A.txt\n"
"...\n"
"~~~"
msgstr ""
"~~~\n"
"NENE01729A.txt\n"
"NENE01729B.txt\n"
"NENE01736A.txt\n"
"...\n"
"~~~"

#: shell-novice/_episodes/05-loop.md:673
msgid ""
"1518 times 5 seconds,\n"
"divided by 60,\n"
"tells her that her script will take about two hours to run.\n"
"As a final check,\n"
"she opens another terminal window,\n"
"goes into `north-pacific-gyre`,\n"
"and uses `cat stats-NENE01729B.txt`\n"
"to examine one of the output files.\n"
"It looks good,\n"
"so she decides to get some coffee and catch up on her reading."
msgstr ""
"Значення 1518, помножене на 5 секунд,\n"
"поділене на 60,\n"
"каже їй, що її сценарій буде виконуватися близько двох годин.\n"
"Для остаточної перевірки\n"
"вона відкриває інше вікно терміналу,\n"
"переходить в `north-pacific-gyre`,\n"
"і використовує `cat stats-NENE01729B.txt`.\n"
"для перевірки одного з вихідних файлів.\n"
"Виглядає добре,\n"
"тож вона вирішує випити кави і продовжити читання."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:684
msgid "> ## Those Who Know History Can Choose to Repeat It"
msgstr "> ## Хто знає історію, той може її повторити"

#: shell-novice/_episodes/05-loop.md:685
msgid ""
">\n"
"> Another way to repeat previous work is to use the `history` command to\n"
"> get a list of the last few hundred commands that have been executed, and\n"
"> then to use `!123` (where '123' is replaced by the command number) to\n"
"> repeat one of those commands. For example, if Nelle types this:\n"
">\n"
"> ~~~\n"
"> $ history | tail -n 5\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
">   456  ls -l NENE0*.txt\n"
">   457  rm stats-NENE01729B.txt.txt\n"
">   458  bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n"
">   459  ls -l NENE0*.txt\n"
">   460  history\n"
"> ~~~"
msgstr ""
">\n"
"> Інший спосіб повторити попередню роботу - скористатися командою `history`, щоб\n"
"> отримати список останніх кількох сотень команд, які було виконано, і\n"
"> потім скористатися командою `!123` (де \"123\" замінено на номер команди), щоб\n"
"> повторити одну з цих команд. Наприклад, якщо Неллі набере наступне:\n"
">\n"
"> ~~~\n"
"> $ history | tail -n 5\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
">   456  ls -l NENE0*.txt\n"
">   457  rm stats-NENE01729B.txt.txt\n"
">   458  bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n"
">   459  ls -l NENE0*.txt\n"
">   460  history\n"
"> ~~~"

#: shell-novice/_episodes/05-loop.md:703
msgid ""
">\n"
"> then she can re-run `goostats.sh` on `NENE01729B.txt` simply by typing\n"
"> `!458`."
msgstr ""
">\n"
"> тоді вона може перезапустити `goostats.sh` на `NENE01729B.txt`, просто набравши\n"
"> `!458`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:708
msgid "> ## Other History Commands"
msgstr "> ## Інші команди історії"

#: shell-novice/_episodes/05-loop.md:709
msgid ""
">\n"
"> There are a number of other shortcut commands for getting at the history.\n"
">\n"
"> - <kbd>Ctrl</kbd>+<kbd>R</kbd> enters a history search mode 'reverse-i-search' and finds the\n"
"> most recent command in your history that matches the text you enter next.\n"
"> Press <kbd>Ctrl</kbd>+<kbd>R</kbd> one or more additional times to search for earlier matches.\n"
"> You can then use the left and right arrow keys to choose that line and edit\n"
"> it then hit <kbd>Return</kbd> to run the command.\n"
"> - `!!` retrieves the immediately preceding command\n"
"> (you may or may not find this more convenient than using <kbd>↑</kbd>)\n"
"> - `!$` retrieves the last word of the last command.\n"
"> That's useful more often than you might expect: after\n"
"> `bash goostats.sh NENE01729B.txt stats-NENE01729B.txt`, you can type\n"
"> `less !$` to look at the file `stats-NENE01729B.txt`, which is\n"
"> quicker than doing <kbd>↑</kbd> and editing the command-line."
msgstr ""
">\n"
"> Існує ряд інших команд швидкого доступу до історії.\n"
">\n"
"> - <kbd>Ctrl</kbd>+<kbd>R</kbd> переходить у режим \"зворотного пошуку\" в історіїі і знаходить\n"
"> останню команду у вашому журналі, яка відповідає тексту, що ви введете далі.\n"
"> Натисніть<kbd>Ctrl</kbd>+<kbd>R</kbd> ще один або кілька додаткових разів для пошуку більш ранніх збігів.\n"
"> За допомогою клавіш зі стрілками вліво і вправо виберіть цей рядок і відредагуйте\n"
"> його, потім натисніть <kbd>Return</kbd> щоб виконати команду.\n"
"> - `!!` повертає безпосередньо попередню команду\n"
"> (ви можете знайти це більш зручним, ніж використання <kbd>↑</kbd>)\n"
"> - `!$` повертає останнє слово останньої команди.\n"
"> Це корисно частіше, ніж ви можете собі уявити: після\n"
"> `bash goostats.sh NENE01729B.txt stats-NENE01729B.txt`, ви можете ввести\n"
"> `less !$` для перегляду файлу `stats-NENE01729B.txt`, що\n"
"> швидше, ніж набирати <kbd>↑</kbd> і редагувати командний рядок."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:726
msgid "> ## Doing a Dry Run"
msgstr "> ## Виконання пробного запуску"

#: shell-novice/_episodes/05-loop.md:727
msgid ""
">\n"
"> A loop is a way to do many things at once --- or to make many mistakes at\n"
"> once if it does the wrong thing. One way to check what a loop *would* do\n"
"> is to `echo` the commands it would run instead of actually running them.\n"
">\n"
"> Suppose we want to preview the commands the following loop will execute\n"
"> without actually running those commands:\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     cat $datafile >> all.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> What is the difference between the two loops below, and which one would we\n"
"> want to run?\n"
">\n"
"> ~~~\n"
"> # Version 1\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     echo cat $datafile >> all.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> # Version 2\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     echo \"cat $datafile >> all.pdb\"\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Solution\n"
"> > The second version is the one we want to run.\n"
"> > This prints to screen everything enclosed in the quote marks, expanding the\n"
"> > loop variable name because we have prefixed it with a dollar sign.\n"
"> > It also *does not* modify nor create the file `all.pdb`, as the `>>`\n"
"> > is treated literally as part of a string rather than as a\n"
"> > redirection instruction.\n"
"> >\n"
"> > The first version appends the output from the command `echo cat $datafile`\n"
"> > to the file, `all.pdb`. This file will just contain the list;\n"
"> > `cat cubane.pdb`, `cat ethane.pdb`, `cat methane.pdb` etc.\n"
"> >\n"
"> > Try both versions for yourself to see the output! Be sure to open the\n"
"> > `all.pdb` file to view its contents."
msgstr ""
">\n"
"> Цикл - це спосіб зробити багато речей одночасно --- або зробити багато помилок\n"
"> одночасно, якщо він робить неправильні речі. Один зі способів перевірити, що *робив би* цикл\n"
"> це за допомогою `echo` виводити команди, які він виконуватиме, замість того, щоб виконувати їх насправді.\n"
">\n"
"> Припустимо, ми хочемо переглянути команди, які виконає наступний цикл\n"
"> без виконання цих команд:\n"
">\n"
"> ~~~\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     cat $datafile >> all.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> У чому різниця між двома наведеними нижче циклами, і який з них ми\n"
"> хочемо запустити?\n"
">\n"
"> ~~~\n"
"> # Варіант 1\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     echo cat $datafile >> all.pdb\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> ~~~\n"
"> # Варіант 2\n"
"> $ for datafile in *.pdb\n"
"> > do\n"
"> >     echo \"cat $datafile >> all.pdb\"\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Розв'язання\n"
"> > Друга версія - це та, яку ми хочемо запустити.\n"
"> > Вона виводить на екран усе, що укладено у лапки, розширюючи\n"
"> > назву змінної циклу, оскільки ми додали до неї знак долара.\n"
"> > Він також *не* змінює і не створює файл `all.pdb`, оскільки оператор `>>`\n"
"> > розглядається буквально як частина рядка, а не як\n"
"> > інструкція перенаправлення.\n"
"> >\n"
"> > Перша версія додає вивід команди `echo cat $datafile`\n"
"> > до файлу `all.pdb`. Цей файл міститиме лише список\n"
"> > `cat cubane.pdb`, `cat ethane.pdb`, `cat methane.pdb` тощо.\n"
"> >\n"
"> > Спробуйте обидві версії, щоб побачити результат! Обов'язково відкрийте\n"
"> > файл `all.pdb`, щоб переглянути його вміст."

# blockquote, which can be cascaded
#: shell-novice/_episodes/05-loop.md:781
msgid "> ## Nested Loops"
msgstr "> ## Вкладені цикли"

#: shell-novice/_episodes/05-loop.md:782
msgid ""
">\n"
"> Suppose we want to set up a directory structure to organize\n"
"> some experiments measuring reaction rate constants with different compounds\n"
"> *and* different temperatures.  What would be the\n"
"> result of the following code:\n"
">\n"
"> ~~~\n"
"> $ for species in cubane ethane methane\n"
"> > do\n"
"> >     for temperature in 25 30 37 40\n"
"> >     do\n"
"> >         mkdir $species-$temperature\n"
"> >     done\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Solution\n"
"> > We have a nested loop, i.e. contained within another loop, so for each species\n"
"> > in the outer loop, the inner loop (the nested loop) iterates over the list of\n"
"> > temperatures, and creates a new directory for each combination.\n"
"> >\n"
"> > Try running the code for yourself to see which directories are created!"
msgstr ""
">\n"
"> Припустімо, що ми хочемо створити структуру каталогів для організації\n"
"> певних експериментів з вимірювання констант швидкості реакції з різними сполуками\n"
"> *та* різними температурами. Яким буде\n"
"> результат виконання наступного коду:\n"
">\n"
"> ~~~\n"
"> $ for species in cubane ethane methane\n"
"> > do\n"
"> >     for temperature in 25 30 37 40\n"
"> >     do\n"
"> >         mkdir $species-$temperature\n"
"> >     done\n"
"> > done\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> > ## Розв'язання\n"
"> > Ми маємо вкладений цикл, тобто такий, що міститься в іншому циклі, тому для кожного значення змінної species\n"
"> > у зовнішньому циклі внутрішній цикл (вкладений цикл) перебирає список\n"
"> > температур і створює новий каталог для кожної комбінації.\n"
"> >\n"
"> > Спробуйте запустити код самостійно, щоб побачити, які каталоги буде створено!"
