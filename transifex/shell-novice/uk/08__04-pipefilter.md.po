# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Oleksandr Miroshkin <miroshkinan@gmail.com>, 2023
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2023-02-12 19:32:08+0000\n"
"PO-Revision-Date: 2023-02-12 19:38+0000\n"
"Last-Translator: Oleksandr Miroshkin <miroshkinan@gmail.com>, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/carpentries-i18n/teams/98915/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

# Front Matter
#: shell-novice/_episodes/04-pipefilter.md:1
msgid ""
"---\n"
"title: \"Pipes and Filters\"\n"
"teaching: 25\n"
"exercises: 10\n"
"questions:\n"
"- \"How can I combine existing commands to do new things?\"\n"
"objectives:\n"
"- \"Redirect a command's output to a file.\"\n"
"- \"Construct command pipelines with two or more stages.\"\n"
"- \"Explain what usually happens if a program or pipeline isn't given any input to process.\"\n"
"- \"Explain the advantage of linking commands with pipes and filters.\"\n"
"keypoints:\n"
"- \"`wc` counts lines, words, and characters in its inputs.\"\n"
"- \"`cat` displays the contents of its inputs.\"\n"
"- \"`sort` sorts its inputs.\"\n"
"- \"`head` displays the first 10 lines of its input.\"\n"
"- \"`tail` displays the last 10 lines of its input.\"\n"
"- \"`command > [file]` redirects a command's output to a file (overwriting any existing content).\"\n"
"- \"`command >> [file]` appends a command's output to a file.\"\n"
"- \"`[first] | [second]` is a pipeline: the output of the first command is used as the input to the second.\"\n"
"- \"The best way to use the shell is to use pipes to combine simple single-purpose programs (filters).\"\n"
"---"
msgstr ""
"---\n"
"title: \"Канали та фільтри\"\n"
"teaching: 25\n"
"exercises: 10\n"
"questions:\n"
"- \"Як я можу комбінувати команди, що вже існують, щоб робити нові речі?\"\n"
"objectives:\n"
"- \"Перенаправити вивід команди до файлу.\"\n"
"- \"Створити конвеєри команд з двома та більше ступенями.\"\n"
"- \"Пояснити, що зазвичай відбувається, якщо програмі або конвеєру не надається жодних вхідних даних для обробки.\"\n"
"- \"Пояснити перевагу поєднання команд з каналами та фільтрами.\"\n"
"keypoints:\n"
"- \"`wc` підраховує рядки, слова та символи у вхідних даних.\"\n"
"- \"cat` виводить вміст своїх вхідних даних.\"\n"
"- \"`sort` сортує вхідні дані.\"\n"
"- \"`head` виводить перші 10 рядків вхідних даних.\"\n"
"- \"`tail` виводить останні 10 рядків вхідних даних.\"\n"
"- \"`command > [file]` перенаправляє вивід команди у файл (перезаписуючи наявний вміст).\"\n"
"- \"`command >> [file]` додає вивід команди до файлу.\"\n"
"- \"`[first] | [second]` є конвеєром: вихід першої команди використовується як вхід для другої.\"\n"
"- \"Найкращий спосіб використання терміналу - це використання каналів для об'єднання простих одноцільових програм (фільтрів).\"\n"
"---"

#: shell-novice/_episodes/04-pipefilter.md:24
msgid ""
"Now that we know a few basic commands,\n"
"we can finally look at the shell's most powerful feature:\n"
"the ease with which it lets us combine existing programs in new ways.\n"
"We'll start with the directory `shell-lesson-data/exercise-data/proteins`\n"
"that contains six files describing some simple organic molecules.\n"
"The `.pdb` extension indicates that these files are in Protein Data Bank format,\n"
"a simple text format that specifies the type and position of each atom in the molecule."
msgstr ""
"Тепер, коли ми знаємо декілька основних команд,\n"
"ми можемо нарешті розглянути найпотужнішу можливість терміналу:\n"
"легкість, з якою він дозволяє нам комбінувати програми, що існують, новими способами.\n"
"Ми почнемо з каталогу `shell-lesson-data/exercise-data/proteins`,\n"
"який містить шість файлів, що описують деякі прості органічні молекули.\n"
"Розширення `.pdb` вказує на те, що ці файли у форматі Protein Data Bank,\n"
"простому текстовому форматі, який визначає тип і положення кожного атома в молекулі."

# code block
#: shell-novice/_episodes/04-pipefilter.md:37
msgid ""
"~~~\n"
"cubane.pdb    methane.pdb    pentane.pdb\n"
"ethane.pdb    octane.pdb     propane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"cubane.pdb    methane.pdb    pentane.pdb\n"
"ethane.pdb    octane.pdb     propane.pdb\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:43
msgid "Let's run an example command:"
msgstr "Запустимо приклад команди:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:45
msgid ""
"~~~\n"
"$ wc cubane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc cubane.pdb\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:50
msgid ""
"~~~\n"
"20  156 1158 cubane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"20  156 1158 cubane.pdb\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:55
msgid ""
"`wc` is the 'word count' command:\n"
"it counts the number of lines, words, and characters in files (from left to right, in that order)."
msgstr ""
"`wc` - команда 'порахуй слова' (англ. 'word count'):\n"
"вона підраховує кількість рядків, слів і символів у файлах (зліва направо, у такому порядку)."

#: shell-novice/_episodes/04-pipefilter.md:58
msgid ""
"If we run the command `wc *.pdb`, the `*` in `*.pdb` matches zero or more characters,\n"
"so the shell turns `*.pdb` into a list of all `.pdb` files in the current directory:"
msgstr ""
"Якщо ми виконаємо команду `wc *.pdb`, то `*` у `*.pdb` збігається з нулем або більшою кількістю символів,\n"
"тож термінал перетворить `*.pdb` на перелік усіх `.pdb`-файлів у поточному каталозі:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:61
msgid ""
"~~~\n"
"$ wc *.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc *.pdb\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:66
msgid ""
"~~~\n"
"  20  156  1158  cubane.pdb\n"
"  12  84   622   ethane.pdb\n"
"   9  57   422   methane.pdb\n"
"  30  246  1828  octane.pdb\n"
"  21  165  1226  pentane.pdb\n"
"  15  111  825   propane.pdb\n"
" 107  819  6081  total\n"
"~~~"
msgstr ""
"~~~\n"
"  20  156  1158  cubane.pdb\n"
"  12  84   622   ethane.pdb\n"
"   9  57   422   methane.pdb\n"
"  30  246  1828  octane.pdb\n"
"  21  165  1226  pentane.pdb\n"
"  15  111  825   propane.pdb\n"
" 107  819  6081  total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:77
msgid ""
"Note that `wc *.pdb` also shows the total number of all lines in the last "
"line of the output."
msgstr ""
"Зверніть увагу, що `wc *.pdb` також показує загальну кількість усіх рядків в"
" останньому рядку виводу."

#: shell-novice/_episodes/04-pipefilter.md:79
msgid ""
"If we run `wc -l` instead of just `wc`,\n"
"the output shows only the number of lines per file:"
msgstr ""
"Якщо ми виконаємо `wc -l` замість просто `wc`,\n"
"у виводі буде показано лише кількість рядків у файлі:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:82
msgid ""
"~~~\n"
"$ wc -l *.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.pdb\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:87
#: shell-novice/_episodes/04-pipefilter.md:166
msgid ""
"~~~\n"
"  20  cubane.pdb\n"
"  12  ethane.pdb\n"
"   9  methane.pdb\n"
"  30  octane.pdb\n"
"  21  pentane.pdb\n"
"  15  propane.pdb\n"
" 107  total\n"
"~~~"
msgstr ""
"~~~\n"
"  20  cubane.pdb\n"
"  12  ethane.pdb\n"
"   9  methane.pdb\n"
"  30  octane.pdb\n"
"  21  pentane.pdb\n"
"  15  propane.pdb\n"
" 107  total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:98
msgid ""
"The `-m` and `-w` options can also be used with the `wc` command, to show\n"
"only the number of characters or the number of words in the files."
msgstr ""
"Параметри `-m` і `-w` також можна використовувати з командою `wc`, щоб показати\n"
"тільки кількість символів або тільки кількість слів у файлах."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:101
msgid "> ## Why Isn't It Doing Anything?"
msgstr "> ## Чому воно нічого не робить?"

#: shell-novice/_episodes/04-pipefilter.md:102
msgid ""
">\n"
"> What happens if a command is supposed to process a file, but we\n"
"> don't give it a filename? For example, what if we type:\n"
">\n"
"> ~~~\n"
"> $ wc -l\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> but don't type `*.pdb` (or anything else) after the command?\n"
"> Since it doesn't have any filenames, `wc` assumes it is supposed to\n"
"> process input given at the command prompt, so it just sits there and waits for us to give\n"
"> it some data interactively. From the outside, though, all we see is it\n"
"> sitting there: the command doesn't appear to do anything.\n"
">\n"
"> If you make this kind of mistake, you can escape out of this state by holding down\n"
"> the control key (<kbd>Ctrl</kbd>) and typing the letter <kbd>C</kbd> once and\n"
"> letting go of the <kbd>Ctrl</kbd> key.\n"
"> <kbd>Ctrl</kbd>+<kbd>C</kbd>"
msgstr ""
">\n"
"> Що станеться, якщо команда має обробити файл, але ми\n"
"> не вкажемо імені файлу? Наприклад, що буде, якщо ми наберемо:\n"
">\n"
"> ~~~\n"
"> $ wc -l\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> але не будемо вводити `*.pdb` (або щось інше) після команди?\n"
"> Оскільки команда не має жодних назв файлів, `wc` вважає, що вона повинна\n"
"> обробляти дані, введені у командному рядку, тож вона просто сидить і чекає, поки ми надамо їй\n"
"> інтерактивно якісь дані. Ззовні, однак, все, що ми бачимо, це те, що вона,\n"
"> здається, нічого не робить.\n"
">\n"
"> Якщо ви припустилися такої помилки, ви можете вийти з цього стану, утримуючи\n"
"> клавішу control (<kbd>Ctrl</kbd>), один раз натиснувши клавішу <kbd>C</kbd>,\n"
"> відпустивши після цього клавішу <kbd>Ctrl</kbd>.\n"
"> <kbd>Ctrl</kbd>+<kbd>C</kbd>"

# header
#: shell-novice/_episodes/04-pipefilter.md:124
msgid "## Capturing output from commands"
msgstr "## Перехоплення виводу з команд"

#: shell-novice/_episodes/04-pipefilter.md:126
msgid ""
"Which of these files contains the fewest lines?\n"
"It's an easy question to answer when there are only six files,\n"
"but what if there were 6000?\n"
"Our first step toward a solution is to run the command:"
msgstr ""
"Який з цих файлів містить найменше рядків?\n"
"На це питання легко відповісти, коли файлів всього шість,\n"
"але що, якщо їх 6000?\n"
"Наш перший крок до пошуку рішеня - це запуск команди:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:131
msgid ""
"~~~\n"
"$ wc -l *.pdb > lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.pdb > lengths.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:136
msgid ""
"The greater than symbol, `>`, tells the shell to **redirect** the command's output\n"
"to a file instead of printing it to the screen. (This is why there is no screen output:\n"
"everything that `wc` would have printed has gone into the\n"
"file `lengths.txt` instead.)  The shell will create\n"
"the file if it doesn't exist. If the file exists, it will be\n"
"silently overwritten, which may lead to data loss and thus requires\n"
"some caution.\n"
"`ls lengths.txt` confirms that the file exists:"
msgstr ""
"Символ 'більше ніж', `>`, вказує терміналу **перенаправити** вивід команди\n"
"до файла замість виведення його на екран. (Саме тому виведення на екран не відбувається:\n"
"все, що мала вивести команда `wc`, було збережено у файлі\n"
"`lengths.txt` замість цього). Термінал створить\n"
"файл, якщо його не існує. Якщо файл існує, його буде\n"
"буде перезаписано без будь-яких повідомлень, що може призвести до втрати даних, а отже, вимагає\n"
"певної обережності.\n"
"Файл `ls lengths.txt` підтверджує, що файл існує:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:145
msgid ""
"~~~\n"
"$ ls lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls lengths.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:150
msgid ""
"~~~\n"
"lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"lengths.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:155
msgid ""
"We can now send the content of `lengths.txt` to the screen using `cat lengths.txt`.\n"
"The `cat` command gets its name from 'concatenate' i.e. join together,\n"
"and it prints the contents of files one after another.\n"
"There's only one file in this case,\n"
"so `cat` just shows us what it contains:"
msgstr ""
"Тепер ми можемо вивести вміст файлу `lengths.txt` на екран за допомогою команди `cat lengths.txt`.\n"
"Команда `cat` отримала свою назву від слова 'concatenate', тобто об'єднувати, \n"
"і вона виводить вміст файлів один за одним.\n"
"У цьому випадку є лише один файл,\n"
"тому `cat` просто відображає нам його вміст:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:161
msgid ""
"~~~\n"
"$ cat lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ cat lengths.txt\n"
"~~~"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:177
msgid "> ## Output Page by Page"
msgstr "> ## Виведення сторінка за сторінкою"

#: shell-novice/_episodes/04-pipefilter.md:178
msgid ""
">\n"
"> We'll continue to use `cat` in this lesson, for convenience and consistency,\n"
"> but it has the disadvantage that it always dumps the whole file onto your screen.\n"
"> More useful in practice is the command `less`,\n"
"> which you use with `less lengths.txt`.\n"
"> This displays a screenful of the file, and then stops.\n"
"> You can go forward one screenful by pressing the spacebar,\n"
"> or back one by pressing `b`.  Press `q` to quit."
msgstr ""
">\n"
"> У цьому уроці ми продовжимо використовувати команду `cat` для зручності та послідовності,\n"
"> але вона має той недолік, що завжди виводить весь файл на екран.\n"
"> Більш корисною на практиці є команда `less`,\n"
"> яку ви використовуєте за зразком `less lengths.txt`.\n"
"> Вона виводить один екран вмісту файлу, а потім зупиняється.\n"
"> Ви можете пересунутися на один екран вперед, натиснувши клавішу пробіл,\n"
"> або на один екран назад натисканням клавіші `b`. Щоб вийти, натисніть `q`."

# header
#: shell-novice/_episodes/04-pipefilter.md:189
msgid "## Filtering output"
msgstr "## Фільтрування виводу"

#: shell-novice/_episodes/04-pipefilter.md:191
msgid ""
"Next we'll use the `sort` command to sort the contents of the `lengths.txt` file.\n"
"But first we'll use an exercise to learn a little about the sort command:"
msgstr ""
"Далі ми скористаємося командою `sort` для сортування вмісту файлу `lengths.txt`.\n"
"Але спочатку ми виконаємо вправу, щоб дізнатися більше про команду sort:"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:194
msgid "> ## What Does `sort -n` Do?"
msgstr "> ## Що робить `sort -n`?"

#: shell-novice/_episodes/04-pipefilter.md:195
msgid ""
">\n"
"> The file `shell-lesson-data/exercise-data/numbers.txt` contains the following lines:\n"
">\n"
"> ~~~\n"
"> 10\n"
"> 2\n"
"> 19\n"
"> 22\n"
"> 6\n"
"> ~~~"
msgstr ""
">\n"
"> Файл `shell-lesson-data/exercise-data/numbers.txt` містить наступні рядки:\n"
">\n"
"> ~~~\n"
"> 10\n"
"> 2\n"
"> 19\n"
"> 22\n"
"> 6\n"
"> ~~~"

# SC/DC Template label
#: shell-novice/_episodes/04-pipefilter.md:205
#: shell-novice/_episodes/04-pipefilter.md:504
#: shell-novice/_episodes/05-loop.md:438
#: shell-novice/_episodes/06-script.md:304
#: shell-novice/_episodes/07-find.md:324 shell-novice/_episodes/07-find.md:336
msgid "> {: .source}"
msgstr "> {: .source}"

#: shell-novice/_episodes/04-pipefilter.md:206
msgid ""
">\n"
"> If we run `sort` on this file, the output is:\n"
">\n"
"> ~~~\n"
"> 10\n"
"> 19\n"
"> 2\n"
"> 22\n"
"> 6\n"
"> ~~~"
msgstr ""
">\n"
"> Якщо ми виконаємо команду `sort` для цього файлу, то отримаємо наступне:\n"
">\n"
"> ~~~\n"
"> 10\n"
"> 19\n"
"> 2\n"
"> 22\n"
"> 6\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:217
msgid ""
">\n"
"> If we run `sort -n` on the same file, we get this instead:\n"
">\n"
"> ~~~\n"
"> 2\n"
"> 6\n"
"> 10\n"
"> 19\n"
"> 22\n"
"> ~~~"
msgstr ""
">\n"
"> Якщо ми виконаємо команду `sort -n` для того ж файлу, то отримаємо наступне:\n"
">\n"
"> ~~~\n"
"> 2\n"
"> 6\n"
"> 10\n"
"> 19\n"
"> 22\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:228
msgid ""
">\n"
"> Explain why `-n` has this effect.\n"
">\n"
"> > ## Solution\n"
"> > The `-n` option specifies a numerical rather than an alphanumerical sort."
msgstr ""
">\n"
"> Поясніть, чому `-n` має такий ефект.\n"
">\n"
"> > ## Розв'язання\n"
"> > Опція `-n` задає числове, а не алфавітно-цифрове сортування."

#: shell-novice/_episodes/04-pipefilter.md:236
msgid ""
"We will also use the `-n` option to specify that the sort is\n"
"numerical instead of alphanumerical.\n"
"This does *not* change the file;\n"
"instead, it sends the sorted result to the screen:"
msgstr ""
"Ми також будемо використовувати опцію `-n`, щоб вказати, що сортування буде\n"
"числовим, а не алфавітно-цифровим.\n"
"Це *не* змінить файл;\n"
"натомість відсортований результат буде виведено на екран:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:241
msgid ""
"~~~\n"
"$ sort -n lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ sort -n lengths.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:246
msgid ""
"~~~\n"
"  9  methane.pdb\n"
" 12  ethane.pdb\n"
" 15  propane.pdb\n"
" 20  cubane.pdb\n"
" 21  pentane.pdb\n"
" 30  octane.pdb\n"
"107  total\n"
"~~~"
msgstr ""
"~~~\n"
"  9  methane.pdb\n"
" 12  ethane.pdb\n"
" 15  propane.pdb\n"
" 20  cubane.pdb\n"
" 21  pentane.pdb\n"
" 30  octane.pdb\n"
"107  total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:258
msgid ""
"We can put the sorted list of lines in another temporary file called `sorted-lengths.txt`\n"
"by putting `> sorted-lengths.txt` after the command,\n"
"just as we used `> lengths.txt` to put the output of `wc` into `lengths.txt`.\n"
"Once we've done that,\n"
"we can run another command called `head` to get the first few lines in `sorted-lengths.txt`:"
msgstr ""
"Ми можемо помістити відсортований список рядків в інший тимчасовий файл, який називається `sorted-lengths.txt`.\n"
"додавши `> sorted-lengths.txt` після команди,\n"
"так само, як ми використовували `> lengths.txt`, щоб помістити виведення `wc` у `lengths.txt`.\n"
"Після того, як ми це зробили,\n"
"ми можемо виконати іншу команду, що має назву `head`, щоб отримати перші кілька рядків у `sorted-lengths.txt`:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:264
msgid ""
"~~~\n"
"$ sort -n lengths.txt > sorted-lengths.txt\n"
"$ head -n 1 sorted-lengths.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ sort -n lengths.txt > sorted-lengths.txt\n"
"$ head -n 1 sorted-lengths.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:270
#: shell-novice/_episodes/04-pipefilter.md:384
msgid ""
"~~~\n"
"  9  methane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"  9  methane.pdb\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:275
msgid ""
"Using `-n 1` with `head` tells it that\n"
"we only want the first line of the file;\n"
"`-n 20` would get the first 20,\n"
"and so on.\n"
"Since `sorted-lengths.txt` contains the lengths of our files ordered from least to greatest,\n"
"the output of `head` must be the file with the fewest lines."
msgstr ""
"Використання `-n 1` з `head` говорить команді, що\n"
"нам потрібен лише перший рядок файлу;\n"
"`-n 20` отримає перші 20,\n"
"і так далі.\n"
"Оскільки файл `sorted-lengths.txt` містить довжини наших файлів, впорядковані від найменшої до найбільшої,\n"
"виведенням `head` має бути файл з найменшою кількістю рядків."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:282
msgid "> ## Redirecting to the same file"
msgstr "> ## Перенаправлення у той самий файл"

#: shell-novice/_episodes/04-pipefilter.md:283
msgid ""
">\n"
"> It's a very bad idea to try redirecting\n"
"> the output of a command that operates on a file\n"
"> to the same file. For example:\n"
">\n"
"> ~~~\n"
"> $ sort -n lengths.txt > lengths.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Doing something like this may give you\n"
"> incorrect results and/or delete\n"
"> the contents of `lengths.txt`."
msgstr ""
">\n"
"> Це дуже погана ідея - намагатися перенаправити\n"
"> вихідні дані команди, яка оперує з файлом,\n"
"> у той самий файл. Наприклад:\n"
">\n"
"> ~~~\n"
"> $ sort -n lengths.txt > lengths.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Виконання таких дій може надати вам\n"
"> некоректні результати та/або видалити\n"
"> вміст файлу `lengths.txt`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:298
msgid "> ## What Does `>>` Mean?"
msgstr "> ## Що означає `>>`?"

#: shell-novice/_episodes/04-pipefilter.md:299
msgid ""
">\n"
"> We have seen the use of `>`, but there is a similar operator `>>`\n"
"> which works slightly differently.\n"
"> We'll learn about the differences between these two operators by printing some strings.\n"
"> We can use the `echo` command to print strings e.g.\n"
">\n"
"> ~~~\n"
"> $ echo The echo command prints text\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> The echo command prints text\n"
"> ~~~"
msgstr ""
">\n"
"> Ми бачили використання оператору `>`, але існує схожий оператор `>>`,\n"
"> який працює дещо по-іншому.\n"
"> Ми дізнаємося про відмінності між цими двома операторами, надрукувавши кілька рядків.\n"
"> Ми можемо скористатися командою `echo` для виведення рядків, наприклад\n"
">\n"
"> ~~~\n"
"> $ echo Команда echo виводить текст\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> ~~~\n"
"> Команда echo виводить текст\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:313
msgid ""
">\n"
"> Now test the commands below to reveal the difference between the two operators:\n"
">\n"
"> ~~~\n"
"> $ echo hello > testfile01.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> and:\n"
">\n"
"> ~~~\n"
"> $ echo hello >> testfile02.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Hint: Try executing each command twice in a row and then examining the output files.\n"
">\n"
"> > ## Solution\n"
"> > In the first example with `>`, the string 'hello' is written to `testfile01.txt`,\n"
"> > but the file gets overwritten each time we run the command.\n"
"> >\n"
"> > We see from the second example that the `>>` operator also writes 'hello' to a file\n"
"> > (in this case`testfile02.txt`),\n"
"> > but appends the string to the file if it already exists\n"
"> > (i.e. when we run it for the second time)."
msgstr ""
">\n"
"> Тепер протестуйте наведені нижче команди, щоб виявити різницю між цими двома операторами:\n"
">\n"
"> ~~~\n"
"> $ echo hello > testfile01.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> та:\n"
">\n"
"> ~~~\n"
"> $ echo hello >> testfile02.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Підказка: Спробуйте виконати кожну команду двічі поспіль, а потім переглянути вихідні файли.\n"
">\n"
"> > ## Розв'язання\n"
"> > У першому прикладі з `>` рядок 'hello' записується до файлу `testfile01.txt`,\n"
"> > але файл перезаписується кожного разу, коли ми запускаємо команду.\n"
"> >\n"
"> > З другого прикладу ми бачимо, що оператор `>>` також записує рядок 'hello' у файл\n"
"> > (у цьому випадку `testfile02.txt`),\n"
"> > але додає рядок до файлу, якщо останній вже існує\n"
"> > (тобто, коли ми запускаємо його вдруге)."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:341
msgid "> ## Appending Data"
msgstr "> ## Додавання даних"

#: shell-novice/_episodes/04-pipefilter.md:342
msgid ""
">\n"
"> We have already met the `head` command, which prints lines from the start of a file.\n"
"> `tail` is similar, but prints lines from the end of a file instead.\n"
">\n"
"> Consider the file `shell-lesson-data/exercise-data/animal-counts/animals.csv`.\n"
"> After these commands, select the answer that\n"
"> corresponds to the file `animals-subset.csv`:\n"
">\n"
"> ~~~\n"
"> $ head -n 3 animals.csv > animals-subset.csv\n"
"> $ tail -n 2 animals.csv >> animals-subset.csv\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. The first three lines of `animals.csv`\n"
"> 2. The last two lines of `animals.csv`\n"
"> 3. The first three lines and the last two lines of `animals.csv`\n"
"> 4. The second and third lines of `animals.csv`\n"
">\n"
"> > ## Solution\n"
"> > Option 3 is correct.\n"
"> > For option 1 to be correct we would only run the `head` command.\n"
"> > For option 2 to be correct we would only run the `tail` command.\n"
"> > For option 4 to be correct we would have to pipe the output of `head` into `tail -n 2`\n"
"> >  by doing `head -n 3 animals.csv | tail -n 2 > animals-subset.csv`"
msgstr ""
">\n"
"> Ми вже зустрічалися з командою `head`, яка друкує рядки з початку файлу.\n"
"> Команда `tail` схожа на неї, але друкує рядки з кінця файлу.\n"
">\n"
"> Розглянемо файл `shell-lesson-data/exercise-data/animal-counts/animals.csv`.\n"
"> Після виконання цих команд виберіть відповідь, яка\n"
"> відповідає файлу `animals-subset.csv`:\n"
">\n"
"> ~~~\n"
"> $ head -n 3 animals.csv > animals-subset.csv\n"
"> $ tail -n 2 animals.csv >> animals-subset.csv\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> 1. Перші три рядки файлу `animals.csv'\n"
"> 2. Останні два рядки файлу `animals.csv`.\n"
"> 3. Перші три рядки та останні два рядки файлу `animals.csv`.\n"
"> 4. Другий і третій рядки файлу `animals.csv`.\n"
">\n"
"> > Розв'язання\n"
"> > Варіант 3 є правильним.\n"
"> > Щоб варіант 1 був правильним, потрібно виконати лише команду `head`.\n"
"> > Щоб варіант 2 був правильним, нам слід виконати лише команду `tail`.\n"
"> > Щоб варіант 4 був коректним, нам слід передати вивід команди `head` у команду `tail -n 2`\n"
"> > виконавши `head -n 3 animals.csv | tail -n 2 > animals-subset.csv`."

# header
#: shell-novice/_episodes/04-pipefilter.md:371
msgid "## Passing output to another command"
msgstr "## Передача виводу іншій команді"

#: shell-novice/_episodes/04-pipefilter.md:372
msgid ""
"In our example of finding the file with the fewest lines,\n"
"we are using two intermediate files `lengths.txt` and `sorted-lengths.txt` to store output.\n"
"This is a confusing way to work because\n"
"even once you understand what `wc`, `sort`, and `head` do,\n"
"those intermediate files make it hard to follow what's going on.\n"
"We can make it easier to understand by running `sort` and `head` together:"
msgstr ""
"У нашому прикладі ми шукаємо файл з найменшою кількістю рядків,\n"
"ми використовуємо два проміжні файли `lengths.txt` і `sorted-lengths.txt` для зберігання результатів.\n"
"Це заплутаний спосіб роботи, оскільки\n"
"навіть після того, як ви зрозумієте, що роблять `wc`, `sort` і `head`,\n"
"ці проміжні файли ускладнюють розуміння того, що відбувається.\n"
"Ми можемо полегшити розуміння, запустивши `sort` і `head` разом:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:379
msgid ""
"~~~\n"
"$ sort -n lengths.txt | head -n 1\n"
"~~~"
msgstr ""
"~~~\n"
"$ sort -n lengths.txt | head -n 1\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:389
msgid ""
"The vertical bar, `|`, between the two commands is called a **pipe**.\n"
"It tells the shell that we want to use\n"
"the output of the command on the left\n"
"as the input to the command on the right."
msgstr ""
"Вертикальна риска `|` між двома командами називається  **каналом**.\n"
"Він вказує терміналу, що ми хочемо використовувати\n"
"вивід команди ліворуч\n"
"як вхідні дані для команди праворуч."

#: shell-novice/_episodes/04-pipefilter.md:394
msgid "This has removed the need for the `sorted-lengths.txt` file."
msgstr "Це усунуло необхідність у файлі `sorted-lengths.txt`."

# header
#: shell-novice/_episodes/04-pipefilter.md:396
msgid "## Combining multiple commands"
msgstr "## Поєднання декількох команд"

#: shell-novice/_episodes/04-pipefilter.md:397
msgid ""
"Nothing prevents us from chaining pipes consecutively.\n"
"We can for example send the output of `wc` directly to `sort`,\n"
"and then the resulting output to `head`.\n"
"This removes the need for any intermediate files."
msgstr ""
"Ніщо не заважає нам з'єднувати канали послідовно.\n"
"Ми можемо, наприклад, надсилати вивід `wc` безпосередньо до `sort`,\n"
"а потім отриманий результат - до `head`.\n"
"Це усуває необхідність у будь-яких проміжних файлах."

#: shell-novice/_episodes/04-pipefilter.md:402
msgid "We'll start by using a pipe to send the output of `wc` to `sort`:"
msgstr "Ми почнемо з використання каналу для відправки виводу `wc` до `sort`:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:404
#: shell-novice/_episodes/06-script.md:236
msgid ""
"~~~\n"
"$ wc -l *.pdb | sort -n\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.pdb | sort -n\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:409
msgid ""
"~~~\n"
"   9 methane.pdb\n"
"  12 ethane.pdb\n"
"  15 propane.pdb\n"
"  20 cubane.pdb\n"
"  21 pentane.pdb\n"
"  30 octane.pdb\n"
" 107 total\n"
"~~~"
msgstr ""
"~~~\n"
"   9 methane.pdb\n"
"  12 ethane.pdb\n"
"  15 propane.pdb\n"
"  20 cubane.pdb\n"
"  21 pentane.pdb\n"
"  30 octane.pdb\n"
" 107 total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:420
msgid ""
"We can then send that output through another pipe, to `head`, so that the "
"full pipeline becomes:"
msgstr ""
"Потім ми можемо відправити цей вивід через інший канал в `head`, отже "
"конвеєр стає наступним:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:422
msgid ""
"~~~\n"
"$ wc -l *.pdb | sort -n | head -n 1\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.pdb | sort -n | head -n 1\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:427
msgid ""
"~~~\n"
"   9  methane.pdb\n"
"~~~"
msgstr ""
"~~~\n"
"   9  methane.pdb\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:432
msgid ""
"This is exactly like a mathematician nesting functions like *log(3x)*\n"
"and saying 'the log of three times *x*'.\n"
"In our case,\n"
"the calculation is 'head of sort of line count of `*.pdb`'."
msgstr ""
"Це точно так само, як математик вкладає функції на кшталт *log(3x)*\n"
"і каже 'логарифм трьох, помноженого на *x*'.\n"
"У нашому випадку,\n"
"обчислюється 'head від sort від підрахунку кількості рядків у файлах `*.pdb`'."

#: shell-novice/_episodes/04-pipefilter.md:438
msgid ""
"The redirection and pipes used in the last few commands are illustrated "
"below:"
msgstr ""
"Перенаправлення та канали, використані в останніх кількох командах, "
"проілюстровано нижче:"

#: shell-novice/_episodes/04-pipefilter.md:440
msgid ""
"![Redirects and Pipes of different commands: \"wc -l *.pdb\" will direct the\n"
"output to the shell. \"wc -l *.pdb > lengths\" will direct output to the file\n"
"\"lengths\". \"wc -l *.pdb | sort -n | head -n 1\" will build a pipeline where the\n"
"output of the \"wc\" command is the input to the \"sort\" command, the output of\n"
"the \"sort\" command is the input to the \"head\" command and the output of the\n"
"\"head\" command is directed to the shell](../fig/redirects-and-pipes.svg)"
msgstr ""
"![Перенаправлення та канали різних команд: \"wc -l *.pdb\" перенаправить\n"
"виведення до терміналу. \"wc -l *.pdb > lengths\" спрямує вивід до файлу\n"
"\"lengths\". \"wc -l *.pdb | sort -n | head -n 1\" побудує конвеєр, де\n"
"вихід команди \"wc\" є входом для команди \"sort\", вихід команди\n"
"команди \"sort\" є входом для команди \"head\", а вихід команди\n"
"\"head\" буде спрямовано до терміналу](../fig/redirects-and-pipes.svg)"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:447
msgid "> ## Piping Commands Together"
msgstr "> ## З'єднання команд у конвеєр"

#: shell-novice/_episodes/04-pipefilter.md:448
msgid ""
">\n"
"> In our current directory, we want to find the 3 files which have the least number of\n"
"> lines. Which command listed below would work?\n"
">\n"
"> 1. `wc -l * > sort -n > head -n 3`\n"
"> 2. `wc -l * | sort -n | head -n 1-3`\n"
"> 3. `wc -l * | head -n 3 | sort -n`\n"
"> 4. `wc -l * | sort -n | head -n 3`\n"
">\n"
"> > ## Solution\n"
"> > Option 4 is the solution.\n"
"> > The pipe character `|` is used to connect the output from one command to\n"
"> > the input of another.\n"
"> > `>` is used to redirect standard output to a file.\n"
"> > Try it in the `shell-lesson-data/exercise-data/proteins` directory!"
msgstr ""
">\n"
"> У нашому поточному каталозі ми хочемо знайти 3 файли, які мають найменшу кількість\n"
"> рядків. Яка з наведених нижче команд підійде для цього?\n"
">\n"
"> 1. `wc -l * > sort -n > head -n 3`.\n"
"> 2. `wc -l * | sort -n | head -n 1-3`.\n"
"> 3. `wc -l * | head -n 3 | sort -n`\n"
"> 4. `wc -l * | sort -n | head -n 3`.\n"
">\n"
"> > Розв'язання\n"
"> > Варіант 4 є рішенням.\n"
"> > Символ каналу `|` використовується для під'єднання виводу однієї команди\n"
"> > до входу іншої.\n"
"> > Символ `>` використовується для перенаправлення стандартного виводу до файлу.\n"
"> > Спробуйте у каталозі `shell-lesson-data/exercise-data/proteins`!"

# header
#: shell-novice/_episodes/04-pipefilter.md:467
msgid "## Tools designed to work together"
msgstr "## Інструменти, розроблені для спільної роботи"

#: shell-novice/_episodes/04-pipefilter.md:468
msgid ""
"This idea of linking programs together is why Unix has been so successful.\n"
"Instead of creating enormous programs that try to do many different things,\n"
"Unix programmers focus on creating lots of simple tools that each do one job well,\n"
"and that work well with each other.\n"
"This programming model is called 'pipes and filters'.\n"
"We've already seen pipes;\n"
"a **filter** is a program like `wc` or `sort`\n"
"that transforms a stream of input into a stream of output.\n"
"Almost all of the standard Unix tools can work this way:\n"
"unless told to do otherwise,\n"
"they read from standard input,\n"
"do something with what they've read,\n"
"and write to standard output."
msgstr ""
"Ця ідея зв'язування програм разом є причиною успіху Unix.\n"
"Замість того, щоб створювати величезні програми, які намагаються робити багато різних речей,\n"
"програмісти Unix зосереджуються на створенні великої кількості простих інструментів, кожен з яких добре виконує одну роботу,\n"
"і які добре працюють один з іншим.\n"
"Ця модель програмування називається \"канали та фільтри\".\n"
"Ми вже бачили канали;\n"
"а **фільтр** - це програма на кшталт `wc` або `sort`.\n"
"яка перетворює потік вхідних даних у потік вихідних даних.\n"
"Майже всі стандартні інструменти Unix можуть працювати таким чином:\n"
"якщо їм не наказано робити інакше,\n"
"вони читають зі стандартного вводу,\n"
"роблять щось з прочитаним,\n"
"і записують у стандартний вивід."

#: shell-novice/_episodes/04-pipefilter.md:482
msgid ""
"The key is that any program that reads lines of text from standard input\n"
"and writes lines of text to standard output\n"
"can be combined with every other program that behaves this way as well.\n"
"You can *and should* write your programs this way\n"
"so that you and other people can put those programs into pipes to multiply their power."
msgstr ""
"Ключовим моментом є те, що будь-яка програма, яка зчитує рядки тексту зі стандартного вводу\n"
"і записує рядки тексту у стандартний вивід,\n"
"може бути об'єднана з будь-якою іншою програмою, яка поводиться так само.\n"
"Ви можете *і повинні* писати свої програми у такий спосіб,\n"
"щоб ви та інші люди могли об'єднати ці програми у канали, щоб примножити їхню потужність."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:489
msgid "> ## Pipe Reading Comprehension"
msgstr "> ## Розуміння читання каналу"

#: shell-novice/_episodes/04-pipefilter.md:490
msgid ""
">\n"
"> A file called `animals.csv` (in the `shell-lesson-data/exercise-data/animal-counts` folder)\n"
"> contains the following data:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> 2012-11-06,deer,2\n"
"> 2012-11-06,fox,4\n"
"> 2012-11-07,rabbit,16\n"
"> 2012-11-07,bear,1\n"
"> ~~~"
msgstr ""
">\n"
"> Файл з назвою `animals.csv` (у папці `shell-lesson-data/exercise-data/animal-counts`)\n"
"> містить наступні дані:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> 2012-11-06,deer,2\n"
"> 2012-11-06,fox,4\n"
"> 2012-11-07,rabbit,16\n"
"> 2012-11-07,bear,1\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:505
msgid ""
">\n"
"> What text passes through each of the pipes and the final redirect in the pipeline below?\n"
"> Note, the `sort -r` command sorts in reverse order.\n"
">\n"
"> ~~~\n"
"> $ cat animals.csv | head -n 5 | tail -n 3 | sort -r > final.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> Hint: build the pipeline up one command at a time to test your understanding\n"
"> > ## Solution\n"
"> > The `head` command extracts the first 5 lines from `animals.csv`.\n"
"> > Then, the last 3 lines are extracted from the previous 5 by using the `tail` command.\n"
"> > With the `sort -r` command those 3 lines are sorted in reverse order and finally,\n"
"> > the output is redirected to a file `final.txt`.\n"
"> > The content of this file can be checked by executing `cat final.txt`.\n"
"> > The file should contain the following lines:\n"
"> > ```\n"
"> > 2012-11-06,rabbit,19\n"
"> > 2012-11-06,deer,2\n"
"> > 2012-11-05,raccoon,7\n"
"> > ```\n"
"> > {: .source}"
msgstr ""
">\n"
"> Який текст проходить через кожен з каналів і кінцеве перенаправлення у конвеєрі нижче?\n"
"> Зауважте, що команда `sort -r` сортує у зворотному порядку.\n"
">\n"
"> ~~~\n"
"> $ cat animals.csv | head -n 5 | tail -n 3 | sort -r > final.txt\n"
"> ~~~\n"
"> {: .language-bash}\n"
"> Підказка: створюйте конвеєр по одній команді за раз, щоб перевірити своє розуміння\n"
"> > ## Розв'язання\n"
"> > Команда `head` витягує перші 5 рядків з файлу `animals.csv`.\n"
"> > Потім останні 3 рядки витягуються з попередніх 5 за допомогою команди `tail`.\n"
"> > За допомогою команди `sort -r` ці 3 рядки сортуються у зворотному порядку і нарешті,\n"
"> > виведення перенаправляється до файлу `final.txt`.\n"
"> > Вміст цього файлу можна перевірити, виконавши команду `cat final.txt`.\n"
"> > Файл повинен містити наступні рядки:\n"
"> > ```\n"
"> > 2012-11-06,rabbit,19\n"
"> > 2012-11-06,олень,2\n"
"> > 2012-11-05,єнот,7\n"
"> > ```\n"
"> > {: .source}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:530
msgid "> ## Pipe Construction"
msgstr "> ## Конструювання каналу"

#: shell-novice/_episodes/04-pipefilter.md:531
msgid ""
">\n"
"> For the file `animals.csv` from the previous exercise, consider the following command:\n"
">\n"
"> ~~~\n"
"> $ cut -d , -f 2 animals.csv\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> The `cut` command is used to remove or 'cut out' certain sections of each line in the file,\n"
"> and `cut` expects the lines to be separated into columns by a <kbd>Tab</kbd> character.\n"
"> A character used in this way is a called a **delimiter**.\n"
"> In the example above we use the `-d` option to specify the comma as our delimiter character.\n"
"> We have also used the `-f` option to specify that we want to extract the second field (column).\n"
"> This gives the following output:\n"
">\n"
"> ~~~\n"
"> deer\n"
"> rabbit\n"
"> raccoon\n"
"> rabbit\n"
"> deer\n"
"> fox\n"
"> rabbit\n"
"> bear\n"
"> ~~~"
msgstr ""
">\n"
"> Для файлу `animals.csv` з попередньої завдання розглянемо наступну команду:>\n"
"> ~~~\n"
"> $ cut -d , -f 2 animals.csv\n"
"> ~~~\n"
"> {: .language-bash}\n"
">\n"
"> Команда `cut` використовується для видалення або 'вирізання' певних частин кожного рядка у файлі,\n"
"> і `cut` очікує, що рядки буде розділено на стовпчики символом <kbd>Tab</kbd>.\n"
"> Символ, який використовується таким чином, називається **відокремлювальним символом**.\n"
"> У наведеному вище прикладі ми використовуємо опцію `-d`, щоб вказати кому як відокремлювальний символ.\n"
"> Ми також використали опцію `-f`, щоб вказати, що ми хочемо вилучити друге поле (стовпчик).\n"
"> Це призведе до наступного результату:\n"
">\n"
"> ~~~\n"
"> deer\n"
"> rabbit\n"
"> raccoon\n"
"> rabbit\n"
"> deer\n"
"> fox\n"
"> rabbit\n"
"> bear\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:557
msgid ""
">\n"
"> The `uniq` command filters out adjacent matching lines in a file.\n"
"> How could you extend this pipeline (using `uniq` and another command) to find\n"
"> out what animals the file contains (without any duplicates in their\n"
"> names)?\n"
">\n"
"> > ## Solution\n"
"> > ```\n"
"> > $ cut -d , -f 2 animals.csv | sort | uniq\n"
"> > ```\n"
"> > {: .language-bash}"
msgstr ""
">\n"
"> Команда `uniq` відфільтровує сусідні однакові рядки у файлі.\n"
"> Як можна розширити цей конвеєр (за допомогою `uniq` та іншої команди), щоб\n"
"> з'ясувати, які тварини містяться у файлі (без повторень у їхніх\n"
"> назвах)?\n"
">\n"
"> > ## Розв'язання\n"
"> > ```\n"
"> > $ cut -d , -f 2 animals.csv | sort | uniq\n"
"> > ```\n"
"> > {: .language-bash}"

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:571
msgid "> ## Which Pipe?"
msgstr "> ## Який канал?"

#: shell-novice/_episodes/04-pipefilter.md:572
msgid ""
">\n"
"> The file `animals.csv` contains 8 lines of data formatted as follows:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> ...\n"
"> ~~~"
msgstr ""
">\n"
"> Файл `animals.csv` містить 8 рядків даних, відформатованих наступним чином:\n"
">\n"
"> ~~~\n"
"> 2012-11-05,deer,5\n"
"> 2012-11-05,rabbit,22\n"
"> 2012-11-05,raccoon,7\n"
"> 2012-11-06,rabbit,19\n"
"> ...\n"
"> ~~~"

#: shell-novice/_episodes/04-pipefilter.md:583
msgid ""
">\n"
"> The `uniq` command has a `-c` option which gives a count of the\n"
"> number of times a line occurs in its input.  Assuming your current\n"
"> directory is `shell-lesson-data/exercise-data/animal-counts`,\n"
"> what command would you use to produce a table that shows\n"
"> the total count of each type of animal in the file?\n"
">\n"
"> 1.  `sort animals.csv | uniq -c`\n"
"> 2.  `sort -t, -k2,2 animals.csv | uniq -c`\n"
"> 3.  `cut -d, -f 2 animals.csv | uniq -c`\n"
"> 4.  `cut -d, -f 2 animals.csv | sort | uniq -c`\n"
"> 5.  `cut -d, -f 2 animals.csv | sort | uniq -c | wc -l`\n"
">\n"
"> > ## Solution\n"
"> > Option 4. is the correct answer.\n"
"> > If you have difficulty understanding why, try running the commands, or sub-sections of\n"
"> > the pipelines (make sure you are in the `shell-lesson-data/exercise-data/animal-counts`\n"
"> > directory)."
msgstr ""
">\n"
"> Команда `uniq` має опцію `-c`, яка дає\n"
"> кількість входжень рядка у вхідних даних. Припустимо, що ваш поточний\n"
"> каталог має назву `shell-lesson-data/exercise-data/animal-counts`,\n"
"> яку команду слід використати, щоб створити таблицю, яка показує\n"
"> загальну кількість тварин кожного типу у файлі?\n"
">\n"
"> 1. `sort animals.csv | uniq -c`.\n"
"> 2. `sort -t, -k2,2 animals.csv | uniq -c`.\n"
"> 3. `cut -d, -f 2 animals.csv | uniq -c`\n"
"> 4. `cut -d, -f 2 animals.csv | sort | uniq -c`.\n"
"> 5. `cut -d, -f 2 animals.csv | sort | uniq -c | wc -l`\n"
">\n"
"> > ## Розв'язання\n"
"> > Варіант 4 є правильною відповіддю.\n"
"> > Якщо вам важко зрозуміти, чому, спробуйте виконати команди або фрагменти\n"
"> > конвеєрів (переконайтеся, що ви перебуваєте у каталозі `shell-lesson-data/exercise-data/animal-counts`)."

# header
#: shell-novice/_episodes/04-pipefilter.md:604
msgid "## Nelle's Pipeline: Checking Files"
msgstr "### Конвеєр Неллі: Перевірка файлів"

#: shell-novice/_episodes/04-pipefilter.md:606
msgid ""
"Nelle has run her samples through the assay machines\n"
"and created 17 files in the `north-pacific-gyre` directory described earlier.\n"
"As a quick check, starting from the `shell-lesson-data` directory, Nelle types:"
msgstr ""
"Неллі пропустила свої зразки через аналізатори\n"
"і створила 17 файлів у каталозі `north-pacific-gyre`, описаному раніше.\n"
"Для швидкої перевірки, починаючи з каталогу `shell-lesson-data`, Неллі набирає:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:610
msgid ""
"~~~\n"
"$ cd north-pacific-gyre\n"
"$ wc -l *.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ cd north-pacific-gyre\n"
"$ wc -l *.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:616
msgid "The output is 18 lines that look like this:"
msgstr "На виході вона отримує 18 рядків, які виглядають наступним чином:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:618
msgid ""
"~~~\n"
"300 NENE01729A.txt\n"
"300 NENE01729B.txt\n"
"300 NENE01736A.txt\n"
"300 NENE01751A.txt\n"
"300 NENE01751B.txt\n"
"300 NENE01812A.txt\n"
"... ...\n"
"~~~"
msgstr ""
"~~~\n"
"300 NENE01729A.txt\n"
"300 NENE01729B.txt\n"
"300 NENE01736A.txt\n"
"300 NENE01751A.txt\n"
"300 NENE01751B.txt\n"
"300 NENE01812A.txt\n"
"... ...\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:629
msgid "Now she types this:"
msgstr "Тепер вона набирає наступне:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:631
msgid ""
"~~~\n"
"$ wc -l *.txt | sort -n | head -n 5\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.txt | sort -n | head -n 5\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:636
msgid ""
"~~~\n"
" 240 NENE02018B.txt\n"
" 300 NENE01729A.txt\n"
" 300 NENE01729B.txt\n"
" 300 NENE01736A.txt\n"
" 300 NENE01751A.txt\n"
"~~~"
msgstr ""
"~~~\n"
" 240 NENE02018B.txt\n"
" 300 NENE01729A.txt\n"
" 300 NENE01729B.txt\n"
" 300 NENE01736A.txt\n"
" 300 NENE01751A.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:645
msgid ""
"Whoops: one of the files is 60 lines shorter than the others.\n"
"When she goes back and checks it,\n"
"she sees that she did that assay at 8:00 on a Monday morning --- someone\n"
"was probably in using the machine on the weekend,\n"
"and she forgot to reset it.\n"
"Before re-running that sample,\n"
"she checks to see if any files have too much data:"
msgstr ""
"Упс: один з файлів на 60 рядків коротший за інші.\n"
"Коли вона повертається і перевіряє його,\n"
"вона бачить, що зробила цей аналіз о 8:00 ранку в понеділок --- хтось,\n"
"можливо, користувався машиною на вихідних,\n"
"і вона забула її перезавантажити.\n"
"Перед тим, як повторно проаналізувати цей зразок,\n"
"вона перевіряє, чи є файли, що містять забагато даних:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:653
msgid ""
"~~~\n"
"$ wc -l *.txt | sort -n | tail -n 5\n"
"~~~"
msgstr ""
"~~~\n"
"$ wc -l *.txt | sort -n | tail -n 5\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:658
msgid ""
"~~~\n"
" 300 NENE02040B.txt\n"
" 300 NENE02040Z.txt\n"
" 300 NENE02043A.txt\n"
" 300 NENE02043B.txt\n"
"5040 total\n"
"~~~"
msgstr ""
"~~~\n"
" 300 NENE02040B.txt\n"
" 300 NENE02040Z.txt\n"
" 300 NENE02043A.txt\n"
" 300 NENE02043B.txt\n"
"5040 total\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:667
msgid ""
"Those numbers look good --- but what's that 'Z' doing there in the third-to-last line?\n"
"All of her samples should be marked 'A' or 'B';\n"
"by convention,\n"
"her lab uses 'Z' to indicate samples with missing information.\n"
"To find others like it, she does this:"
msgstr ""
"Ці цифри виглядають добре --- але що робить ця 'Z' у передостанньому рядку?\n"
"Всі її зразки мають бути позначені 'A' або 'B';\n"
"за попередньою домовленістю\n"
"її лабораторія використовує 'Z' для позначення зразків з недостатньою інформацією.\n"
"Щоб знайти подібні зразки, вона робить наступне:"

# code block
#: shell-novice/_episodes/04-pipefilter.md:673
msgid ""
"~~~\n"
"$ ls *Z.txt\n"
"~~~"
msgstr ""
"~~~\n"
"$ ls *Z.txt\n"
"~~~"

# code block
#: shell-novice/_episodes/04-pipefilter.md:678
msgid ""
"~~~\n"
"NENE01971Z.txt    NENE02040Z.txt\n"
"~~~"
msgstr ""
"~~~\n"
"NENE01971Z.txt    NENE02040Z.txt\n"
"~~~"

#: shell-novice/_episodes/04-pipefilter.md:683
msgid ""
"Sure enough,\n"
"when she checks the log on her laptop,\n"
"there's no depth recorded for either of those samples.\n"
"Since it's too late to get the information any other way,\n"
"she must exclude those two files from her analysis.\n"
"She could delete them using `rm`,\n"
"but there are actually some analyses she might do later where depth doesn't matter,\n"
"so instead, she'll have to be careful later on to select files using the wildcard expressions\n"
"`NENE*A.txt NENE*B.txt`."
msgstr ""
"Звісно,\n"
"коли вона перевіряє журнал на своєму ноутбуці,\n"
"глибина не записана для жодного з цих зразків.\n"
"Оскільки вже занадто пізно отримати інформацію в інший спосіб,\n"
"вона повинна виключити ці два файли з аналізу.\n"
"Вона може видалити їх за допомогою `rm`,\n"
"але насправді є деякі аналізи, які вона може зробити пізніше, де глибина не має значення,\n"
"тож натомість, пізніше їй доведеться бути обережною і вибирати файли за допомогою підстановочних виразів\n"
"`NENE*A.txt NENE*B.txt`."

# blockquote, which can be cascaded
#: shell-novice/_episodes/04-pipefilter.md:694
msgid "> ## Removing Unneeded Files"
msgstr "> ## Видалення непотрібних файлів"

#: shell-novice/_episodes/04-pipefilter.md:695
msgid ""
">\n"
"> Suppose you want to delete your processed data files, and only keep\n"
"> your raw files and processing script to save storage.\n"
"> The raw files end in `.dat` and the processed files end in `.txt`.\n"
"> Which of the following would remove all the processed data files,\n"
"> and *only* the processed data files?\n"
">\n"
"> 1. `rm ?.txt`\n"
"> 2. `rm *.txt`\n"
"> 3. `rm * .txt`\n"
"> 4. `rm *.*`\n"
">\n"
"> > ## Solution\n"
"> > 1. This would remove `.txt` files with one-character names\n"
"> > 2. This is the correct answer\n"
"> > 3. The shell would expand `*` to match everything in the current directory,\n"
"> > so the command would try to remove all matched files and an additional\n"
"> > file called `.txt`\n"
"> > 4. The shell would expand `*.*` to match all files with any extension,\n"
"> > so this command would delete all files"
msgstr ""
">\n"
"> Припустимо, ви хочете видалити файли оброблених даних і зберегти лише\n"
"> сирі файли і скрипт обробки для економії місця у сховищі.\n"
"> Вихідні файли закінчуються на `.dat`, а оброблені файли закінчуються на `.txt`.\n"
"> Яка з наведених нижче команд видалить усі оброблені файли даних,\n"
"> і *лише* оброблені файли даних?\n"
">\n"
"> 1. `rm ?.txt`\n"
"> 2. `rm *.txt`\n"
"> 3. `rm * .txt`\n"
"> 4. `rm *.*`\n"
">\n"
"> > Розв'язання\n"
"> > 1. Це призведе до вилучення файлів `.txt` з односимвольними назвами\n"
"> > 2. Це правильна відповідь\n"
"> > 3. Термінал розширить підстановочний символ `*` так, щоб він відповідав усім файлам у поточному каталозі,\n"
"> > таким чином, команда спробує видалити всі знайдені файли і додатковий\n"
"> > файл з назвою `.txt'.\n"
"> > 4. Термінал розширить `*.*`, щоб знайти всі файли з будь-яким розширенням,\n"
"> > таким чином, ця команда видалить усі файли."
