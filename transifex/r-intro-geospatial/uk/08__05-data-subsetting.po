# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Yurii Kleban, 2023
# vorontsoovaa, 2023
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2020-07-18 17:19:47+0100\n"
"PO-Revision-Date: 2020-07-18 16:29+0000\n"
"Last-Translator: vorontsoovaa, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/carpentries-i18n/teams/98915/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

# Front Matter
#: r-intro-geospatial/_episodes/05-data-subsetting.md:1
msgid ""
"---\n"
"# Please do not edit this file directly; it is auto generated.\n"
"# Instead, please edit 05-data-subsetting.md in _episodes_rmd/\n"
"title: Subsetting Data\n"
"teaching: 25\n"
"exercises: 10\n"
"questions:\n"
"- \"How can I work with subsets of data in R?\"\n"
"objectives:\n"
"- \"To be able to subset vectors and data frames\"\n"
"- \"To be able to extract individual and multiple elements: by index, by name, using comparison operations\"\n"
"- \"To be able to skip and remove elements from various data structures.\"\n"
"keypoints:\n"
"- \"Indexing in R starts at 1, not 0.\"\n"
"- \"Access individual values by location using `[]`.\"\n"
"- \"Access slices of data using `[low:high]`.\"\n"
"- \"Access arbitrary sets of data using `[c(...)]`.\"\n"
"- \"Use logical operations and logical vectors to access subsets of data.\"\n"
"source: Rmd\n"
"---"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:24
msgid ""
"R has many powerful subset operators. Mastering them will allow you to\n"
"easily perform complex operations on any kind of dataset."
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:27
msgid ""
"There are six different ways we can subset any kind of object, and three\n"
"different subsetting operators for the different data structures."
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:30
msgid "Let's start with the workhorse of R: a simple numeric vector."
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:33
msgid ""
"~~~\n"
"x <- c(5.4, 6.2, 7.1, 4.8, 7.5)\n"
"names(x) <- c('a', 'b', 'c', 'd', 'e')\n"
"x\n"
"~~~"
msgstr ""
"~~~\n"
"x <- c(5.4, 6.2, 7.1, 4.8, 7.5)\n"
"names(x) <- c('a', 'b', 'c', 'd', 'e')\n"
"x\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:42
msgid ""
"~~~\n"
"  a   b   c   d   e \n"
"5.4 6.2 7.1 4.8 7.5 \n"
"~~~"
msgstr ""
"~~~\n"
"  a   b   c   d   e \n"
"5.4 6.2 7.1 4.8 7.5 \n"
"~~~"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/05-data-subsetting.md:48
msgid "> ## Atomic vectors"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:49
msgid ""
">\n"
"> In R, simple vectors containing character strings, numbers, or logical values\n"
"> are called *atomic* vectors because they can't be further simplified."
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:54
msgid ""
"So now that we've created a dummy vector to play with, how do we get at its\n"
"contents?"
msgstr ""

# header
#: r-intro-geospatial/_episodes/05-data-subsetting.md:57
msgid "## Accessing elements using their indices"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:59
msgid ""
"To extract elements of a vector we can give their corresponding index, starting\n"
"from one:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:63
msgid ""
"~~~\n"
"x[1]\n"
"~~~"
msgstr ""
"~~~\n"
"x[1]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:70
#: r-intro-geospatial/_episodes/05-data-subsetting.md:466
msgid ""
"~~~\n"
"  a \n"
"5.4 \n"
"~~~"
msgstr ""
"~~~\n"
"  a \n"
"5.4 \n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:77
msgid ""
"~~~\n"
"x[4]\n"
"~~~"
msgstr ""
"~~~\n"
"x[4]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:84
msgid ""
"~~~\n"
"  d \n"
"4.8 \n"
"~~~"
msgstr ""
"~~~\n"
"  d \n"
"4.8 \n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:90
msgid ""
"It may look different, but the square brackets operator is a function. For vectors\n"
"(and matrices), it means \"get me the nth element\"."
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:93
msgid "We can ask for multiple elements at once:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:96
msgid ""
"~~~\n"
"x[c(1, 3)]\n"
"~~~"
msgstr ""
"~~~\n"
"x[c(1, 3)]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:103
#: r-intro-geospatial/_episodes/05-data-subsetting.md:405
msgid ""
"~~~\n"
"  a   c \n"
"5.4 7.1 \n"
"~~~"
msgstr ""
"~~~\n"
"  a   c \n"
"5.4 7.1 \n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:109
msgid "Or slices of the vector:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:112
msgid ""
"~~~\n"
"x[1:4]\n"
"~~~"
msgstr ""
"~~~\n"
"x[1:4]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:119
msgid ""
"~~~\n"
"  a   b   c   d \n"
"5.4 6.2 7.1 4.8 \n"
"~~~"
msgstr ""
"~~~\n"
"  a   b   c   d \n"
"5.4 6.2 7.1 4.8 \n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:125
msgid ""
"the `:` operator creates a sequence of numbers from the left element to the "
"right."
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:127
msgid ""
"~~~\n"
"1:4\n"
"~~~"
msgstr ""
"~~~\n"
"1:4\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:134
#: r-intro-geospatial/_episodes/05-data-subsetting.md:148
msgid ""
"~~~\n"
"[1] 1 2 3 4\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 1 2 3 4\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:141
msgid ""
"~~~\n"
"c(1, 2, 3, 4)\n"
"~~~"
msgstr ""
"~~~\n"
"c(1, 2, 3, 4)\n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:154
msgid "We can ask for the same element multiple times:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:157
msgid ""
"~~~\n"
"x[c(1, 1, 3)]\n"
"~~~"
msgstr ""
"~~~\n"
"x[c(1, 1, 3)]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:164
msgid ""
"~~~\n"
"  a   a   c \n"
"5.4 5.4 7.1 \n"
"~~~"
msgstr ""
"~~~\n"
"  a   a   c \n"
"5.4 5.4 7.1 \n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:170
msgid ""
"If we ask for an index beyond the length of the vector, R will return a "
"missing value:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:172
msgid ""
"~~~\n"
"x[6]\n"
"~~~"
msgstr ""
"~~~\n"
"x[6]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:179
msgid ""
"~~~\n"
"<NA> \n"
"  NA \n"
"~~~"
msgstr ""
"~~~\n"
"<NA> \n"
"  NA \n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:185
msgid ""
"This is a vector of length one containing an `NA`, whose name is also `NA`."
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:187
msgid "If we ask for the 0th element, we get an empty vector:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:190
msgid ""
"~~~\n"
"x[0]\n"
"~~~"
msgstr ""
"~~~\n"
"x[0]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:197
msgid ""
"~~~\n"
"named numeric(0)\n"
"~~~"
msgstr ""
"~~~\n"
"named numeric(0)\n"
"~~~"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/05-data-subsetting.md:202
msgid "> ## Vector numbering in R starts at 1"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:203
msgid ""
">\n"
"> In many programming languages (C and Python, for example), the first\n"
"> element of a vector has an index of 0. In R, the first element is 1."
msgstr ""

# header
#: r-intro-geospatial/_episodes/05-data-subsetting.md:208
msgid "## Skipping and removing elements"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:210
msgid ""
"If we use a negative number as the index of a vector, R will return\n"
"every element *except* for the one specified:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:214
msgid ""
"~~~\n"
"x[-2]\n"
"~~~"
msgstr ""
"~~~\n"
"x[-2]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:221
msgid ""
"~~~\n"
"  a   c   d   e \n"
"5.4 7.1 4.8 7.5 \n"
"~~~"
msgstr ""
"~~~\n"
"  a   c   d   e \n"
"5.4 7.1 4.8 7.5 \n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:227
msgid "We can skip multiple elements:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:230
msgid ""
"~~~\n"
"x[c(-1, -5)]  # or x[-c(1,5)]\n"
"~~~"
msgstr ""
"~~~\n"
"x[c(-1, -5)]  # or x[-c(1,5)]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:237
msgid ""
"~~~\n"
"  b   c   d \n"
"6.2 7.1 4.8 \n"
"~~~"
msgstr ""
"~~~\n"
"  b   c   d \n"
"6.2 7.1 4.8 \n"
"~~~"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/05-data-subsetting.md:243
msgid "> ## Tip: Order of operations"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:244
msgid ""
">\n"
"> A common trip up for novices occurs when trying to skip\n"
"> slices of a vector. It's natural to to try to negate a\n"
"> sequence like so:\n"
">\n"
"> \n"
"> ~~~\n"
"> x[-1:3]\n"
"> ~~~\n"
"> {: .language-r}\n"
">\n"
"> This gives a somewhat cryptic error:\n"
">\n"
"> \n"
"> ~~~\n"
"> Error in x[-1:3]: only 0's may be mixed with negative subscripts\n"
"> ~~~"
msgstr ""

# SC/DC Template label
#: r-intro-geospatial/_episodes/05-data-subsetting.md:261
msgid "> {: .error}"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:262
msgid ""
">\n"
"> But remember the order of operations. `:` is really a function.\n"
"> It takes its first argument as -1, and its second as 3,\n"
"> so generates the sequence of numbers: `c(-1, 0, 1, 2, 3)`.\n"
">\n"
"> The correct solution is to wrap that function call in brackets, so\n"
"> that the `-` operator applies to the result:\n"
">\n"
"> \n"
"> ~~~\n"
"> x[-(1:3)]\n"
"> ~~~\n"
"> {: .language-r}\n"
"> \n"
"> \n"
"> \n"
"> ~~~\n"
">   d   e \n"
"> 4.8 7.5 \n"
"> ~~~"
msgstr ""

# SC/DC Template label
#: r-intro-geospatial/_episodes/05-data-subsetting.md:282
#: r-intro-geospatial/_episodes/05-data-subsetting.md:322
#: r-intro-geospatial/_episodes/05-data-subsetting.md:331
#: r-intro-geospatial/_episodes/05-data-subsetting.md:519
msgid "> {: .output}"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:286
msgid ""
"To remove elements from a vector, we need to assign the result back\n"
"into the variable:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:290
msgid ""
"~~~\n"
"x <- x[-4]\n"
"x\n"
"~~~"
msgstr ""
"~~~\n"
"x <- x[-4]\n"
"x\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:298
msgid ""
"~~~\n"
"  a   b   c   e \n"
"5.4 6.2 7.1 7.5 \n"
"~~~"
msgstr ""
"~~~\n"
"  a   b   c   e \n"
"5.4 6.2 7.1 7.5 \n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:305
#: r-intro-geospatial/_episodes/05-data-subsetting.md:502
msgid ""
">\n"
"> Given the following code:\n"
">\n"
"> \n"
"> ~~~\n"
"> x <- c(5.4, 6.2, 7.1, 4.8, 7.5)\n"
"> names(x) <- c('a', 'b', 'c', 'd', 'e')\n"
"> print(x)\n"
"> ~~~\n"
"> {: .language-r}\n"
"> \n"
"> \n"
"> \n"
"> ~~~\n"
">   a   b   c   d   e \n"
"> 5.4 6.2 7.1 4.8 7.5 \n"
"> ~~~"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:323
msgid ""
">\n"
"> Come up with at least 3 different commands that will produce the following output:\n"
">\n"
"> \n"
"> ~~~\n"
">   b   c   d \n"
"> 6.2 7.1 4.8 \n"
"> ~~~"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:332
msgid ""
">\n"
"> After you find 3 different commands, compare notes with your neighbour. Did you have different strategies?\n"
">\n"
"> > ## Solution to challenge 1\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > x[2:4]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   b   c   d \n"
"> > 6.2 7.1 4.8 \n"
"> > ~~~\n"
"> > {: .output}\n"
"> > \n"
"> > ~~~\n"
"> > x[-c(1,5)]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   b   c   d \n"
"> > 6.2 7.1 4.8 \n"
"> > ~~~\n"
"> > {: .output}\n"
"> > \n"
"> > ~~~\n"
"> > x[c(\"b\", \"c\", \"d\")]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   b   c   d \n"
"> > 6.2 7.1 4.8 \n"
"> > ~~~\n"
"> > {: .output}\n"
"> > \n"
"> > ~~~\n"
"> > x[c(2,3,4)]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   b   c   d \n"
"> > 6.2 7.1 4.8 \n"
"> > ~~~\n"
"> > {: .output}"
msgstr ""

# header
#: r-intro-geospatial/_episodes/05-data-subsetting.md:392
msgid "## Subsetting by name"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:394
msgid ""
"We can extract elements by using their name, instead of extracting by index:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:397
msgid ""
"~~~\n"
"x <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) # we can name a vector 'on the fly'\n"
"x[c(\"a\", \"c\")]\n"
"~~~"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:411
msgid ""
"This is usually a much more reliable way to subset objects: the\n"
"position of various elements can often change when chaining together\n"
"subsetting operations, but the names will always remain the same!"
msgstr ""

# header
#: r-intro-geospatial/_episodes/05-data-subsetting.md:415
msgid "## Subsetting through other logical operations"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:417
msgid "We can also use any logical vector to subset:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:420
msgid ""
"~~~\n"
"x[c(FALSE, FALSE, TRUE, FALSE, TRUE)]\n"
"~~~"
msgstr ""
"~~~\n"
"x[c(FALSE, FALSE, TRUE, FALSE, TRUE)]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:427
#: r-intro-geospatial/_episodes/05-data-subsetting.md:445
msgid ""
"~~~\n"
"  c   e \n"
"7.1 7.5 \n"
"~~~"
msgstr ""
"~~~\n"
"  c   e \n"
"7.1 7.5 \n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:433
msgid ""
"Since comparison operators (e.g. `>`, `<`, `==`) evaluate to logical vectors, we can also\n"
"use them to succinctly subset vectors: the following statement gives\n"
"the same result as the previous one."
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:438
msgid ""
"~~~\n"
"x[x > 7]\n"
"~~~"
msgstr ""
"~~~\n"
"x[x > 7]\n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:451
msgid ""
"Breaking it down, this statement first evaluates `x>7`, generating\n"
"a logical vector `c(FALSE, FALSE, TRUE, FALSE, TRUE)`, and then\n"
"selects the elements of `x` corresponding to the `TRUE` values."
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:455
msgid ""
"We can use `==` to mimic the previous method of indexing by name\n"
"(remember you have to use `==` rather than `=` for comparisons):"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:459
msgid ""
"~~~\n"
"x[names(x) == \"a\"]\n"
"~~~"
msgstr ""
"~~~\n"
"x[names(x) == \"a\"]\n"
"~~~"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/05-data-subsetting.md:472
msgid "> ## Tip: Combining logical conditions"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:473
msgid ""
">\n"
"> We often want to combine multiple logical\n"
"> criteria. For example, we might want to find all the countries that are\n"
"> located in Asia **or** Europe **and** have life expectancies within a certain\n"
"> range. Several operations for combining logical vectors exist in R:\n"
">\n"
">  * `&`, the \"logical AND\" operator: returns `TRUE` if both the left and right\n"
">    are `TRUE`.\n"
">  * `|`, the \"logical OR\" operator: returns `TRUE`, if either the left or right\n"
">    (or both) are `TRUE`.\n"
">\n"
"> You may sometimes see `&&` and `||` instead of `&` and `|`. These two-character operators\n"
"> only look at the first element of each vector and ignore the\n"
"> remaining elements. In general you should not use the two-character\n"
"> operators in data analysis; save them\n"
"> for programming, i.e. deciding whether to execute a statement.\n"
">\n"
">  * `!`, the \"logical NOT\" operator: converts `TRUE` to `FALSE` and `FALSE` to\n"
">    `TRUE`. It can negate a single logical condition (eg `!TRUE` becomes\n"
">    `FALSE`), or a whole vector of conditions(eg `!c(TRUE, FALSE)` becomes\n"
">    `c(FALSE, TRUE)`).\n"
">\n"
"> Additionally, you can compare the elements within a single vector using the\n"
"> `all` function (which returns `TRUE` if every element of the vector is `TRUE`)\n"
"> and the `any` function (which returns `TRUE` if one or more elements of the\n"
"> vector are `TRUE`)."
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:520
msgid ""
">\n"
"> Write a subsetting command to return the values in x that are greater than 4 and less than 7.\n"
">\n"
"> > ## Solution to challenge 2\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > x_subset <- x[x<7 & x>4]\n"
"> > print(x_subset)\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   a   b   d \n"
"> > 5.4 6.2 4.8 \n"
"> > ~~~\n"
"> > {: .output}"
msgstr ""

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/05-data-subsetting.md:542
msgid "> ## Tip: Getting help for operators"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:543
msgid ""
">\n"
"> Remember you can search for help on operators by wrapping them in quotes:\n"
"> `help(\"%in%\")` or `?\"%in%\"`."
msgstr ""

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/05-data-subsetting.md:549
msgid "> ## Handling special values"
msgstr ""

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/05-data-subsetting.md:550
msgid ""
"> At some point you will encounter functions in R that cannot handle "
"missing, infinite,"
msgstr ""

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/05-data-subsetting.md:551
msgid "> or undefined data."
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:552
msgid ""
">\n"
"> There are a number of special functions you can use to filter out this data:\n"
">\n"
"> * `is.na` will return all positions in a vector, matrix, or data frame\n"
">   containing `NA` (or `NaN`)\n"
"> * likewise, `is.nan`, and `is.infinite` will do the same for `NaN` and `Inf`.\n"
"> * `is.finite` will return all positions in a vector, matrix, or data.frame\n"
">   that do not contain `NA`, `NaN` or `Inf`.\n"
"> * `na.omit` will filter out all missing values from a vector"
msgstr ""

# header
#: r-intro-geospatial/_episodes/05-data-subsetting.md:563
msgid "## Data frames"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:565
msgid ""
"Remember the data frames are lists underneath the hood, so similar rules\n"
"apply. However they are also two dimensional objects:"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:568
msgid ""
"`[` with one argument will act the same way as for lists, where each list\n"
"element corresponds to a column. The resulting object will be a data frame:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:572
msgid ""
"~~~\n"
"head(gapminder[3])\n"
"~~~"
msgstr ""
"~~~\n"
"head(gapminder[3])\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:579
msgid ""
"~~~\n"
"       pop\n"
"1  8425333\n"
"2  9240934\n"
"3 10267083\n"
"4 11537966\n"
"5 13079460\n"
"6 14880372\n"
"~~~"
msgstr ""
"~~~\n"
"       pop\n"
"1  8425333\n"
"2  9240934\n"
"3 10267083\n"
"4 11537966\n"
"5 13079460\n"
"6 14880372\n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:590
msgid "Similarly, `[[` will act to extract *a single column*:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:593
msgid ""
"~~~\n"
"head(gapminder[[\"lifeExp\"]])\n"
"~~~"
msgstr ""
"~~~\n"
"head(gapminder[[\"lifeExp\"]])\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:600
msgid ""
"~~~\n"
"[1] 28.801 30.332 31.997 34.020 36.088 38.438\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 28.801 30.332 31.997 34.020 36.088 38.438\n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:605
msgid "And `$` provides a convenient shorthand to extract columns by name:"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:608
msgid ""
"~~~\n"
"head(gapminder$year)\n"
"~~~"
msgstr ""
"~~~\n"
"head(gapminder$year)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:615
msgid ""
"~~~\n"
"[1] 1952 1957 1962 1967 1972 1977\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 1952 1957 1962 1967 1972 1977\n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:620
msgid ""
"To select specific rows and/or columns, you can provide two arguments to `[`"
" "
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:623
msgid ""
"~~~\n"
"gapminder[1:3, ]\n"
"~~~"
msgstr ""
"~~~\n"
"gapminder[1:3, ]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:630
msgid ""
"~~~\n"
"      country year      pop continent lifeExp gdpPercap\n"
"1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n"
"2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n"
"3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n"
"~~~"
msgstr ""
"~~~\n"
"      country year      pop continent lifeExp gdpPercap\n"
"1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n"
"2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n"
"3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:638
msgid ""
"If we subset a single row, the result will be a data frame (because\n"
"the elements are mixed types):"
msgstr ""

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:642
msgid ""
"~~~\n"
"gapminder[3, ]\n"
"~~~"
msgstr ""
"~~~\n"
"gapminder[3, ]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/05-data-subsetting.md:649
msgid ""
"~~~\n"
"      country year      pop continent lifeExp gdpPercap\n"
"3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n"
"~~~"
msgstr ""
"~~~\n"
"      country year      pop continent lifeExp gdpPercap\n"
"3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n"
"~~~"

#: r-intro-geospatial/_episodes/05-data-subsetting.md:655
msgid ""
"But for a single column the result will be a vector (this can be changed with\n"
"the third argument, `drop = F0ALSE`)."
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:659
msgid ""
">\n"
"> Fix each of the following common data frame subsetting errors:\n"
">\n"
"> 1. Extract observations collected for the year 1957\n"
">\n"
">    \n"
">    ~~~\n"
">    gapminder[gapminder$year = 1957, ]\n"
">    ~~~\n"
">    {: .language-r}\n"
">\n"
"> 2. Extract all columns except 1 through to 4\n"
">\n"
">    \n"
">    ~~~\n"
">    gapminder[, -1:4]\n"
">    ~~~\n"
">    {: .language-r}\n"
">\n"
"> 3. Extract the rows where the life expectancy is longer the 80 years\n"
">\n"
">    \n"
">    ~~~\n"
">    gapminder[gapminder$lifeExp > 80]\n"
">    ~~~\n"
">    {: .language-r}\n"
">\n"
"> 4. Extract the first row, and the fourth and fifth columns\n"
">   (`lifeExp` and `gdpPercap`).\n"
">\n"
">    \n"
">    ~~~\n"
">    gapminder[1, 4, 5]\n"
">    ~~~\n"
">    {: .language-r}\n"
">\n"
"> 5. Advanced: extract rows that contain information for the years 2002\n"
">    and 2007\n"
">\n"
">    \n"
">    ~~~\n"
">    gapminder[gapminder$year == 2002 | 2007,]\n"
">    ~~~\n"
">    {: .language-r}\n"
">\n"
"> > ## Solution to challenge 3\n"
"> >\n"
"> > Fix each of the following common data frame subsetting errors:\n"
"> >\n"
"> > 1. Extract observations collected for the year 1957\n"
"> >\n"
"> >    \n"
"> >    ~~~\n"
"> >    # gapminder[gapminder$year = 1957, ]\n"
"> >    gapminder[gapminder$year == 1957, ]\n"
"> >    ~~~\n"
"> >    {: .language-r}\n"
"> >\n"
"> > 2. Extract all columns except 1 through to 4\n"
"> >\n"
"> >    \n"
"> >    ~~~\n"
"> >    # gapminder[, -1:4]\n"
"> >    gapminder[,-c(1:4)]\n"
"> >    ~~~\n"
"> >    {: .language-r}\n"
"> >\n"
"> > 3. Extract the rows where the life expectancy is longer the 80 years\n"
"> >\n"
"> >    \n"
"> >    ~~~\n"
"> >    # gapminder[gapminder$lifeExp > 80]\n"
"> >    gapminder[gapminder$lifeExp > 80,]\n"
"> >    ~~~\n"
"> >    {: .language-r}\n"
"> >\n"
"> > 4. Extract the first row, and the fourth and fifth columns\n"
"> >   (`lifeExp` and `gdpPercap`).\n"
"> >\n"
"> >    \n"
"> >    ~~~\n"
"> >    # gapminder[1, 4, 5]\n"
"> >    gapminder[1, c(4, 5)]\n"
"> >    ~~~\n"
"> >    {: .language-r}\n"
"> >\n"
"> > 5. Advanced: extract rows that contain information for the years 2002\n"
"> >    and 2007\n"
"> >\n"
"> >     \n"
"> >     ~~~\n"
"> >     # gapminder[gapminder$year == 2002 | 2007,]\n"
"> >     gapminder[gapminder$year == 2002 | gapminder$year == 2007,]\n"
"> >     gapminder[gapminder$year %in% c(2002, 2007),]\n"
"> >     ~~~\n"
"> >     {: .language-r}"
msgstr ""

#: r-intro-geospatial/_episodes/05-data-subsetting.md:759
msgid ""
">\n"
"> 1. Why does `gapminder[1:20]` return an error? How does it differ from\n"
">    `gapminder[1:20, ]`?\n"
">\n"
"> 2. Create a new `data.frame` called `gapminder_small` that only contains rows\n"
"> 1 through 9 and 19 through 23. You can do this in one or two steps.\n"
">\n"
"> > ## Solution to challenge 4\n"
"> >\n"
"> > 1.  `gapminder` is a data.frame so needs to be subsetted on two dimensions. `gapminder[1:20, ]` subsets the data to give the first 20 rows and all columns.\n"
"> >\n"
"> > 2.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > gapminder_small <- gapminder[c(1:9, 19:23),]\n"
"> > ~~~\n"
"> > {: .language-r}"
msgstr ""
