# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Yurii Kleban, 2023
# vorontsoovaa, 2023
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2020-07-18 17:19:47+0100\n"
"PO-Revision-Date: 2020-07-18 16:29+0000\n"
"Last-Translator: vorontsoovaa, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/carpentries-i18n/teams/98915/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

# Front Matter
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1
msgid ""
"---\n"
"# Please do not edit this file directly; it is auto generated.\n"
"# Instead, please edit 03-data-structures-part1.md in _episodes_rmd/\n"
"title: \"Data Structures\"\n"
"teaching: 40\n"
"exercises: 15\n"
"questions:\n"
"- \"How can I read data in R?\"\n"
"- \"What are the basic data types in R?\"\n"
"- \"How do I represent categorical information in R?\"\n"
"objectives:\n"
"- \"To be aware of the different types of data.\"\n"
"- \"To begin exploring data frames, and understand how they are related to vectors, factors and lists.\"\n"
"- \"To be able to ask questions from R about the type, class, and structure of an object.\"\n"
"keypoints:\n"
"- \"Use `read.csv` to read tabular data in R.\"\n"
"- \"The basic data types in R are double, integer, complex, logical, and character.\"\n"
"- \"Use factors to represent categories in R.\"\n"
"source: Rmd\n"
"---"
msgstr ""

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:24
msgid ""
"One of R's most powerful features is its ability to deal with tabular data -\n"
"such as you may already have in a spreadsheet or a CSV file. Let's start by\n"
"downloading and reading in a file `nordic-data.csv`. We will\n"
"save this data as an object named `nordic`:"
msgstr ""
"Однією з найпотужніших функцій R є здатність мати справи з табличними даними -\n"
"такими, які ви вже можете мати в електронній таблиці або в файлі CSV. Почнемо з\n"
"завантаження і читання у файлі `nordic-data.csv`. Ми\n"
"збережемо ці дані, як об'єкт під назвою `nordic`:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:30
msgid ""
"~~~\n"
"nordic <- read.csv(\"data/nordic-data.csv\")\n"
"~~~"
msgstr ""
"~~~\n"
"nordic <- read.csv(\"data/nordic-data.csv\")\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:35
msgid ""
"The `read.table` function is used for reading in tabular data stored in a text\n"
"file where the columns of data are separated by punctuation characters such as\n"
"CSV files (csv = comma-separated values). Tabs and commas are the most common\n"
"punctuation characters used to separate or delimit data points in csv files.\n"
"For convenience R provides 2 other versions of `read.table`. These are: `read.csv`\n"
"for files where the data are separated with commas and `read.delim` for files\n"
"where the data are separated with tabs. Of these three functions `read.csv` is\n"
"the most commonly used.  If needed it is possible to override the default\n"
"delimiting punctuation marks for both `read.csv` and `read.delim`."
msgstr ""
"Функція `read.table` використовуєтьяс для читання табличних даних, що зберігаються в текстовому \n"
"файлі, де стовпці даних розділені пунктуаційними символами, такими як\n"
"файли CSV  (csv = значення, розділені комами). Табуляція і коми - найбільш поширені \n"
"пунктуаційні символи, що використовуються для розділення або розмежування точок даних у файлах csv.\n"
"Для зручності R надає 2 інші версії `read.table`.  Це: `read.csv`\n"
"для файлів, де дані розділені комами і `read.delim` для файлів,\n"
"де дані розділені табуляцією. Із цих трьох функцій `read.csv`\n"
"найчастіше використовується.  Якщо необхідно, можна перевизначити стандартне\n"
"розмежування знаків пунктуації для `read.csv` і `read.delim`."

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:45
msgid ""
"We can begin exploring our dataset right away, pulling out columns by specifying\n"
"them using the `$` operator:"
msgstr ""
"Ми можемо почати вивчати наш набір даних прямо зараз,  витягуючи стовпці, вказуючи\n"
"оператор `$`:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:49
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1015
msgid ""
"~~~\n"
"nordic$country\n"
"~~~"
msgstr ""
"~~~\n"
"nordic$country\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:56
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1022
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1036
msgid ""
"~~~\n"
"[1] \"Denmark\" \"Sweden\"  \"Norway\" \n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"Denmark\" \"Sweden\"  \"Norway\" \n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:63
msgid ""
"~~~\n"
"nordic$lifeExp\n"
"~~~"
msgstr ""
"~~~\n"
"nordic$lifeExp\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:70
msgid ""
"~~~\n"
"[1] 77.2 80.0 79.0\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 77.2 80.0 79.0\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:75
msgid ""
"We can do other operations on the columns. For example, if we discovered "
"that the life expectancy is two years higher: "
msgstr ""
"Ми можемо робити різні операції зі стовпцями. Наприклад, якщо ми виявили, що"
" тривалість життя на два роки вища: "

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:78
msgid ""
"~~~\n"
"nordic$lifeExp + 2\n"
"~~~"
msgstr ""
"~~~\n"
"nordic$lifeExp + 2\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:85
msgid ""
"~~~\n"
"[1] 79.2 82.0 81.0\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 79.2 82.0 81.0\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:90
msgid "But what about:"
msgstr "А як що до цього:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:93
msgid ""
"~~~\n"
"nordic$lifeExp + nordic$country\n"
"~~~"
msgstr ""
"~~~\n"
"nordic$lifeExp + nordic$country\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:100
msgid ""
"~~~\n"
"Error in nordic$lifeExp + nordic$country: non-numeric argument to binary operator\n"
"~~~"
msgstr ""
"~~~\n"
"Error in nordic$lifeExp + nordic$country: non-numeric argument to binary operator\n"
"~~~"

# SC/DC Template label
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:103
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:250
#: r-intro-geospatial/_episodes/04-data-structures-part2.md:398
msgid "{: .error}"
msgstr "{: .error}"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:105
msgid ""
"Understanding what happened here is key to successfully analyzing data in R."
msgstr ""
"Розуміння того, що тут сталося - це ключ до успішного аналізу даних в R.  "

# header
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:107
msgid "## Data Types"
msgstr "## Типи даних"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:109
msgid ""
"If you guessed that the last command will return an error because `77.2` plus\n"
"`\"Denmark\"` is nonsense, you're right - and you already have some intuition for an\n"
"important concept in programming called *data classes*. We can ask what class of\n"
"data something is:"
msgstr ""
"Якщо ви здогадались, що остання командаповерне помилку, тому що `77.2` +\n"
"`\"Denmark\"` це нісенітниця, і ви праві - і y вас вже є якась інтуїція для\n"
"важливої концепції під назвою *data classes*. Ми можемо запитати\n"
"який це клас даних:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:115
msgid ""
"~~~\n"
"class(nordic$lifeExp)\n"
"~~~"
msgstr ""
"~~~\n"
"class(nordic$lifeExp)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:122
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:137
msgid ""
"~~~\n"
"[1] \"numeric\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"numeric\"\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:127
msgid ""
"There are 6 main types: `numeric`, `integer`, `complex`, `logical`, "
"`character`, and `factor`."
msgstr ""
"У R є 6 основних типів даних: `numeric`, `integer`, `complex`, `logical`, "
"`character`, and `factor`."

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:130
msgid ""
"~~~\n"
"class(3.14)\n"
"~~~"
msgstr ""
"~~~\n"
"class(3.14)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:144
msgid ""
"~~~\n"
"class(1L) # The L suffix forces the number to be an integer, since by default R uses float numbers\n"
"~~~"
msgstr ""
"~~~\n"
"class(1L) # The L suffix forces the number to be an integer, since by default R uses float numbers\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:151
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:656
#: r-intro-geospatial/_episodes/04-data-structures-part2.md:107
msgid ""
"~~~\n"
"[1] \"integer\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"integer\"\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:158
msgid ""
"~~~\n"
"class(1+1i)\n"
"~~~"
msgstr ""
"~~~\n"
"class(1+1i)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:165
msgid ""
"~~~\n"
"[1] \"complex\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"complex\"\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:172
msgid ""
"~~~\n"
"class(TRUE)\n"
"~~~"
msgstr ""
"~~~\n"
"class(TRUE)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:179
msgid ""
"~~~\n"
"[1] \"logical\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"logical\"\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:186
msgid ""
"~~~\n"
"class('banana')\n"
"~~~"
msgstr ""
"~~~\n"
"class('banana')\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:193
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:231
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:835
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1050
#: r-intro-geospatial/_episodes/04-data-structures-part2.md:121
msgid ""
"~~~\n"
"[1] \"character\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"character\"\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:200
msgid ""
"~~~\n"
"class(factor('banana'))\n"
"~~~"
msgstr ""
"~~~\n"
"class(factor('banana'))\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:207
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:802
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:849
msgid ""
"~~~\n"
"[1] \"factor\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"factor\"\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:212
msgid ""
"No matter how\n"
"complicated our analyses become, all data in R is interpreted a specific \n"
"data class. This strictness has some really important consequences."
msgstr ""
"Не важливо від того, наскільки\n"
"складним стає наш аналіз, всі дані в R інтерпретуються  конкретним \n"
"класом даних. Ця строгість має деякі дійсно важливі наслідки."

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:216
msgid ""
"A user has added new details of age expectancy. This information is in the file\n"
"`data/nordic-data-2.csv`."
msgstr ""
"Користувач додав нові деталі у тривалості віку. Ця інформація у файлі\n"
"`data/nordic-data-2.csv`."

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:219
msgid ""
"Load the new nordic data as `nordic_2`, and check what class of data we find in the\n"
"`lifeExp` column:"
msgstr ""
"Завантажте нові дані як `nordic_2`, і перевірте, який клас даних у\n"
"колонці `lifeExp`:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:223
msgid ""
"~~~\n"
"nordic_2 <- read.csv(\"data/nordic-data-2.csv\")\n"
"class(nordic_2$lifeExp)\n"
"~~~"
msgstr ""
"~~~\n"
"nordic_2 <- read.csv(\"data/nordic-data-2.csv\")\n"
"class(nordic_2$lifeExp)\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:236
msgid ""
"Oh no, our life expectancy lifeExp aren't the numeric type anymore! If we try to do the same math\n"
"we did on them before, we run into trouble:"
msgstr ""
"О ні, наша очікувана тривалість життя lifeExp більше не є числовим типом! Якщо ми спробуємо обчислити їх так само,\n"
"як і раніше, ми зіткнемося з проблемами:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:240
msgid ""
"~~~\n"
"nordic_2$lifeExp + 2\n"
"~~~"
msgstr ""
"~~~\n"
"nordic_2$lifeExp + 2\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:247
msgid ""
"~~~\n"
"Error in nordic_2$lifeExp + 2: non-numeric argument to binary operator\n"
"~~~"
msgstr ""
"~~~\n"
"Error in nordic_2$lifeExp + 2: non-numeric argument to binary operator\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:252
msgid ""
"What happened? When R reads a csv file into one of these tables, it insists that\n"
"everything in a column be the same class; if it can't understand\n"
"*everything* in the column as numeric, then *nothing* in the column gets to be numeric. The table that R loaded our nordic data into is something called a\n"
"dataframe, and it is our first example of something called a *data\n"
"structure* - that is, a structure which R knows how to build out of the basic\n"
"data types."
msgstr ""
"Що сталося? Коли R зчитує файл csv в одну з цих таблиць, він наполягає на тому, щоб\n"
"усе в стовпці було одного класу; якщо він не може зрозуміти\n"
"*що все* в стовпці є числами, тоді *нічого* в стовпці не може бути числом. Таблиця, у яку R завантажив наші дані, називається\n"
"фреймом даних, і це наш перший приклад чогось, що називається *структура\n"
"даних* - тобто структура, яку R знає, як побудувати з основних \n"
"типів даних."

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:259
msgid ""
"We can see that it is a dataframe by calling the `class()` function on it:"
msgstr ""
"Ми можемо побачити, що це фрейм даних, викликавши на ньому функцію "
"`class()`:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:262
msgid ""
"~~~\n"
"class(nordic)\n"
"~~~"
msgstr ""
"~~~\n"
"class(nordic)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:269
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1095
#: r-intro-geospatial/_episodes/04-data-structures-part2.md:161
msgid ""
"~~~\n"
"[1] \"data.frame\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"data.frame\"\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:274
msgid ""
"In order to successfully use our data in R, we need to understand what the basic\n"
"data structures are, and how they behave. "
msgstr ""
"Щоб успішно використовувати наші дані в R, нам потрібно зрозуміти, що таке основні\n"
"структури даних і як вони поводяться. "

# header
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:277
msgid "## Vectors and Type Coercion"
msgstr "## Вектори та тип примусу"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:279
msgid ""
"To better understand this behavior, let's meet another of the data structures:\n"
"the vector."
msgstr ""
"Щоб краще зрозуміти цю поведінку, давайте познайомимося з іншою структурою даних:\n"
"вектор."

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:283
msgid ""
"~~~\n"
"my_vector <- vector(length = 3)\n"
"my_vector\n"
"~~~"
msgstr ""
"~~~\n"
"my_vector <- vector(length = 3)\n"
"my_vector\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:291
msgid ""
"~~~\n"
"[1] FALSE FALSE FALSE\n"
"~~~"
msgstr ""
"~~~\n"
"[1] FALSE FALSE FALSE\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:296
msgid ""
"A vector in R is essentially an ordered list of things, with the special\n"
"condition that everything in the vector must be the same basic data type. If\n"
"you don't choose the data type, it'll default to `logical`; or, you can declare\n"
"an empty vector of whatever type you like."
msgstr ""
"Вектор у R - це, по суті, впорядковний список речей, з особливою\n"
"умовою, що все у векторі має бути того самого типу даних. Якщо\n"
"ви не виберете тип даних, за умовчуванням буде `logical`; або, ви можете оголосити\n"
"порожній вектор будь-якого типу, який вам подобається."

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:302
msgid ""
"~~~\n"
"another_vector <- vector(mode = 'character', length = 3)\n"
"another_vector\n"
"~~~"
msgstr ""
"~~~\n"
"another_vector <- vector(mode = 'character', length = 3)\n"
"another_vector\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:310
msgid ""
"~~~\n"
"[1] \"\" \"\" \"\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"\" \"\" \"\"\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:315
msgid "You can check if something is a vector:"
msgstr "Ви можете перевірити, чи щось є вектором:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:318
msgid ""
"~~~\n"
"str(another_vector)\n"
"~~~"
msgstr ""
"~~~\n"
"str(another_vector)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:325
msgid ""
"~~~\n"
" chr [1:3] \"\" \"\" \"\"\n"
"~~~"
msgstr ""
"~~~\n"
" chr [1:3] \"\" \"\" \"\"\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:330
msgid ""
"The somewhat cryptic output from this command indicates the basic data type\n"
"found in this vector - in this case `chr`, character; an indication of the\n"
"number of things in the vector - actually, the indexes of the vector, in this\n"
"case `[1:3]`; and a few examples of what's actually in the vector - in this case\n"
"empty character strings. If we similarly do"
msgstr ""
"Дещо загадковий вихід цієї команди вказує на базовий тип даних,\n"
"хнайдений у цьому векторі - у цьому випадку `chr`, символ; вказівка на\n"
"кількість речей у векторі - власне, індекси вектора, в даному\n"
"випадку `[1:3]`; і кілька випадків того, що насправді є у векторі - у цьому випадку\n"
"порожні рядки символів. Якщо ми робимо так само "

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:337
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:717
msgid ""
"~~~\n"
"str(nordic$lifeExp)\n"
"~~~"
msgstr ""
"~~~\n"
"str(nordic$lifeExp)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:344
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:724
msgid ""
"~~~\n"
" num [1:3] 77.2 80 79\n"
"~~~"
msgstr ""
"~~~\n"
" num [1:3] 77.2 80 79\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:349
msgid ""
"we see that `nordic$lifeExp` is a vector, too - the columns of data we load into R\n"
"data frames are all vectors, and that's the root of why R forces everything in\n"
"a column to be the same basic data type."
msgstr ""
"ми бачимо, що `nordic$lifeExp` це теж вектор - усі стовпці даних, які ми завантажуємо у фрейми даних R,\n"
"є векторами, і це головна причина, чому R змушує, щоб все в \n"
"стовпці мало той самий базовий тип даних."

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:353
msgid "> ## Discussion 1"
msgstr "> ## Обговорення 1"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:354
msgid ""
">\n"
"> Why is R so opinionated about what we put in our columns of data?\n"
"> How does this help us?\n"
">\n"
"> > ## Discussion 1\n"
"> >\n"
"> > By keeping everything in a column the same, we allow ourselves to make simple\n"
"> > assumptions about our data; if you can interpret one entry in the column as a\n"
"> > number, then you can interpret *all* of them as numbers, so we don't have to\n"
"> > check every time. This consistency is what people mean when they talk about\n"
"> > *clean data*; in the long run, strict consistency goes a long way to making\n"
"> > our lives easier in R."
msgstr ""
">\n"
"> Чому R так самовпевнено ставиться до того, що ми розміщуємо в наших стовпцях даних\n"
"> Як нам це допомагає?\n"
">\n"
"> > ## Обговорення  1\n"
"> >\n"
"> > Зберігаючи все в стовпці однаковим, ми дозволяємо собі робити прості\n"
"> > припущення щодо наших даних; якщо ви можете інтерпретувати один запис у стовпці як \n"
"> > число, тоді ви можете інтерпретувати *усі* як числа, тому нам не потрібно\n"
"> > перевіряти кожного разу. Саме цю послідовність мають на увазі люди, коли говорять про\n"
"> > *очищені дані*;  Зрештою, сувора послідовність значною мірою\n"
"> > полегшує наше життя в R."

# SC/DC Template label
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:367
msgid "{: .discussion}"
msgstr "{: .discussion}"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:369
msgid ""
"You can also make vectors with explicit contents with the combine function:"
msgstr ""
"Ви також можете створювати вектори з явним вмістом за допомогою функції "
"об'єднання:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:372
msgid ""
"~~~\n"
"combine_vector <- c(2, 6, 3)\n"
"combine_vector\n"
"~~~"
msgstr ""
"~~~\n"
"combine_vector <- c(2, 6, 3)\n"
"combine_vector\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:380
msgid ""
"~~~\n"
"[1] 2 6 3\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 2 6 3\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:385
msgid ""
"Given what we've learned so far, what do you think the following will "
"produce?"
msgstr ""
"З огляду на те, що ми вже вивчили, яким, на вашу думку, буде результат "
"наступного?"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:388
msgid ""
"~~~\n"
"quiz_vector <- c(2, 6, '3')\n"
"~~~"
msgstr ""
"~~~\n"
"quiz_vector <- c(2, 6, '3')\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:393
msgid ""
"This is something called *type coercion*, and it is the source of many surprises\n"
"and the reason why we need to be aware of the basic data types and how R will\n"
"interpret them. When R encounters a mix of types (here numeric and character) to\n"
"be combined into a single vector, it will force them all to be the same\n"
"type. Consider:"
msgstr ""
"Це те, що називається *примусом типу* , і це джерело багатьох сюрпризів\n"
"і причина, чому ми повинні знати про основні типи даних і те, як R \n"
"їх інтерпретує. Коли R зустрічає комбінацію типів (числових і символьних)\n"
"які потрібно об’єднати в єдиний вектор, він змусить їх усіх бути одного\n"
"типу. Розглянемо:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:400
msgid ""
"~~~\n"
"coercion_vector <- c('a', TRUE)\n"
"coercion_vector\n"
"~~~"
msgstr ""
"~~~\n"
"coercion_vector <- c('a', TRUE)\n"
"coercion_vector\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:408
msgid ""
"~~~\n"
"[1] \"a\"    \"TRUE\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"a\"    \"TRUE\"\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:415
msgid ""
"~~~\n"
"another_coercion_vector <- c(0, TRUE)\n"
"another_coercion_vector\n"
"~~~"
msgstr ""
"~~~\n"
"another_coercion_vector <- c(0, TRUE)\n"
"another_coercion_vector\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:423
msgid ""
"~~~\n"
"[1] 0 1\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 0 1\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:428
msgid ""
"The coercion rules go: `logical` -> `integer` -> `numeric` -> `complex` ->\n"
"`character`, where -> can be read as *are transformed into*. You can try to\n"
"force coercion against this flow using the `as.` functions:"
msgstr ""
"Правила примусу виглядають так: `logical` -> `integer` -> `numeric` -> `complex` ->\n"
"`character`, де -> можна читати як,  *перетворюється на*. Ви можете спробувати\n"
"змусити цей потік за допомогою функції `as.`:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:433
msgid ""
"~~~\n"
"character_vector_example <- c('0', '2', '4')\n"
"character_vector_example\n"
"~~~"
msgstr ""
"~~~\n"
"character_vector_example <- c('0', '2', '4')\n"
"character_vector_example\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:441
msgid ""
"~~~\n"
"[1] \"0\" \"2\" \"4\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"0\" \"2\" \"4\"\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:448
msgid ""
"~~~\n"
"character_coerced_to_numeric <- as.numeric(character_vector_example)\n"
"character_coerced_to_numeric\n"
"~~~"
msgstr ""
"~~~\n"
"character_coerced_to_numeric <- as.numeric(character_vector_example)\n"
"character_coerced_to_numeric\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:456
msgid ""
"~~~\n"
"[1] 0 2 4\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 0 2 4\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:463
msgid ""
"~~~\n"
"numeric_coerced_to_logical <- as.logical(character_coerced_to_numeric)\n"
"numeric_coerced_to_logical\n"
"~~~"
msgstr ""
"~~~\n"
"numeric_coerced_to_logical <- as.logical(character_coerced_to_numeric)\n"
"numeric_coerced_to_logical\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:471
msgid ""
"~~~\n"
"[1] FALSE  TRUE  TRUE\n"
"~~~"
msgstr ""
"~~~\n"
"[1] FALSE  TRUE  TRUE\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:476
msgid ""
"As you can see, some surprising things can happen when R forces one basic data\n"
"type into another! Nitty-gritty of type coercion aside, the point is: if your\n"
"data doesn't look like what you thought it was going to look like, type coercion\n"
"may well be to blame; make sure everything is the same type in your vectors and\n"
"your columns of data frames, or you will get nasty surprises!"
msgstr ""
"Як ви можете бачити, деякі дивовижні речі можуть статися, коли R примусово перетворює один базовий \n"
"тип даних в інший! Залишаючи в стороні дрібниці примусу типів, головне: якщо ваші\n"
"дані виглядають не так, як ви думали, виною може бути\n"
"примус типів; переконайтеся, що все має однаковий тип у ваших векторах і\n"
"стовпцях кадрів даних, інакше ви отримаєте неприємні сюрпризи!"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:484
msgid "> Given what you now know about type conversion, look at the class of"
msgstr ""
"> Враховуючи те, що ви тепер знаєте про перетворення типів, подивіться на "
"клас"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:485
msgid ""
"> data in `nordic_2$lifeExp` and compare it with `nordic$lifeExp`. Why are"
msgstr ""
"> даних у `nordic_2$lifeExpта` порівняйте його з `nordic$lifeExp`. Чому"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:486
msgid "> these columns different classes? "
msgstr "> ці стовпці є різними класами?"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:488
msgid "> > ## Solution"
msgstr "> > ## Розв'язання"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:489
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:494
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:495
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:496
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:501
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:502
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:503
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:508
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:509
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:510
msgid "> > "
msgstr "> > "

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:490
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:492
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:497
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:499
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:504
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:506
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:511
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:513
msgid "> > ~~~"
msgstr "> > ~~~"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:491
msgid "> > str(nordic_2$lifeExp)"
msgstr "> > str(nordic_2$lifeExp)"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:493
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:507
msgid "> > {: .language-r}"
msgstr "> > {: .language-r}"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:498
msgid "> >  chr [1:3] \"77.2\" \"80\" \"79.0 or 83\""
msgstr "> >  chr [1:3] \"77.2\" \"80\" \"79.0 or 83\""

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:500
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:514
msgid "> > {: .output}"
msgstr "> > {: .output}"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:505
msgid "> > str(nordic$lifeExp)"
msgstr "> > str(nordic$lifeExp)"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:512
msgid "> >  num [1:3] 77.2 80 79"
msgstr "> >  num [1:3] 77.2 80 79"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:515
msgid "> > The data in `nordic_2$lifeExp` is stored as factors rather than "
msgstr "> > Дані в `nordic_2$lifeExp` зберігаються як множники, а не "

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:516
msgid "> > numeric. This is because of the \"or\" character string in the third "
msgstr "> > числові. Це через рядок символів \"або\" в третій"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:517
msgid "> > data point. \"Factor\" is R's special term for categorical data. "
msgstr ""
"> > точці даних. \n"
"\"Фактор\" — це спеціальний термін R для категоричних даних."

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:518
msgid "> > We will be working more with factor data later in this workshop."
msgstr ""
"> > Пізніше, на цьому семінарі, ми будемо більше працювати з факторними "
"даними."

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:522
msgid ""
"The combine function, `c()`, will also append things to an existing vector:"
msgstr ""
"Функція комбінування `c(), також додаватиме елементи до існуючого вектора:  "

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:525
msgid ""
"~~~\n"
"ab_vector <- c('a', 'b')\n"
"ab_vector\n"
"~~~"
msgstr ""
"~~~\n"
"ab_vector <- c('a', 'b')\n"
"ab_vector\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:533
msgid ""
"~~~\n"
"[1] \"a\" \"b\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"a\" \"b\"\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:540
msgid ""
"~~~\n"
"combine_example <- c(ab_vector, 'DC')\n"
"combine_example\n"
"~~~"
msgstr ""
"~~~\n"
"combine_example <- c(ab_vector, 'DC')\n"
"combine_example\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:548
msgid ""
"~~~\n"
"[1] \"a\"  \"b\"  \"DC\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"a\"  \"b\"  \"DC\"\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:553
msgid "You can also make series of numbers:"
msgstr "Ви також можете скласти ряд чисел:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:556
msgid ""
"~~~\n"
"my_series <- 1:10\n"
"my_series\n"
"~~~"
msgstr ""
"~~~\n"
"my_series <- 1:10\n"
"my_series\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:564
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:578
msgid ""
"~~~\n"
" [1]  1  2  3  4  5  6  7  8  9 10\n"
"~~~"
msgstr ""
"~~~\n"
" [1]  1  2  3  4  5  6  7  8  9 10\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:571
msgid ""
"~~~\n"
"seq(10)\n"
"~~~"
msgstr ""
"~~~\n"
"seq(10)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:585
msgid ""
"~~~\n"
"seq(1,10, by = 0.1)\n"
"~~~"
msgstr ""
"~~~\n"
"seq(1,10, by = 0.1)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:592
msgid ""
"~~~\n"
" [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4\n"
"[16]  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9\n"
"[31]  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4\n"
"[46]  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9\n"
"[61]  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4\n"
"[76]  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9\n"
"[91] 10.0\n"
"~~~"
msgstr ""
"~~~\n"
" [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4\n"
"[16]  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9\n"
"[31]  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4\n"
"[46]  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9\n"
"[61]  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4\n"
"[76]  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9\n"
"[91] 10.0\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:603
msgid "We can ask a few questions about vectors:"
msgstr "Ми можемо поставити кілька запитань про вектори:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:606
msgid ""
"~~~\n"
"sequence_example <- seq(10)\n"
"head(sequence_example,n = 2)\n"
"~~~"
msgstr ""
"~~~\n"
"sequence_example <- seq(10)\n"
"head(sequence_example,n = 2)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:614
msgid ""
"~~~\n"
"[1] 1 2\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 1 2\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:621
msgid ""
"~~~\n"
"tail(sequence_example, n = 4)\n"
"~~~"
msgstr ""
"~~~\n"
"tail(sequence_example, n = 4)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:628
msgid ""
"~~~\n"
"[1]  7  8  9 10\n"
"~~~"
msgstr ""
"~~~\n"
"[1]  7  8  9 10\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:635
msgid ""
"~~~\n"
"length(sequence_example)\n"
"~~~"
msgstr ""
"~~~\n"
"length(sequence_example)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:642
msgid ""
"~~~\n"
"[1] 10\n"
"~~~"
msgstr ""
"~~~\n"
"[1] 10\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:649
msgid ""
"~~~\n"
"class(sequence_example)\n"
"~~~"
msgstr ""
"~~~\n"
"class(sequence_example)\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:661
msgid "Finally, you can give names to elements in your vector:"
msgstr "Нарешті, ви можете дати назви елементам у вашому векторі: "

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:664
msgid ""
"~~~\n"
"my_example <- 5:8\n"
"names(my_example) <- c(\"a\", \"b\", \"c\", \"d\")\n"
"my_example\n"
"~~~"
msgstr ""
"~~~\n"
"my_example <- 5:8\n"
"names(my_example) <- c(\"a\", \"b\", \"c\", \"d\")\n"
"my_example\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:673
msgid ""
"~~~\n"
"a b c d \n"
"5 6 7 8 \n"
"~~~"
msgstr ""
"~~~\n"
"a b c d \n"
"5 6 7 8 \n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:681
msgid ""
"~~~\n"
"names(my_example)\n"
"~~~"
msgstr ""
"~~~\n"
"names(my_example)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:688
msgid ""
"~~~\n"
"[1] \"a\" \"b\" \"c\" \"d\"\n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"a\" \"b\" \"c\" \"d\"\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:694
msgid ""
">\n"
"> Start by making a vector with the numbers 1 through 26.\n"
"> Multiply the vector by 2, and give the resulting vector\n"
"> names A through Z (hint: there is a built in vector called `LETTERS`)\n"
">\n"
"> > ## Solution to Challenge 2\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > x <- 1:26\n"
"> > x <- x * 2\n"
"> > names(x) <- LETTERS\n"
"> > ~~~\n"
"> > {: .language-r}"
msgstr ""
">\n"
"> Почніть із створення вектора з числами від 1 до 26.\n"
"> Помножте вектор на 2 і дайте отриманому вектору\n"
"> назви від A до Z (підказка: є вбудований вектор під назвою  `LETTERS`)\n"
">\n"
"> > ## Розв'язання до завдання 2\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > x <- 1:26\n"
"> > x <- x * 2\n"
"> > names(x) <- LETTERS\n"
"> > ~~~\n"
"> > {: .language-r}"

# header
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:712
#: r-intro-geospatial/_episodes/04-data-structures-part2.md:487
msgid "## Factors"
msgstr "## Фактори"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:714
msgid "We said that columns in data frames were vectors:"
msgstr "Ми сказали, що стовпці в кадрах даних є векторами:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:731
msgid ""
"~~~\n"
"str(nordic$year)\n"
"~~~"
msgstr ""
"~~~\n"
"str(nordic$year)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:738
msgid ""
"~~~\n"
" int [1:3] 2002 2002 2002\n"
"~~~"
msgstr ""
"~~~\n"
" int [1:3] 2002 2002 2002\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:743
msgid "These make sense. But what about"
msgstr "Це має сенс. Але як що до цього"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:746
msgid ""
"~~~\n"
"str(nordic$country)\n"
"~~~"
msgstr ""
"~~~\n"
"str(nordic$country)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:753
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1064
msgid ""
"~~~\n"
" chr [1:3] \"Denmark\" \"Sweden\" \"Norway\"\n"
"~~~"
msgstr ""
"~~~\n"
" chr [1:3] \"Denmark\" \"Sweden\" \"Norway\"\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:758
msgid ""
"Another important data structure is called a factor. Factors look like character\n"
"data, but are used to represent categorical information. For example, let's make\n"
"a vector of strings labeling nordic countries for all the countries in our\n"
"study:"
msgstr ""
"Ще одна важлива структура даних називається фактором. Фактори виглядають як символьні\n"
"дані, але використовуються для представлення категоріальної інформації. Наприклад, створимо\n"
"вектор рядків, що позначає скандинавські країни для всіх країн нашого\n"
"дослідження:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:764
msgid ""
"~~~\n"
"nordic_countries <- c('Norway', 'Finland', 'Denmark', 'Iceland', 'Sweden')\n"
"nordic_countries\n"
"~~~"
msgstr ""
"~~~\n"
"nordic_countries <- c('Norway', 'Finland', 'Denmark', 'Iceland', 'Sweden')\n"
"nordic_countries\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:772
msgid ""
"~~~\n"
"[1] \"Norway\"  \"Finland\" \"Denmark\" \"Iceland\" \"Sweden\" \n"
"~~~"
msgstr ""
"~~~\n"
"[1] \"Norway\"  \"Finland\" \"Denmark\" \"Iceland\" \"Sweden\" \n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:779
msgid ""
"~~~\n"
"str(nordic_countries)\n"
"~~~"
msgstr ""
"~~~\n"
"str(nordic_countries)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:786
msgid ""
"~~~\n"
" chr [1:5] \"Norway\" \"Finland\" \"Denmark\" \"Iceland\" \"Sweden\"\n"
"~~~"
msgstr ""
"~~~\n"
" chr [1:5] \"Norway\" \"Finland\" \"Denmark\" \"Iceland\" \"Sweden\"\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:791
msgid "We can turn a vector into a factor like so:"
msgstr "Ми можемо перетворити вектор у множник таким способом:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:794
msgid ""
"~~~\n"
"categories <- factor(nordic_countries)\n"
"class(categories)\n"
"~~~"
msgstr ""
"~~~\n"
"categories <- factor(nordic_countries)\n"
"class(categories)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:809
msgid ""
"~~~\n"
"str(categories)\n"
"~~~"
msgstr ""
"~~~\n"
"str(categories)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:816
msgid ""
"~~~\n"
" Factor w/ 5 levels \"Denmark\",\"Finland\",..: 4 2 1 3 5\n"
"~~~"
msgstr ""
"~~~\n"
" Factor w/ 5 levels \"Denmark\",\"Finland\",..: 4 2 1 3 5\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:821
msgid ""
"Now R has noticed that there are 5 possible categories in our data - but it\n"
"also did something surprising; instead of printing out the strings we gave it,\n"
"we got a bunch of numbers instead. R has replaced our human-readable categories\n"
"with numbered indices under the hood, this is necessary as many statistical\n"
"calculations utilise such numerical representations for categorical data:"
msgstr ""
"Тепер R помітив, що в наших даних є 5 можливих категорій, але він\n"
"також зробив дещо дивовижне; замість того, щоб роздрукувати рядки, які ми йому дали,\n"
"натомість ми отримали купу чисел. R замінив наші зрозумілі людині категорії\n"
"нумерованими індексами під капотом, це необхідно, оскільки багато статистичних\n"
"розрахунків використовують такі числові представлення категоріальних даних:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:828
msgid ""
"~~~\n"
"class(nordic_countries)\n"
"~~~"
msgstr ""
"~~~\n"
"class(nordic_countries)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:842
msgid ""
"~~~\n"
"class(categories)\n"
"~~~"
msgstr ""
"~~~\n"
"class(categories)\n"
"~~~"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:854
msgid "> ## Challenge"
msgstr "> ## Завдання"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:855
msgid ""
">\n"
"> Can you guess why these numbers are used to represent these countries?\n"
">\n"
">> ## Solution\n"
">> \n"
">> They are sorted in alphabetical order"
msgstr ""
">\n"
"> Чи можете ви здогадатися, чому ці цифри використовуються для позначення цих країн?\n"
">\n"
">> ## Розв'язання\n"
">> \n"
">> Вони відсортовані в алфавітному порядку"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:865
msgid ""
">\n"
"> Is there a factor in our `nordic` data frame? what is its name? Try using\n"
"> `?read.csv` to figure out how to keep text columns as character vectors\n"
"> instead of factors; then write a command or two to show that the factor in\n"
"> `nordic` is actually a character vector when loaded in this way.\n"
">\n"
"> > ## Solution to Challenge 3\n"
"> >\n"
"> > One solution is use the argument `stringAsFactors`:\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic <- read.csv(file = \"data/nordic-data.csv\", stringsAsFactors = FALSE)\n"
"> > str(nordic$country)\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> >\n"
"> > Another solution is use the argument `colClasses`\n"
"> > that allow finer control.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic <- read.csv(file=\"data/nordic-data.csv\", colClasses=c(NA, NA, \"character\"))\n"
"> > str(nordic$country)\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> >\n"
"> > Note: new students find the help files difficult to understand; make sure to let them know\n"
"> > that this is typical, and encourage them to take their best guess based on semantic meaning,\n"
"> > even if they aren't sure."
msgstr ""
">\n"
"> Чи є фактор у нашому `nordic` кадрі даних? як воно називається? Спробуйте використати \n"
"> `?read.csv` щоб зрозуміти, як зберегти текстові стовпці як символьні вектори\n"
"> замість факторів; потім напишіть одну-дві команди, щоб показати, що множник\n"
"> `nordic` насправді є символьним вектором, коли завантажується таким чином.\n"
">\n"
"> > ## Розв'язання до завдання 3\n"
"> >\n"
"> > Одним із рішень є використання аргументу `stringAsFactors`:\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic <- read.csv(file = \"data/nordic-data.csv\", stringsAsFactors = FALSE)\n"
"> > str(nordic$country)\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> >\n"
"> > Іншим рішенням є використання аргументу `colClasses`\n"
"> > який дозволяє точніше контролювати.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic <- read.csv(file=\"data/nordic-data.csv\", colClasses=c(NA, NA, \"character\"))\n"
"> > str(nordic$country)\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> >\n"
"> > Примітка: новачкам важко зрозуміти файли довідки; не забудьте повідомити їм,\n"
"> > що це типово, і заохочуйте їх робити найкращі припущення на основі семантичного значення,\n"
"> > навіть якщо вони не впевнені."

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:898
msgid ""
"When doing statistical modelling, it's important to know what the baseline\n"
"levels are. This is assumed to be the first factor, but by default factors are\n"
"labeled in alphabetical order. You can change this by specifying the levels:"
msgstr ""
"Виконуючи статистичне моделювання, важливо знати, що таке базові рівні. \n"
"Передбачається, що це перший фактор, але за замовчуванням фактори \n"
"позначені в алфавітному порядку. Ви можете змінити це, вказавши рівні:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:903
msgid ""
"~~~\n"
"mydata <- c(\"case\", \"control\", \"control\", \"case\")\n"
"factor_ordering_example <- factor(mydata, levels = c(\"control\", \"case\"))\n"
"str(factor_ordering_example)\n"
"~~~"
msgstr ""
"~~~\n"
"mydata <- c(\"case\", \"control\", \"control\", \"case\")\n"
"factor_ordering_example <- factor(mydata, levels = c(\"control\", \"case\"))\n"
"str(factor_ordering_example)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:912
msgid ""
"~~~\n"
" Factor w/ 2 levels \"control\",\"case\": 2 1 1 2\n"
"~~~"
msgstr ""
"~~~\n"
" Factor w/ 2 levels \"control\",\"case\": 2 1 1 2\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:917
msgid ""
"In this case, we've explicitly told R that \"control\" should represented by 1,\n"
"and \"case\" by 2. This designation can be very important for interpreting the\n"
"results of statistical models!"
msgstr ""
"У цьому випадку ми чітко сказали R, що \"control\" має бути представлений 1,\n"
"і \"case\" - 2. Це позначення може бути дуже важливим для інтерпретації\n"
"результатів статистичних моделей!"

# header
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:921
msgid "## Lists"
msgstr "## Списки"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:923
msgid ""
"Another data structure you'll want in your bag of tricks is the `list`. A list\n"
"is simpler in some ways than the other types, because you can put anything you\n"
"want in it:"
msgstr ""
"Інша структура даних, яка вам знадобиться у вашій сумці хитрощів, це `list`. Список\n"
"дещо простіший, ніж інші типи, тому що ви можете додати до нього все,\n"
"що завгодно:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:928
msgid ""
"~~~\n"
"list_example <- list(1, \"a\", TRUE, c(2, 6, 7))\n"
"list_example\n"
"~~~"
msgstr ""
"~~~\n"
"list_example <- list(1, \"a\", TRUE, c(2, 6, 7))\n"
"list_example\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:936
msgid ""
"~~~\n"
"[[1]]\n"
"[1] 1\n"
"\n"
"[[2]]\n"
"[1] \"a\"\n"
"\n"
"[[3]]\n"
"[1] TRUE\n"
"\n"
"[[4]]\n"
"[1] 2 6 7\n"
"~~~"
msgstr ""
"~~~\n"
"[[1]]\n"
"[1] 1\n"
"\n"
"[[2]]\n"
"[1] \"a\"\n"
"\n"
"[[3]]\n"
"[1] TRUE\n"
"\n"
"[[4]]\n"
"[1] 2 6 7\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:953
msgid ""
"~~~\n"
"another_list <- list(title = \"Numbers\", numbers = 1:10, data = TRUE )\n"
"another_list\n"
"~~~"
msgstr ""
"~~~\n"
"another_list <- list(title = \"Numbers\", numbers = 1:10, data = TRUE )\n"
"another_list\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:961
msgid ""
"~~~\n"
"$title\n"
"[1] \"Numbers\"\n"
"\n"
"$numbers\n"
" [1]  1  2  3  4  5  6  7  8  9 10\n"
"\n"
"$data\n"
"[1] TRUE\n"
"~~~"
msgstr ""
"~~~\n"
"$title\n"
"[1] \"Numbers\"\n"
"\n"
"$numbers\n"
" [1]  1  2  3  4  5  6  7  8  9 10\n"
"\n"
"$data\n"
"[1] TRUE\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:973
msgid ""
"We can now understand something a bit surprising in our data frame; what "
"happens if we compare `str(nordic)` and `str(another_list)`:"
msgstr ""
"Тепер ми можемо зрозуміти дещо дивовижне у нашому кадрі даних; що станеться,"
" якщо порівняти `str(nordic)` і `str(another_list)`:"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:976
msgid ""
"~~~\n"
"str(nordic)\n"
"~~~"
msgstr ""
"~~~\n"
"str(nordic)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:983
msgid ""
"~~~\n"
"'data.frame':\t3 obs. of  3 variables:\n"
" $ country: chr  \"Denmark\" \"Sweden\" \"Norway\"\n"
" $ year   : int  2002 2002 2002\n"
" $ lifeExp: num  77.2 80 79\n"
"~~~"
msgstr ""
"~~~\n"
"'data.frame':\t3 obs. of  3 variables:\n"
" $ country: chr  \"Denmark\" \"Sweden\" \"Norway\"\n"
" $ year   : int  2002 2002 2002\n"
" $ lifeExp: num  77.2 80 79\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:993
msgid ""
"~~~\n"
"str(another_list)\n"
"~~~"
msgstr ""
"~~~\n"
"str(another_list)\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1000
msgid ""
"~~~\n"
"List of 3\n"
" $ title  : chr \"Numbers\"\n"
" $ numbers: int [1:10] 1 2 3 4 5 6 7 8 9 10\n"
" $ data   : logi TRUE\n"
"~~~"
msgstr ""
"~~~\n"
"List of 3\n"
" $ title  : chr \"Numbers\"\n"
" $ numbers: int [1:10] 1 2 3 4 5 6 7 8 9 10\n"
" $ data   : logi TRUE\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1008
msgid ""
"We see that the output for these two objects look very similar. It is because\n"
"data frames are lists 'under the hood'. Data frames are a special case of lists where each element (the columns of the data frame) have the same lengths."
msgstr ""
"Ми бачимо, що вихід для цих двох об’єктів виглядає дуже схожим. Це тому, що\n"
"фрейми даних є списками 'under the hood'. Фрейми даних є окремим випадком списків, де кожен елемент (стовпці фрейму даних) мають однакову довжину."

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1011
msgid ""
"In our `nordic` example, we have an integer, a double and a logical variable. As\n"
"we have seen already, each column of data frame is a vector."
msgstr ""
"У нашому прикладі `nordic`, ми маємо ціле число, подвійну та логічну змінну. Як\n"
"ми вже бачили, кожен стовпець кадру даних є вектором."

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1029
msgid ""
"~~~\n"
"nordic[, 1]\n"
"~~~"
msgstr ""
"~~~\n"
"nordic[, 1]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1043
msgid ""
"~~~\n"
"class(nordic[, 1])\n"
"~~~"
msgstr ""
"~~~\n"
"class(nordic[, 1])\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1057
msgid ""
"~~~\n"
"str(nordic[, 1])\n"
"~~~"
msgstr ""
"~~~\n"
"str(nordic[, 1])\n"
"~~~"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1069
msgid ""
"Each row is an *observation* of different variables, itself a data frame, and\n"
"thus can be composed of elements of different types."
msgstr ""
"Кожен рядок є *спостереженням* різних змінних, сам по собі є фреймом даних, і\n"
"тому може складатися з елементів різних типів."

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1073
msgid ""
"~~~\n"
"nordic[1, ]\n"
"~~~"
msgstr ""
"~~~\n"
"nordic[1, ]\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1080
msgid ""
"~~~\n"
"  country year lifeExp\n"
"1 Denmark 2002    77.2\n"
"~~~"
msgstr ""
"~~~\n"
"  country year lifeExp\n"
"1 Denmark 2002    77.2\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1088
msgid ""
"~~~\n"
"class(nordic[1, ])\n"
"~~~"
msgstr ""
"~~~\n"
"class(nordic[1, ])\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1102
msgid ""
"~~~\n"
"str(nordic[1, ])\n"
"~~~"
msgstr ""
"~~~\n"
"str(nordic[1, ])\n"
"~~~"

# code block
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1109
msgid ""
"~~~\n"
"'data.frame':\t1 obs. of  3 variables:\n"
" $ country: chr \"Denmark\"\n"
" $ year   : int 2002\n"
" $ lifeExp: num 77.2\n"
"~~~"
msgstr ""
"~~~\n"
"'data.frame':\t1 obs. of  3 variables:\n"
" $ country: chr \"Denmark\"\n"
" $ year   : int 2002\n"
" $ lifeExp: num 77.2\n"
"~~~"

# blockquote, which can be cascaded
#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1117
#: r-intro-geospatial/_episodes/05-data-subsetting.md:758
msgid "> ## Challenge 4"
msgstr "> ## Завдання 4"

#: r-intro-geospatial/_episodes/03-data-structures-part1.md:1118
msgid ""
">\n"
"> There are several subtly different ways to call variables, observations and\n"
"> elements from data frames:\n"
">\n"
"> - `nordic[1]`\n"
"> - `nordic[[1]]`\n"
"> - `nordic$country`\n"
"> - `nordic[\"country\"]`\n"
"> - `nordic[1, 1]`\n"
"> - `nordic[, 1]`\n"
"> - `nordic[1, ]`\n"
">\n"
"> Try out these examples and explain what is returned by each one.\n"
">\n"
"> *Hint:* Use the function `class()` to examine what is returned in each case.\n"
">\n"
"> > ## Solution to Challenge 4\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[1]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   country\n"
"> > 1 Denmark\n"
"> > 2  Sweden\n"
"> > 3  Norway\n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > We can think of a data frame as a list of vectors. The single brace `[1]`\n"
"> > returns the first slice of the list, as another list. In this case it is the\n"
"> > first column of the data frame.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[[1]]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> > [1] \"Denmark\" \"Sweden\"  \"Norway\" \n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > The double brace `[[1]]` returns the contents of the list item. In this case\n"
"> > it is the contents of the first column, a _vector_ of type _factor_.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic$country\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> > [1] \"Denmark\" \"Sweden\"  \"Norway\" \n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > This example uses the `$` character to address items by name. _coat_ is the\n"
"> > first column of the data frame, again a _vector_ of type _factor_.\n"
"> X\n"
"> > \n"
"> > ~~~\n"
"> > nordic[\"country\"]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   country\n"
"> > 1 Denmark\n"
"> > 2  Sweden\n"
"> > 3  Norway\n"
"> > ~~~\n"
"> > {: .output}\n"
"> > Here we are using a single brace `[\"country\"]` replacing the index number\n"
"> > with the column name. Like example 1, the returned object is a _list_.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[1, 1]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> > [1] \"Denmark\"\n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > This example uses a single brace, but this time we provide row and column\n"
"> coordinates. The returned object is the value in row 1, column 1. The object\n"
"> is an _integer_ but because it is part of a _vector_ of type _factor_, R\n"
"> displays the label \"Denmark\" associated with the integer value.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[, 1]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> > [1] \"Denmark\" \"Sweden\"  \"Norway\" \n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > Like the previous example we use single braces and provide row and column\n"
"> > coordinates. The row coordinate is not specified, R interprets this missing\n"
"> > value as all the elements in this _column_ _vector_.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[1, ]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   country year lifeExp\n"
"> > 1 Denmark 2002    77.2\n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > Again we use the single brace with row and column coordinates. The column\n"
"> > coordinate is not specified. The return value is a _list_ containing all the\n"
"> > values in the first row."
msgstr ""
">\n"
"> Існує кілька тонко різних способів виклику змінних, спостережень і\n"
"> елементів із фрейму даних:\n"
">\n"
"> - `nordic[1]`\n"
"> - `nordic[[1]]`\n"
"> - `nordic$country`\n"
"> - `nordic[\"country\"]`\n"
"> - `nordic[1, 1]`\n"
"> - `nordic[, 1]`\n"
"> - `nordic[1, ]`\n"
">\n"
"> Спробуйте ці приклади та поясніть, що повертає кожен із них.\n"
">\n"
"> *Підказка:* скористайтеся функцією `class()` щоб перевірити, що повертається в кожному випадку.\n"
">\n"
"> > ## Розв'язання до завдання 4\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[1]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   country\n"
"> > 1 Denmark\n"
"> > 2  Sweden\n"
"> > 3  Norway\n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > Ми можемо розглядати фрейм даних як список векторів. Одинарна дужка `[1]`\n"
"> > повертає перший фрагмент списку як інший список. У цьому випадку це\n"
"> > перший стовпець фрейму даних.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[[1]]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> > [1] \"Denmark\" \"Sweden\"  \"Norway\" \n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > Подвійна дужка `[[1]]` повертає вміст елемента списку. У цьому випадку\n"
"> > це вміст першого стовпця,, a _vector_ типу _factor_.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic$country\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> > [1] \"Denmark\" \"Sweden\"  \"Norway\" \n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > У цьому прикладі використовується символ `$`  для адресації елементів за назвою. _coat_ є\n"
"> > першим стовпцем фрейму даних, знову _vector_ типу _factor_.\n"
"> X\n"
"> > \n"
"> > ~~~\n"
"> > nordic[\"country\"]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   country\n"
"> > 1 Denmark\n"
"> > 2  Sweden\n"
"> > 3  Norway\n"
"> > ~~~\n"
"> > {: .output}\n"
"> > Тут ми використовуємо одну дужку, `[\"country\"]` яка замінює номер індексу\n"
"> > назвою стовпця. Як у прикладі 1, повернутий об'єкт -  _list_.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[1, 1]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> > [1] \"Denmark\"\n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > У цьому прикладі використовується одна дужка, але цього разу ми надаємо координати рядків і стовпців.\n"
"> Повернутий об’єкт – це значення в рядку 1, стовпці 1. Об’єкт\n"
"> є _integer_, але оскільки він є частиною _vector_ типу _factor_, R\n"
"> відображає мітку \"Denmark\" пов'язану з цілим значенням.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[, 1]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> > [1] \"Denmark\" \"Sweden\"  \"Norway\" \n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > Як і в попередньому прикладі, ми використовуємо одинарні дужки та надаємо координати рядків і стовпців.\n"
"> > Координата рядка не вказана, R інтерпретує це відсутнє\n"
"> > значення як усі елементи цього _column_ _vector_.\n"
"> >\n"
"> > \n"
"> > ~~~\n"
"> > nordic[1, ]\n"
"> > ~~~\n"
"> > {: .language-r}\n"
"> > \n"
"> > \n"
"> > \n"
"> > ~~~\n"
"> >   country year lifeExp\n"
"> > 1 Denmark 2002    77.2\n"
"> > ~~~\n"
"> > {: .output}\n"
"> >\n"
"> > Знову ми використовуємо одну фігурну дужку з координатами рядків і стовпців.\n"
"> > Координата колони не вказана. Повернене значення - це _list_, що містить\n"
"> > усі значення в першому рядку."
