# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Olexandr Konovalov, 2023
# Maryna Raievska, 2023
#
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2023-10-14 13:03:05+0100\n"
"PO-Revision-Date: 2023-02-12 17:54+0000\n"
"Last-Translator: Maryna Raievska, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/carpentries-i18n/"
"teams/98915/uk/)\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

# Front Matter
#: gap-lesson/_episodes/05-small-groups.md:1
msgid ""
"---\n"
"title: \"Small groups search\"\n"
"teaching: 40\n"
"exercises: 15\n"
"questions:\n"
"- \"Modular programming: putting functions together\"\n"
"- \"How to check some conjecture for all groups of a given order\"\n"
"objectives:\n"
"- \"Using the Small Groups Library\"\n"
"- \"Designing a system of functions to fit together\"\n"
"keypoints:\n"
"- \"Organise the code into functions.\"\n"
"- \"Create small groups one by one instead of producing a huge list of them."
"\"\n"
"- \"Using `SmallGroupsInformation` may help to reduce the search space.\"\n"
"- \"GAP is not a magic tool: theoretical knowledge may help much more than "
"the brute-force approach.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Пошук малих груп\"\n"
"teaching: 40\n"
"exercises: 15\n"
"questions:\n"
"- \"Модульне програмування: поєднання функцій разом\"\n"
"- \"Як перевірити деяку гіпотезу для всіх груп заданого порядку\"\n"
"objectives:\n"
"- \"Використовуючи Small Groups Library\"\n"
"- \"Розробка системи функцій, яка сумісна\"\n"
"keypoints:\n"
"- \"Організуйте код у функції.\"\n"
"- \"Створюйте малі групи одну за одною замість того, щоб створювати їх "
"величезний список.\"\n"
"- \"Використання `SmallGroupsInformation` може допомогти зменшити простір "
"пошуку.\"\n"
"- \"GAP не є чарівним інструментом: теоретичні знання можуть допомогти "
"набагато більше, ніж підхід грубої сили.\"\n"
"---"

#: gap-lesson/_episodes/05-small-groups.md:18
msgid ""
"In this section, we wish to discover some non-trivial groups with an "
"interesting\n"
"property: namely, that the average order of their elements is an integer."
msgstr ""
"У цьому розділі ми хочемо відкрити деякі нетривіальні групи з цікавою\n"
"властивістю, а саме, що середній порядок їхніх елементів є цілим числом."

#: gap-lesson/_episodes/05-small-groups.md:21
msgid ""
"The GAP distribution includes a number of data libraries (see an overview\n"
"[here](http://www.gap-system.org/Datalib/datalib.html)). One of them is\n"
"the [Small Groups Library](http://www.gap-system.org/Packages/sgl.html) by\n"
"Hans Ulrich Besche, Bettina Eick and Eamonn O'Brien."
msgstr ""
"Дистрибутив GAP включає низку бібліотек даних (див. огляд\n"
"[here](http://www.gap-system.org/Datalib/datalib.html)). Однією з них є\n"
"[Small Groups Library](http://www.gap-system.org/Packages/sgl.html) Ганса "
"Ульріха Беше, Беттіни Айк та Імона О'Брайена."

#: gap-lesson/_episodes/05-small-groups.md:26
msgid ""
"This library provides various utilities to determine which information\n"
"is stored there and submit queries to search for groups with desired\n"
"properties. The key functions are `SmallGroup`, `AllSmallGroups`,\n"
"`NrSmallGroups`, `SmallGroupsInformation` and `IdGroup`. For example:"
msgstr ""
"Ця бібліотека надає різні утиліти для визначення того, яка інформація\n"
"там зберігається, і надсилання запитів для пошуку груп із потрібними\n"
"властивостями. Ключовими функціями є `SmallGroup`, `AllSmallGroups`,\n"
"`NrSmallGroups`, `SmallGroupsInformation` та `IdGroup`. Наприклад:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:31
msgid ""
"~~~\n"
"gap> NrSmallGroups(64);\n"
"267\n"
"gap> SmallGroupsInformation(64);\n"
"\n"
"  There are 267 groups of order 64.\n"
"  They are sorted by their ranks.\n"
"     1 is cyclic.\n"
"     2 - 54 have rank 2.\n"
"     55 - 191 have rank 3.\n"
"     192 - 259 have rank 4.\n"
"     260 - 266 have rank 5.\n"
"     267 is elementary abelian.\n"
"\n"
"  For the selection functions the values of the following attributes\n"
"  are precomputed and stored:\n"
"     IsAbelian, PClassPGroup, RankPGroup, FrattinifactorSize and\n"
"     FrattinifactorId.\n"
"\n"
"  This size belongs to layer 2 of the SmallGroups library.\n"
"  IdSmallGroup is available for this size.\n"
"\n"
"gap> G:=SmallGroup(64,2);\n"
"<pc group of size 64 with 6 generators>\n"
"gap> AllSmallGroups(Size,64,NilpotencyClassOfGroup,5);\n"
"[ <pc group of size 64 with 6 generators>, <pc group of size 64 with 6 "
"generators>,\n"
"  <pc group of size 64 with 6 generators> ]\n"
"gap> List(last,IdGroup);\n"
"[ [ 64, 52 ], [ 64, 53 ], [ 64, 54 ] ]\n"
"~~~"
msgstr ""
"~~~\n"
"gap> NrSmallGroups(64);\n"
"267\n"
"gap> SmallGroupsInformation(64);\n"
"\n"
"  There are 267 groups of order 64.\n"
"  They are sorted by their ranks.\n"
"     1 is cyclic.\n"
"     2 - 54 have rank 2.\n"
"     55 - 191 have rank 3.\n"
"     192 - 259 have rank 4.\n"
"     260 - 266 have rank 5.\n"
"     267 is elementary abelian.\n"
"\n"
"  For the selection functions the values of the following attributes\n"
"  are precomputed and stored:\n"
"     IsAbelian, PClassPGroup, RankPGroup, FrattinifactorSize and\n"
"     FrattinifactorId.\n"
"\n"
"  This size belongs to layer 2 of the SmallGroups library.\n"
"  IdSmallGroup is available for this size.\n"
"\n"
"gap> G:=SmallGroup(64,2);\n"
"<pc group of size 64 with 6 generators>\n"
"gap> AllSmallGroups(Size,64,NilpotencyClassOfGroup,5);\n"
"[ <pc group of size 64 with 6 generators>, <pc group of size 64 with 6 "
"generators>,\n"
"  <pc group of size 64 with 6 generators> ]\n"
"gap> List(last,IdGroup);\n"
"[ [ 64, 52 ], [ 64, 53 ], [ 64, 54 ] ]\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:63
msgid ""
"We would like to use our own testing function, which we will create here,\n"
"using inline notation (available for one-argument functions):"
msgstr ""
"Ми хотіли б використати нашу власну функцію тестування, яку ми створимо "
"тут,\n"
"використовуючи вбудовану нотацію (доступну для функцій з одним аргументом):"

# code block
#: gap-lesson/_episodes/05-small-groups.md:66
msgid ""
"~~~\n"
"TestOneGroup := G -> IsInt( AvgOrdOfGroup(G) );\n"
"~~~"
msgstr ""
"~~~\n"
"TestOneGroup := G -> IsInt( AvgOrdOfGroup(G) );\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:71
msgid "Now try, for example"
msgstr "Тепер спробуйте, наприклад,"

# code block
#: gap-lesson/_episodes/05-small-groups.md:73
msgid ""
"~~~\n"
"List([TrivialGroup(),Group((1,2))],TestOneGroup);\n"
"~~~"
msgstr ""
"~~~\n"
"List([TrivialGroup(),Group((1,2))],TestOneGroup);\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:78
msgid ""
"~~~\n"
"[ true, false ]\n"
"~~~"
msgstr ""
"~~~\n"
"[ true, false ]\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:83
msgid ""
"~~~\n"
"gap> AllSmallGroups(Size,24,TestOneGroup,true);\n"
"~~~"
msgstr ""
"~~~\n"
"gap> AllSmallGroups(Size,24,TestOneGroup,true);\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:88
msgid ""
"~~~\n"
"[ ]\n"
"~~~"
msgstr ""
"~~~\n"
"[ ]\n"
"~~~"

# blockquote, which can be cascaded
#: gap-lesson/_episodes/05-small-groups.md:93
msgid "> ## Modular programming begins here"
msgstr "> ## Тут починається модульне програмування"

#: gap-lesson/_episodes/05-small-groups.md:94
msgid ""
">\n"
"> Why is returning booleans a good design decision for such functions,\n"
"> instead of just printing information or returning a string such as "
"`\"YES\"` ?"
msgstr ""
">\n"
"> Чому повернення логічних значень є хорошим проєктним рішенням для таких "
"функцій, \n"
"> замість того, щоб просто друкувати інформацію чи повертати рядок, "
"наприклад `\"YES\"`?"

#: gap-lesson/_episodes/05-small-groups.md:99
msgid ""
"This is a simple example of a function which tests all groups of a given "
"order.\n"
"It creates one group at a time, checks the desired property, and returns as "
"soon\n"
"as an example is discovered. Otherwise it returns `fail` which is a special "
"kind\n"
"of boolean variable in GAP."
msgstr ""
"Це простий приклад функції, яка перевіряє всі групи заданого порядку.\n"
"Він створює одну групу за раз, перевіряє потрібну властивість і "
"повертається, щойно \n"
"буде виявлено приклад. В іншому випадку він повертає `fail`, який є "
"особливим типом\n"
" логічної змінної в GAP."

# code block
#: gap-lesson/_episodes/05-small-groups.md:104
msgid ""
"~~~\n"
"TestOneOrderEasy := function(n)\n"
"local i;\n"
"for i in [1..NrSmallGroups(n)] do\n"
"  if TestOneGroup( SmallGroup( n, i ) ) then\n"
"    return [n,i];\n"
"  fi;\n"
"od;\n"
"return fail;\n"
"end;\n"
"~~~"
msgstr ""
"~~~\n"
"TestOneOrderEasy := function(n)\n"
"local i;\n"
"for i in [1..NrSmallGroups(n)] do\n"
"  if TestOneGroup( SmallGroup( n, i ) ) then\n"
"    return [n,i];\n"
"  fi;\n"
"od;\n"
"return fail;\n"
"end;\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:117
#: gap-lesson/_episodes/05-small-groups.md:169
msgid "For example,"
msgstr "Наприклад,"

# code block
#: gap-lesson/_episodes/05-small-groups.md:119
msgid ""
"~~~\n"
"TestOneOrderEasy(1);\n"
"~~~"
msgstr ""
"~~~\n"
"TestOneOrderEasy(1);\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:124
msgid ""
"~~~\n"
"[ 1, 1 ]\n"
"~~~"
msgstr ""
"~~~\n"
"[ 1, 1 ]\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:129
msgid ""
"~~~\n"
"TestOneOrderEasy(24);\n"
"~~~"
msgstr ""
"~~~\n"
"TestOneOrderEasy(24);\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:134
#: gap-lesson/_extras/discuss.md:169
msgid ""
"~~~\n"
"fail\n"
"~~~"
msgstr ""
"~~~\n"
"fail\n"
"~~~"

# blockquote, which can be cascaded
#: gap-lesson/_episodes/05-small-groups.md:139
msgid "> ## `AllSmallGroups` runs out of memory -- what to do?"
msgstr "`AllSmallGroups` не вистачає пам'яті - що робити?"

#: gap-lesson/_episodes/05-small-groups.md:140
msgid ""
">\n"
"> * Use iteration over `[1..NrSmallGroups(n)]` as shown in the function "
"above\n"
"> * Use `IdsOfAllSmallGroups` which accepts same arguments as "
"`AllSmallGroups`\n"
"> but returns ids instead of groups."
msgstr ""
">\n"
"> *Використовуйте ітерацію над `[1..NrSmallGroups(n)]`, як показано у "
"функції вище\n"
"> * Використовуйте `IdsOfAllSmallGroups`, яка приймає ті самі аргументи, що "
"й `AllSmallGroups`, \n"
"> але повертає ідентифікатори замість груп."

#: gap-lesson/_episodes/05-small-groups.md:146
msgid ""
"Iterating over `[1..NrSmallGroups(n)]` gives you more flexibility if you "
"need\n"
"more control over the progress of calculation. For example, the next "
"version\n"
"of our testing function prints additional information about the number of "
"the\n"
"group being tested. It also supplies the testing function as an argument "
"(why do\n"
"you think this is better?)."
msgstr ""
"Ітерація над `[1..NrSmallGroups(n)]` дає вам більше гнучкості, якщо вам "
"потрібно\n"
"більше контролювати хід обчислення. Наприклад, наступна версія\n"
"нашої функції тестування друкує додаткову інформацію про номер\n"
"групи, що тестується. Він також надає функцію тестування як аргумент (чому\n"
"ви думаєте, що це краще?)"

# code block
#: gap-lesson/_episodes/05-small-groups.md:152
msgid ""
"~~~\n"
"TestOneOrder := function(f,n)\n"
"local i, G;\n"
"for i in [1..NrSmallGroups(n)] do\n"
"  Print(n, \":\", i, \"/\", NrSmallGroups(n), \"\\r\");\n"
"  G := SmallGroup( n, i );\n"
"  if f(G) then\n"
"    Print(\"\\n\");\n"
"    return [n,i];\n"
"  fi;\n"
"od;\n"
"Print(\"\\n\");\n"
"return fail;\n"
"end;\n"
"~~~"
msgstr ""
"~~~\n"
"TestOneOrder := function(f,n)\n"
"local i, G;\n"
"for i in [1..NrSmallGroups(n)] do\n"
"  Print(n, \":\", i, \"/\", NrSmallGroups(n), \"\\r\");\n"
"  G := SmallGroup( n, i );\n"
"  if f(G) then\n"
"    Print(\"\\n\");\n"
"    return [n,i];\n"
"  fi;\n"
"od;\n"
"Print(\"\\n\");\n"
"return fail;\n"
"end;\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:171
msgid ""
"~~~\n"
"TestOneOrder(TestOneGroup,64);\n"
"~~~"
msgstr ""
"~~~\n"
"TestOneOrder(TestOneGroup,64);\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:176
msgid ""
"will display a changing counter during calculation and then return `fail`:"
msgstr ""
"відобразить змінний лічильник під час обчислення, а потім поверне `fail`:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:178
msgid ""
"~~~\n"
"64:267/267\n"
"fail\n"
"~~~"
msgstr ""
"~~~\n"
"64:267/267\n"
"fail\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:184
msgid ""
"The next step is to integrate `TestOneOrder` into a function which will "
"test\n"
"all orders from 2 to `n` and stop as soon as it finds an example of a\n"
"group with the average order of an element being an integer:"
msgstr ""
"Наступним кроком є інтеграція `TestOneOrder` у функцію, яка перевірить\n"
"усі порядки від 2 до `n` і зупиниться, щойно знайде приклад\n"
"групи, середній порядок елемента якого є цілим числом:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:188
msgid ""
"~~~\n"
"TestAllOrders:=function(f,n)\n"
"local i, res;\n"
"for i in [2..n] do\n"
"  res:=TestOneOrder(f,i);\n"
"  if res <> fail then\n"
"    return res;\n"
"  fi;\n"
"od;\n"
"return fail;\n"
"end;\n"
"~~~"
msgstr ""
"~~~\n"
"TestAllOrders:=function(f,n)\n"
"local i, res;\n"
"for i in [2..n] do\n"
"  res:=TestOneOrder(f,i);\n"
"  if res <> fail then\n"
"    return res;\n"
"  fi;\n"
"od;\n"
"return fail;\n"
"end;\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:202
msgid "It reports that there is such a group of order 105:"
msgstr "Ми бачимо, що існує така група порядку 105:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:204
msgid ""
"~~~\n"
"TestAllOrders(TestOneGroup,128);\n"
"~~~"
msgstr ""
"~~~\n"
"TestAllOrders(TestOneGroup,128);\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:209
msgid ""
"~~~\n"
"2:1/1\n"
"3:1/1\n"
"4:2/2\n"
"5:1/1\n"
"6:2/2\n"
"7:1/1\n"
"8:5/5\n"
"...\n"
"...\n"
"...\n"
"100:16/16\n"
"101:1/1\n"
"102:4/4\n"
"103:1/1\n"
"104:14/14\n"
"105:1/2\n"
"[ 105, 1 ]\n"
"~~~"
msgstr ""
"~~~\n"
"2:1/1\n"
"3:1/1\n"
"4:2/2\n"
"5:1/1\n"
"6:2/2\n"
"7:1/1\n"
"8:5/5\n"
"...\n"
"...\n"
"...\n"
"100:16/16\n"
"101:1/1\n"
"102:4/4\n"
"103:1/1\n"
"104:14/14\n"
"105:1/2\n"
"[ 105, 1 ]\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:230
msgid ""
"To explore it further, we can get its `StructureDescription` (see\n"
"[here](http://www.gap-system.org/Manuals/doc/ref/chap39."
"html#X87BF1B887C91CA2E)\n"
"for the explanation of the notation it uses):"
msgstr ""
"Щоб дослідити її далі, ми можемо отримати її `StructureDescription` (див.\n"
"[тут](http://www.gap-system.org/Manuals/doc/ref/chap39."
"html#X87BF1B887C91CA2E)\n"
"для пояснення нотації, яку використано):"

# code block
#: gap-lesson/_episodes/05-small-groups.md:234
msgid ""
"~~~\n"
"G:=SmallGroup(105,1); AvgOrdOfGroup(G); StructureDescription(G);\n"
"~~~"
msgstr ""
"~~~\n"
"G:=SmallGroup(105,1); AvgOrdOfGroup(G); StructureDescription(G);\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:239
msgid ""
"~~~\n"
"<pc group of size 105 with 3 generators>\n"
"17\n"
"\"C5 x (C7 : C3)\"\n"
"~~~"
msgstr ""
"~~~\n"
"<pc group of size 105 with 3 generators>\n"
"17\n"
"\"C5 x (C7 : C3)\"\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:246
msgid ""
"and then convert it to a finitely presented group to see its generators and "
"relators:"
msgstr ""
"а потім перетворити її на скінченно представлену групу, щоб побачити її "
"твірні та співвідношення."

# code block
#: gap-lesson/_episodes/05-small-groups.md:248
msgid ""
"~~~\n"
"H:=SimplifiedFpGroup(Image(IsomorphismFpGroup(G)));\n"
"RelatorsOfFpGroup(H);\n"
"~~~"
msgstr ""
"~~~\n"
"H:=SimplifiedFpGroup(Image(IsomorphismFpGroup(G)));\n"
"RelatorsOfFpGroup(H);\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:254
msgid ""
"~~~\n"
"<fp group on the generators [ F1, F2, F3 ]>\n"
"[ F1^3, F2^-1*F1^-1*F2*F1, F3^-1*F2^-1*F3*F2, F3^-1*F1^-1*F3*F1*F3^-1, "
"F2^5,\n"
"  F3^7 ]\n"
"~~~"
msgstr ""
"~~~\n"
"<fp group on the generators [ F1, F2, F3 ]>\n"
"[ F1^3, F2^-1*F1^-1*F2*F1, F3^-1*F2^-1*F3*F2, F3^-1*F1^-1*F3*F1*F3^-1, "
"F2^5,\n"
"  F3^7 ]\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:261
msgid ""
"Now we want to try larger groups, starting from order 106 (we check that\n"
"the other group of order 105 possesses no such property)"
msgstr ""
"Тепер ми хочемо спробувати більші групи, починаючи з порядку 106 (ми "
"перевіряємо,\n"
"що інша група порядку 105 не має такої властивості)"

# code block
#: gap-lesson/_episodes/05-small-groups.md:264
msgid ""
"~~~\n"
"List(AllSmallGroups(105),AvgOrdOfGroup);\n"
"~~~"
msgstr ""
"~~~\n"
"List(AllSmallGroups(105),AvgOrdOfGroup);\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:269
msgid ""
"~~~\n"
"[ 17, 301/5 ]\n"
"~~~"
msgstr ""
"~~~\n"
"[ 17, 301/5 ]\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:274
msgid ""
"With a little modification, we add an extra argument specifying the order "
"from\n"
"which to start:"
msgstr ""
"З невеликими змінами ми додаємо додатковий аргумент, який визначає порядок,\n"
"з якого потрібно починати:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:277
msgid ""
"~~~\n"
"TestRangeOfOrders:=function(f,n1,n2)\n"
"local n, res;\n"
"for n in [n1..n2] do\n"
"  res:=TestOneOrder(f,n);\n"
"  if res <> fail then\n"
"    return res;\n"
"  fi;\n"
"od;\n"
"return fail;\n"
"end;\n"
"~~~"
msgstr ""
"~~~\n"
"TestRangeOfOrders:=function(f,n1,n2)\n"
"local n, res;\n"
"for n in [n1..n2] do\n"
"  res:=TestOneOrder(f,n);\n"
"  if res <> fail then\n"
"    return res;\n"
"  fi;\n"
"od;\n"
"return fail;\n"
"end;\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:291
msgid "But now we call it with"
msgstr "Але тепер ми викликаємо"

# code block
#: gap-lesson/_episodes/05-small-groups.md:293
msgid ""
"~~~\n"
"TestRangeOfOrders(TestOneGroup,106,256);\n"
"~~~"
msgstr ""
"~~~\n"
"TestRangeOfOrders(TestOneGroup,106,256);\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:298
msgid ""
"and discover that testing 2328 groups of order 128 and additionally 56092 "
"groups\n"
"of order 256 already takes too long."
msgstr ""
"і виявляємо, що тестування 2328 груп порядку 128 і додатково 56092\n"
"груп порядку 256 вже займає занадто багато часу."

# blockquote, which can be cascaded
#: gap-lesson/_episodes/05-small-groups.md:301
#: gap-lesson/_episodes/06-attributes.md:234
msgid "> ## Don't panic!"
msgstr "> ## Не панікувати!"

#: gap-lesson/_episodes/05-small-groups.md:302
msgid ""
">\n"
"> You can interrupt GAP by pressing Ctrl-C once. After that, GAP will enter\n"
"> a break loop, designated by the break prompt `brk>`. You can leave it by\n"
"> typing `quit;` (beware of pressing Ctrl-C twice within a second -- that "
"will\n"
"> terminate GAP session completely)."
msgstr ""
">\n"
"> Ви можете перервати GAP, натиснувши Ctrl-C один раз. Після цього GAP "
"увійде\n"
"> в цикл розриву, позначений підказкою розриву `brk>`. Ви можете вийти з "
"нього,\n"
"> ввівши `quit;` (стережіться натискання Ctrl-C двічі протягом секунди – це\n"
"> повністю завершить сеанс GAP)."

#: gap-lesson/_episodes/05-small-groups.md:309
msgid ""
"This is another situation where theoretical knowledge helps much more than "
"the\n"
"brute-force approach. If the group is a _p_-group, then the order of each\n"
"conjugacy class of a non-identity element of the group is divisible by _p_;\n"
"therefore, the average order of a group element may not be an integer. "
"Therefore,\n"
"_p_-groups can be excluded from calculation. So, the new version of the code "
"is"
msgstr ""
"Це ще одна ситуація, коли теоретичні знання допомагають набагато більше,\n"
"ніж підхід грубої сили. Якщо група є _p_-групою, то порядок кожного\n"
" класу спряженості нетотожного елемента групи ділиться на _p_;\n"
" отже, середній порядок елемента групи може не бути цілим числом. Тому\n"
"_p_-групи можна виключити з розрахунку. Отже, нова версія коду є"

# code block
#: gap-lesson/_episodes/05-small-groups.md:315
msgid ""
"~~~\n"
"TestRangeOfOrders:=function(f,n1,n2)\n"
"local n, res;\n"
"for n in [n1..n2] do\n"
"  if not IsPrimePowerInt(n) then\n"
"     res:=TestOneOrder(f,n);\n"
"     if res <> fail then\n"
"       return res;\n"
"     fi;\n"
"   fi;\n"
"od;\n"
"return fail;\n"
"end;\n"
"~~~"
msgstr ""
"~~~\n"
"TestRangeOfOrders:=function(f,n1,n2)\n"
"local n, res;\n"
"for n in [n1..n2] do\n"
"  if not IsPrimePowerInt(n) then\n"
"     res:=TestOneOrder(f,n);\n"
"     if res <> fail then\n"
"       return res;\n"
"     fi;\n"
"   fi;\n"
"od;\n"
"return fail;\n"
"end;\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:331
msgid ""
"and using it we are able to discover a group of order 357 with the same "
"property:"
msgstr ""
"і використовуючи його, ми можемо виявити групу порядку 357 з тією ж "
"властивістю:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:333
msgid ""
"~~~\n"
"gap> TestRangeOfOrders(TestOneGroup,106,512);\n"
"~~~"
msgstr ""
"~~~\n"
"gap> TestRangeOfOrders(TestOneGroup,106,512);\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:338
msgid ""
"~~~\n"
"106:2/2\n"
"108:45/45\n"
"...\n"
"350:10/10\n"
"351:14/14\n"
"352:195/195\n"
"354:4/4\n"
"355:2/2\n"
"356:5/5\n"
"357:1/2\n"
"[ 357, 1 ]\n"
"~~~"
msgstr ""
"~~~\n"
"106:2/2\n"
"108:45/45\n"
"...\n"
"350:10/10\n"
"351:14/14\n"
"352:195/195\n"
"354:4/4\n"
"355:2/2\n"
"356:5/5\n"
"357:1/2\n"
"[ 357, 1 ]\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:353
msgid ""
"The next function shows even further flexibility: it is variadic, i.e.\n"
"it may accept two or more arguments, the first two of which will be assigned "
"to\n"
"the variables `f` and `n`, and the rest of which will be available in the "
"list `r`\n"
"(this is indicated by `...` after `r`). The first argument is the testing\n"
"function, the second is the order to check, and the third and the fourth\n"
"are the numbers of the first and last groups of this order that should be\n"
"checked. By default, the last two are equal to 1 and `NrSmallGroups(n)`\n"
"respectively. This function also shows how to validate the input and\n"
"produce user-friendly error messages in case of invalid arguments."
msgstr ""
"Наступна функція демонструє ще більшу гнучкість: вона є варіативною, тобто\n"
"вона може приймати два або більше аргументів, перші два з яких будуть "
"призначені змінним `f` і `n`, а решта буде доступна в список `r`\n"
"(це позначено `...` після `r`). Перший аргумент —\n"
"функція перевірки, другий — порядок перевірки, третій і четвертий —\n"
"номери першої та останньої груп цього порядку, які потрібно\n"
"перевірити. За замовчуванням останні два дорівнюють 1 і `NrSmallGroups(n)`\n"
"відповідно. Ця функція також показує, як перевірити вхідні дані\n"
"та створювати зручні повідомлення про помилки у випадку неприпустимих "
"аргументів."

#: gap-lesson/_episodes/05-small-groups.md:363
msgid ""
"In addition, this function demonstrates how to use `Info` messages that\n"
"may be switched on and off by setting appropriate `Info` level. The need\n"
"we address here is to be able to switch the levels of verbosity of the\n"
"output without error-prone approach of walking through the code and "
"commenting\n"
"`Print` statements in and out. It is achieved by creating an info class:"
msgstr ""
"Крім того, ця функція демонструє, як використовувати повідомлення `Info`,\n"
"які можна вмикати та вимикати, встановивши відповідний рівень `Info`. "
"Потреба,\n"
"яку ми тут розглядаємо, полягає в тому, щоб мати можливість перемикати рівні "
"багатослівності\n"
"виводу без підходу, схильного до помилок, проходження коду та коментування\n"
"інструкцій `Print`. Це досягається шляхом створення інформаційного класу:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:369
msgid ""
"~~~\n"
"gap> InfoSmallGroupsSearch := NewInfoClass(\"InfoSmallGroupsSearch\");\n"
"~~~"
msgstr ""
"~~~\n"
"gap> InfoSmallGroupsSearch := NewInfoClass(\"InfoSmallGroupsSearch\");\n"
"~~~"

# code block
#: gap-lesson/_episodes/05-small-groups.md:374
msgid ""
"~~~\n"
"InfoSmallGroupsSearch\n"
"~~~"
msgstr ""
"~~~\n"
"InfoSmallGroupsSearch\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:379
msgid ""
"Now instead of `Print(\"something\");` one could use\n"
"`Info( InfoSmallGroupsSearch, infolevel, \"something\" );`\n"
"where `infolevel` is a positive integer specifying the level of verbosity.\n"
"This level could be changed to `n` using the command\n"
"`SetInfoLevel( InfoSmallGroupsSearch, n);`. See actual calls of `Info` in\n"
"the code below:"
msgstr ""
"Тепер замість `Print(\"something\");` можна використовувати\n"
"`Info( InfoSmallGroupsSearch, infolevel, \"something\");`,\n"
"де `infolevel` є додатним цілим числом, що визначає рівень докладності.\n"
"Цей рівень можна змінити на `n` за допомогою команди\n"
"`SetInfoLevel( InfoSmallGroupsSearch, n);`. Перегляньте фактичні виклики "
"`Info` у\n"
"коді нижче:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:386
msgid ""
"~~~\n"
"TestOneOrderVariadic := function(f,n,r...)\n"
"local n1, n2, i;\n"
"\n"
"if not Length(r) in [0..2] then\n"
"  Error(\"The number of arguments must be 2,3 or 4\\n\" );\n"
"fi;\n"
"\n"
"if not IsFunction( f ) then\n"
"  Error(\"The first argument must be a function\\n\" );\n"
"fi;\n"
"\n"
"if not IsPosInt( n ) then\n"
"  Error(\"The second argument must be a positive integer\\n\" );\n"
"fi;\n"
"\n"
"if IsBound(r[1]) then\n"
"  n1:=r[1];\n"
"  if not n1 in [1..NrSmallGroups(n)] then\n"
"    Error(\"The 3rd argument, if present, must belong to \", [1.."
"NrSmallGroups(n)], \"\\n\" );\n"
"  fi;\n"
"else\n"
"  n1:=1;\n"
"fi;\n"
"\n"
"if IsBound(r[2]) then\n"
"  n2:=r[2];\n"
"  if not n2 in [1..NrSmallGroups(n)] then\n"
"    Error(\"The 4th argument, if present, must belong to \", [1.."
"NrSmallGroups(n)], \"\\n\" );\n"
"  elif n2 < n1 then\n"
"    Error(\"The 4th argument, if present, must be greater or equal to the "
"3rd \\n\" );\n"
"  fi;\n"
"else\n"
"  n2:=NrSmallGroups(n);\n"
"fi;\n"
"\n"
"Info( InfoSmallGroupsSearch, 1,\n"
"      \"Checking groups \", n1, \" ... \", n2, \" of order \", n );\n"
"for i in [n1..n2] do\n"
"  if InfoLevel( InfoSmallGroupsSearch ) > 1 then\n"
"    Print(i, \"/\", NrSmallGroups(n), \"\\r\");\n"
"  fi;\n"
"  if f(SmallGroup(n,i)) then\n"
"    Info( InfoSmallGroupsSearch, 1,\n"
"          \"Discovered counterexample: SmallGroup( \", n, \", \", i, "
"\" )\" );\n"
"    return [n,i];\n"
"  fi;\n"
"od;\n"
"Info( InfoSmallGroupsSearch, 1,\n"
"      \"Search completed - no counterexample discovered\" );\n"
"return fail;\n"
"end;\n"
"~~~"
msgstr ""
"~~~\n"
"TestOneOrderVariadic := function(f,n,r...)\n"
"local n1, n2, i;\n"
"\n"
"if not Length(r) in [0..2] then\n"
"  Error(\"The number of arguments must be 2,3 or 4\\n\" );\n"
"fi;\n"
"\n"
"if not IsFunction( f ) then\n"
"  Error(\"The first argument must be a function\\n\" );\n"
"fi;\n"
"\n"
"if not IsPosInt( n ) then\n"
"  Error(\"The second argument must be a positive integer\\n\" );\n"
"fi;\n"
"\n"
"if IsBound(r[1]) then\n"
"  n1:=r[1];\n"
"  if not n1 in [1..NrSmallGroups(n)] then\n"
"    Error(\"The 3rd argument, if present, must belong to \", [1.."
"NrSmallGroups(n)], \"\\n\" );\n"
"  fi;\n"
"else\n"
"  n1:=1;\n"
"fi;\n"
"\n"
"if IsBound(r[2]) then\n"
"  n2:=r[2];\n"
"  if not n2 in [1..NrSmallGroups(n)] then\n"
"    Error(\"The 4th argument, if present, must belong to \", [1.."
"NrSmallGroups(n)], \"\\n\" );\n"
"  elif n2 < n1 then\n"
"    Error(\"The 4th argument, if present, must be greater or equal to the "
"3rd \\n\" );\n"
"  fi;\n"
"else\n"
"  n2:=NrSmallGroups(n);\n"
"fi;\n"
"\n"
"Info( InfoSmallGroupsSearch, 1,\n"
"      \"Checking groups \", n1, \" ... \", n2, \" of order \", n );\n"
"for i in [n1..n2] do\n"
"  if InfoLevel( InfoSmallGroupsSearch ) > 1 then\n"
"    Print(i, \"/\", NrSmallGroups(n), \"\\r\");\n"
"  fi;\n"
"  if f(SmallGroup(n,i)) then\n"
"    Info( InfoSmallGroupsSearch, 1,\n"
"          \"Discovered counterexample: SmallGroup( \", n, \", \", i, "
"\" )\" );\n"
"    return [n,i];\n"
"  fi;\n"
"od;\n"
"Info( InfoSmallGroupsSearch, 1,\n"
"      \"Search completed - no counterexample discovered\" );\n"
"return fail;\n"
"end;\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:441
msgid ""
"The following example demonstrates how the output may now be controlled\n"
"by switching the info level for `InfoSmallGroupsSearch`:"
msgstr ""
"У наступному прикладі показано, як тепер можна керувати\n"
"виводом, перемикаючи рівень інформації для `InfoSmallGroupsSearch`:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:444
msgid ""
"~~~\n"
"gap> TestOneOrderVariadic(IsIntegerAverageOrder,24);\n"
"fail\n"
"gap> SetInfoLevel( InfoSmallGroupsSearch, 1 );\n"
"gap> TestOneOrderVariadic(IsIntegerAverageOrder,24);\n"
"#I  Checking groups 1 ... 15 of order 24\n"
"#I  Search completed - no counterexample discovered\n"
"fail\n"
"gap> TestOneOrderVariadic(IsIntegerAverageOrder,357);\n"
"#I  Checking groups 1 ... 2 of order 357\n"
"#I  Discovered counterexample: SmallGroup( 357, 1 )\n"
"[ 357, 1 ]\n"
"gap> SetInfoLevel( InfoSmallGroupsSearch, 0);\n"
"gap> TestOneOrderVariadic(IsIntegerAverageOrder,357);\n"
"[ 357, 1 ]\n"
"~~~"
msgstr ""
"~~~\n"
"gap> TestOneOrderVariadic(IsIntegerAverageOrder,24);\n"
"fail\n"
"gap> SetInfoLevel( InfoSmallGroupsSearch, 1 );\n"
"gap> TestOneOrderVariadic(IsIntegerAverageOrder,24);\n"
"#I  Перевірка груп 1 ... 15 порядку 24\n"
"#I  Пошук завершено - контрприкладів не знайдено\n"
"fail\n"
"gap> TestOneOrderVariadic(IsIntegerAverageOrder,357);\n"
"#I  Перевірка груп 1 ... 2 порядку 357\n"
"#I  Виявлений контрприклад: SmallGroup( 357, 1 )\n"
"[ 357, 1 ]\n"
"gap> SetInfoLevel( InfoSmallGroupsSearch, 0);\n"
"gap> TestOneOrderVariadic(IsIntegerAverageOrder,357);\n"
"[ 357, 1 ]\n"
"~~~"

#: gap-lesson/_episodes/05-small-groups.md:462
msgid ""
"Of course, this now introduces some complication for the test file,\n"
"which compares the actual output with the reference output. To resolve\n"
"this problem, we will decide to run the tests at info level 0 to suppress  \n"
"all additional outputs. Because the tests may have been started in the\n"
"GAP session with a different info level, we will remember that info level\n"
"to restore it after the test:"
msgstr ""
"Звичайно, тепер це вносить деякі ускладнення для тестового файлу,\n"
" який порівнює фактичний вихід із еталонним виходом. Щоб вирішити\n"
"цю проблему, ми вирішимо запустити тести на інформаційному рівні 0, щоб "
"заблокувати\n"
"всі додаткові виходи. Оскільки тести могли бути запущені в\n"
"сеансі GAP з іншим рівнем інформації, ми запам’ятаємо цей рівень "
"інформації,\n"
"щоб відновити його після тесту:"

# code block
#: gap-lesson/_episodes/05-small-groups.md:469
msgid ""
"~~~\n"
"# Finding groups with integer average order\n"
"gap> INFO_SSS:=InfoLevel(InfoSmallGroupsSearch);;\n"
"gap> SetInfoLevel( InfoSmallGroupsSearch, 0);\n"
"gap> res:=[];;\n"
"gap> for n in [1..360] do\n"
">      if not IsPrimePowerInt(n) then\n"
">        t := TestOneOrderVariadic( IsIntegerAverageOrder,n,1,"
"NrSmallGroups(n) );\n"
">        if t <> fail then\n"
">          Add(res,t);\n"
">        fi;\n"
">      fi;\n"
">    od;\n"
"gap> res;\n"
"[ [ 1, 1 ], [ 105, 1 ], [ 357, 1 ] ]\n"
"gap> SetInfoLevel( InfoSmallGroupsSearch, INFO_SSS);\n"
"~~~"
msgstr ""
"~~~\n"
"# Знаходжeння груп із цілим середнім порядком\n"
"gap> INFO_SSS:=InfoLevel(InfoSmallGroupsSearch);;\n"
"gap> SetInfoLevel( InfoSmallGroupsSearch, 0);\n"
"gap> res:=[];;\n"
"gap> for n in [1..360] do\n"
">      if not IsPrimePowerInt(n) then\n"
">        t := TestOneOrderVariadic( IsIntegerAverageOrder,n,1,"
"NrSmallGroups(n) );\n"
">        if t <> fail then\n"
">          Add(res,t);\n"
">        fi;\n"
">      fi;\n"
">    od;\n"
"gap> res;\n"
"[ [ 1, 1 ], [ 105, 1 ], [ 357, 1 ] ]\n"
"gap> SetInfoLevel( InfoSmallGroupsSearch, INFO_SSS);\n"
"~~~"

# blockquote, which can be cascaded
#: gap-lesson/_episodes/05-small-groups.md:488
msgid ""
"> ## Does the Small Groups Library contain another group with this property?"
msgstr ""
"> ## Чи містить бібліотека Small Groups Library іншу групу з цією "
"властивістю?"

#: gap-lesson/_episodes/05-small-groups.md:489
msgid ""
">\n"
"> * What can you say about the order of the groups with this property?\n"
">\n"
"> * Can you estimate how long it may take to check all 408641062 groups of "
"order 1536?\n"
">\n"
"> * How many groups of order not higher than 2000 might you be able to "
"check,\n"
">   excluding _p_-groups and those of order 1536?\n"
">\n"
"> * Can you find another group with this property in the Small Groups "
"Library\n"
">   (of order not equal to 1536)?"
msgstr ""
">\n"
"> * Що Ви можете сказати про порядок груп із цією властивістю?\n"
">\n"
"> * Чи можете Ви оцінити, скільки часу може зайняти перевірка всіх 408641062 "
"груп порядку 1536?\n"
">\n"
"> * Скільки груп порядку не вище 2000 Ви могли б перевірити,\n"
"> за винятком _p_-груп і груп порядку 1536?\n"
">\n"
"> * Чи можете Ви знайти іншу групу з цією властивістю в бібліотеці Small "
"Groups Library\n"
" > (порядок не дорівнює 1536)?"
