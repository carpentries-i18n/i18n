# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Ingrid Bianka Garcia Lino <ingrid.bianka@gmail.com>, 2020
# Ivan Ogasawara <ivan.ogasawara@gmail.com>, 2020
# David PS <dps.helio@gmail.com>, 2021
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2020-05-24 19:34:12+0100\n"
"PO-Revision-Date: 2020-05-24 19:14+0000\n"
"Last-Translator: David PS <dps.helio@gmail.com>, 2021\n"
"Language-Team: Spanish (https://www.transifex.com/carpentries-i18n/teams/98915/es/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

# Front Matter
#: python-novice-gapminder/_episodes/13-conditionals.md:1
msgid ""
"---\n"
"title: \"Conditionals\"\n"
"teaching: 10\n"
"exercises: 15\n"
"questions:\n"
"- \"How can programs do different things for different data?\"\n"
"objectives:\n"
"- \"Correctly write programs that use if and else statements and simple Boolean expressions (without logical operators).\"\n"
"- \"Trace the execution of unnested conditionals and conditionals inside loops.\"\n"
"keypoints:\n"
"- \"Use `if` statements to control whether or not a block of code is executed.\"\n"
"- \"Conditionals are often used inside loops.\"\n"
"- \"Use `else` to execute a block of code when an `if` condition is *not* true.\"\n"
"- \"Use `elif` to specify additional tests.\"\n"
"- \"Conditions are tested once, in order.\"\n"
"- \"Create a table showing variables' values to trace a program's execution.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Condicionales\"\n"
"teaching: 10\n"
"exercises: 15\n"
"questions:\n"
"- \"¿Cómo pueden los programas hacer cosas diferentes para datos diferentes?\"\n"
"objectives:\n"
"- \"Escribir correctamente los programas que usan declaraciones `if` y `else` y expresiones booleanas simples (sin operadores lógicos).\"\n"
"- \"Rastrear la ejecución de sentencias condicionales no anidados y sentencias condicionales dentro de bucles.\"\n"
"keypoints:\n"
"- \"Utiliza las declaraciones `if` para controlar si se ejecuta o no un bloque de código.\"\n"
"- \"Las sentencias condicionales a menudo se usan dentro de bucles.\"\n"
"- \"Usa `else` para ejecutar un bloque de código cuando una condición` if` *no* es verdadera.\"\n"
"- \"Usa `elif` para especificar verificaciones adicionales.\"\n"
"- \"Las condiciones se verifican una vez, en orden.\"\n"
"- \"Crea una tabla que muestre los valores de las variables para rastrear la ejecución de un programa.\"\n"
"---"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:18
msgid ""
"## Use `if` statements to control whether or not a block of code is "
"executed."
msgstr ""
"## Utiliza las declaraciones `if` para controlar si se ejecuta o no un "
"bloque de código."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:20
msgid "*   An `if` statement (more properly called a *conditional* statement)"
msgstr ""
"Una declaración `if` (más propiamente llamada declaración *condicional*)"

#: python-novice-gapminder/_episodes/13-conditionals.md:21
msgid ""
"    controls whether some block of code is executed or not.\n"
"*   Structure is similar to a `for` statement:\n"
"    *   First line opens with `if` and ends with a colon\n"
"    *   Body containing one or more statements is indented (usually by 4 spaces)"
msgstr ""
"    controla si algún bloque de código se ejecuta o no.\n"
"*   La estructura es similar a una declaración `for`:\n"
"    *   La primera línea se abre con `if` y termina con dos puntos\n"
"    *   El cuerpo que contiene una o más declaraciones es indentado (generalmente por 4 espacios)"

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:26
msgid ""
"~~~\n"
"mass = 3.54\n"
"if mass > 3.0:\n"
"    print(mass, 'is large')\n"
"\n"
"mass = 2.07\n"
"if mass > 3.0:\n"
"    print (mass, 'is large')\n"
"~~~"
msgstr ""
"~~~\n"
"mass = 3.54\n"
"if mass > 3.0:\n"
"    print(mass, 'is large')\n"
"\n"
"mass = 2.07\n"
"if mass > 3.0:\n"
"    print (mass, 'is large')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:35
msgid ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:41
msgid "## Conditionals are often used inside loops."
msgstr "## Las sentencias condicionales a menudo se usan dentro de bucles."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:43
msgid ""
"*   Not much point using a conditional when we know the value (as above)."
msgstr ""
"*   No tiene mucho sentido usar una sentencia condicional cuando conocemos "
"el valor (como arriba)."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:44
msgid "*   But useful when we have a collection to process."
msgstr "*   Pero es útil cuando tenemos una colección de datos para procesar."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:46
msgid ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 3.0:\n"
"        print(m, 'is large')\n"
"~~~"
msgstr ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 3.0:\n"
"        print(m, 'is large')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:52
msgid ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"9.22 is large\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"9.22 is large\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:59
msgid ""
"## Use `else` to execute a block of code when an `if` condition is *not* "
"true."
msgstr ""
"## Utiliza `else` para ejecutar un bloque de código cuando una condición` "
"if`  *no* es verdadera."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:61
msgid "*   `else` can be used following an `if`."
msgstr "*  `else` se puede usar después de un` if`."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:62
msgid ""
"*   Allows us to specify an alternative to execute when the `if` *branch* "
"isn't taken."
msgstr ""
"*   Nos permite especificar una alternativa para ejecutar cuando no se entra"
" en la *rama* `if`."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:64
msgid ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 3.0:\n"
"        print(m, 'is large')\n"
"    else:\n"
"        print(m, 'is small')\n"
"~~~"
msgstr ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 3.0:\n"
"        print(m, 'is large')\n"
"    else:\n"
"        print(m, 'is small')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:72
msgid ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"2.07 is small\n"
"9.22 is large\n"
"1.86 is small\n"
"1.71 is small\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"2.07 is small\n"
"9.22 is large\n"
"1.86 is small\n"
"1.71 is small\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:82
msgid "## Use `elif` to specify additional tests."
msgstr "## Usa `elif` para especificar verificaciones adicionales."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:84
msgid ""
"*   May want to provide several alternative choices, each with its own test."
msgstr ""
"*   Tal vez desees proporcionar varias opciones alternativas, cada una con "
"su propia verificación."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:85
msgid "*   Use `elif` (short for \"else if\") and a condition to specify these."
msgstr ""
"*   Usa `elif` (abreviatura de\" else if \") y una condición para "
"especificarlos."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:86
msgid "*   Always associated with an `if`."
msgstr "*   Siempre asociado con un `if`."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:87
msgid "*   Must come before the `else` (which is the \"catch all\")."
msgstr "*   Debe venir antes de `else` (que \"trata todo lo demás\")."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:89
msgid ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 9.0:\n"
"        print(m, 'is HUGE')\n"
"    elif m > 3.0:\n"
"        print(m, 'is large')\n"
"    else:\n"
"        print(m, 'is small')\n"
"~~~"
msgstr ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 9.0:\n"
"        print(m, 'is HUGE')\n"
"    elif m > 3.0:\n"
"        print(m, 'is large')\n"
"    else:\n"
"        print(m, 'is small')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:99
msgid ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"2.07 is small\n"
"9.22 is HUGE\n"
"1.86 is small\n"
"1.71 is small\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"2.07 is small\n"
"9.22 is HUGE\n"
"1.86 is small\n"
"1.71 is small\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:109
msgid "## Conditions are tested once, in order."
msgstr "## Las condiciones se verifican una vez, en orden."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:111
msgid ""
"*   Python steps through the branches of the conditional in order, testing "
"each in turn."
msgstr ""
"*   Python recorre las ramas de las sentencias condicionales en orden, "
"verificando cada una por turno."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:112
msgid "*   So ordering matters."
msgstr "*   Por lo que el orden es importante."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:114
msgid ""
"~~~\n"
"grade = 85\n"
"if grade >= 70:\n"
"    print('grade is C')\n"
"elif grade >= 80:\n"
"    print('grade is B')\n"
"elif grade >= 90:\n"
"    print('grade is A')\n"
"~~~"
msgstr ""
"~~~\n"
"grade = 85\n"
"if grade >= 70:\n"
"    print('grade is C')\n"
"elif grade >= 80:\n"
"    print('grade is B')\n"
"elif grade >= 90:\n"
"    print('grade is A')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:123
msgid ""
"{: .language-python}\n"
"~~~\n"
"grade is C\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"grade is C\n"
"~~~"

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:129
msgid "*   Does *not* automatically go back and re-evaluate if values change."
msgstr ""
"*  *No* retrocede automáticamente y vuelve a evaluar si los valores cambian."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:131
msgid ""
"~~~\n"
"velocity = 10.0\n"
"if velocity > 20.0:\n"
"    print('moving too fast')\n"
"else:\n"
"    print('adjusting velocity')\n"
"    velocity = 50.0\n"
"~~~"
msgstr ""
"~~~\n"
"velocity = 10.0\n"
"if velocity > 20.0:\n"
"    print('moving too fast')\n"
"else:\n"
"    print('adjusting velocity')\n"
"    velocity = 50.0\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:139
msgid ""
"{: .language-python}\n"
"~~~\n"
"adjusting velocity\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"adjusting velocity\n"
"~~~"

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:145
msgid ""
"*   Often use conditionals in a loop to \"evolve\" the values of variables."
msgstr ""
"*   A menudo se usa condicionales en un bucle para \"evolucionar\" los "
"valores de las variables."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:147
msgid ""
"~~~\n"
"velocity = 10.0\n"
"for i in range(5): # execute the loop 5 times\n"
"    print(i, ':', velocity)\n"
"    if velocity > 20.0:\n"
"        print('moving too fast')\n"
"        velocity = velocity - 5.0\n"
"    else:\n"
"        print('moving too slow')\n"
"        velocity = velocity + 10.0\n"
"print('final velocity:', velocity)\n"
"~~~"
msgstr ""
"~~~\n"
"velocity = 10.0\n"
"for i in range(5): # execute the loop 5 times\n"
"    print(i, ':', velocity)\n"
"    if velocity > 20.0:\n"
"        print('moving too fast')\n"
"        velocity = velocity - 5.0\n"
"    else:\n"
"        print('moving too slow')\n"
"        velocity = velocity + 10.0\n"
"print('final velocity:', velocity)\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:159
msgid ""
"{: .language-python}\n"
"~~~\n"
"0 : 10.0\n"
"moving too slow\n"
"1 : 20.0\n"
"moving too slow\n"
"2 : 30.0\n"
"moving too fast\n"
"3 : 25.0\n"
"moving too fast\n"
"4 : 20.0\n"
"moving too slow\n"
"final velocity: 30.0\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"0 : 10.0\n"
"moving too slow\n"
"1 : 20.0\n"
"moving too slow\n"
"2 : 30.0\n"
"moving too fast\n"
"3 : 25.0\n"
"moving too fast\n"
"4 : 20.0\n"
"moving too slow\n"
"final velocity: 30.0\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:175
msgid ""
"## Create a table showing variables' values to trace a program's execution."
msgstr ""
"## Crea una tabla que muestre los valores de las variables para rastrear la "
"ejecución de un programa."

# inline html
#: python-novice-gapminder/_episodes/13-conditionals.md:177
msgid ""
"<table>\n"
"  <tr>\n"
"    <td><strong>i</strong></td>\n"
"    <td>0</td>\n"
"    <td>.</td>\n"
"    <td>1</td>\n"
"    <td>.</td>\n"
"    <td>2</td>\n"
"    <td>.</td>\n"
"    <td>3</td>\n"
"    <td>.</td>\n"
"    <td>4</td>\n"
"    <td>.</td>\n"
"  </tr>\n"
"  <tr>\n"
"    <td><strong>velocity</strong></td>\n"
"    <td>10.0</td>\n"
"    <td>20.0</td>\n"
"    <td>.</td>\n"
"    <td>30.0</td>\n"
"    <td>.</td>\n"
"    <td>25.0</td>\n"
"    <td>.</td>\n"
"    <td>20.0</td>\n"
"    <td>.</td>\n"
"    <td>30.0</td>\n"
"  </tr>\n"
"</table>"
msgstr ""
"<table>\n"
"  <tr>\n"
"    <td><strong>i</strong></td>\n"
"    <td>0</td>\n"
"    <td>.</td>\n"
"    <td>1</td>\n"
"    <td>.</td>\n"
"    <td>2</td>\n"
"    <td>.</td>\n"
"    <td>3</td>\n"
"    <td>.</td>\n"
"    <td>4</td>\n"
"    <td>.</td>\n"
"  </tr>\n"
"  <tr>\n"
"    <td><strong>velocity</strong></td>\n"
"    <td>10.0</td>\n"
"    <td>20.0</td>\n"
"    <td>.</td>\n"
"    <td>30.0</td>\n"
"    <td>.</td>\n"
"    <td>25.0</td>\n"
"    <td>.</td>\n"
"    <td>20.0</td>\n"
"    <td>.</td>\n"
"    <td>30.0</td>\n"
"  </tr>\n"
"</table>"

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:206
msgid ""
"*   The program must have a `print` statement *outside* the body of the loop"
msgstr ""
"El programa debe tener una declaración `print` *fuera* del cuerpo del bucle."

#: python-novice-gapminder/_episodes/13-conditionals.md:207
msgid ""
"    to show the final value of `velocity`,\n"
"    since its value is updated by the last iteration of the loop."
msgstr ""
"para mostrar el valor final de 'velocity',\n"
"ya que su valor se actualiza hasta la última iteración del bucle"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:210
msgid "> ## Compound Relations Using `and`, `or`, and Parentheses"
msgstr "> ## Relaciones Compuestas Usando `and`,` or`, y Paréntesis"

#: python-novice-gapminder/_episodes/13-conditionals.md:211
msgid ""
">\n"
"> Often, you want some combination of things to be true.  You can combine\n"
"> relations within a conditional using `and` and `or`.  Continuing the example\n"
"> above, suppose you have\n"
">\n"
"> ~~~\n"
"> mass     = [ 3.54,  2.07,  9.22,  1.86,  1.71]\n"
"> velocity = [10.00, 20.00, 30.00, 25.00, 20.00]\n"
">\n"
"> i = 0\n"
"> for i in range(5):\n"
">     if mass[i] > 5 and velocity[i] > 20:\n"
">         print(\"Fast heavy object.  Duck!\")\n"
">     elif mass[i] > 2 and mass[i] <= 5 and velocity[i] <= 20:\n"
">         print(\"Normal traffic\")\n"
">     elif mass[i] <= 2 and velocity[i] <= 20:\n"
">         print(\"Slow light object.  Ignore it\")\n"
">     else:\n"
">         print(\"Whoa!  Something is up with the data.  Check it\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> Just like with arithmetic, you can and should use parentheses whenever there\n"
"> is possible ambiguity.  A good general rule is to *always* use parentheses\n"
"> when mixing `and` and `or` in the same condition.  That is, instead of:\n"
">\n"
"> ~~~\n"
"> if mass[i] <= 2 or mass[i] >= 5 and velocity[i] > 20:\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> write one of these:\n"
">\n"
"> ~~~\n"
"> if (mass[i] <= 2 or mass[i] >= 5) and velocity[i] > 20:\n"
"> if mass[i] <= 2 or (mass[i] >= 5 and velocity[i] > 20):\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> so it is perfectly clear to a reader (and to Python) what you really mean."
msgstr ""
">\n"
"> A menudo, quieres alguna combinación de cosas para que la condición sea verdadera. Puedes combinar\n"
"> relaciones dentro de un condicional usando `and` y `or`. Continuando con el ejemplo\n"
"> arriba, suponga que tienes\n"
">\n"
"> ~~~\n"
"> mass     = [ 3.54,  2.07,  9.22,  1.86,  1.71]\n"
"> velocity = [10.00, 20.00, 30.00, 25.00, 20.00]\n"
">\n"
"> i = 0\n"
"> for i in range(5):\n"
">     if mass[i] > 5 and velocity[i] > 20:\n"
">         print(\"Fast heavy object.  Duck!\")\n"
">     elif mass[i] > 2 and mass[i] <= 5 and velocity[i] <= 20:\n"
">         print(\"Normal traffic\")\n"
">     elif mass[i] <= 2 and velocity[i] <= 20:\n"
">         print(\"Slow light object.  Ignore it\")\n"
">     else:\n"
">         print(\"Whoa!  Something is up with the data.  Check it\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> Al igual que con la aritmética, debes usar paréntesis siempre que\n"
"> se presente una posible ambigüedad. Una buena regla general es *siempre* usar paréntesis\n"
"> al mezclar `and` y` or` en la misma condición. Es decir, en lugar de:\n"
">\n"
"> ~~~\n"
"> if mass[i] <= 2 or mass[i] >= 5 and velocity[i] > 20:\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> escribe uno de estos:\n"
">\n"
"> ~~~\n"
"> if (mass[i] <= 2 or mass[i] >= 5) and velocity[i] > 20:\n"
"> if mass[i] <= 2 or (mass[i] >= 5 and velocity[i] > 20):\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> así que es perfectamente claro para un lector (y para Python) lo que realmente quieres decir."

#: python-novice-gapminder/_episodes/13-conditionals.md:254
msgid ""
">\n"
"> What does this program print?\n"
">\n"
"> ~~~\n"
"> pressure = 71.9\n"
"> if pressure > 50.0:\n"
">     pressure = 25.0\n"
"> elif pressure <= 50.0:\n"
">     pressure = 0.0\n"
"> print(pressure)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > 25.0\n"
"> > ~~~\n"
"> > {: .output}"
msgstr ""
">\n"
"> ¿Qué imprime este programa?\n"
">\n"
"> ~~~\n"
"> pressure = 71.9\n"
"> if pressure > 50.0:\n"
">     pressure = 25.0\n"
"> elif pressure <= 50.0:\n"
">     pressure = 0.0\n"
"> print(pressure)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Solución\n"
"> >\n"
"> > ~~~\n"
"> > 25.0\n"
"> > ~~~\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:276
msgid "> ## Trimming Values"
msgstr "> ## Recorte de valores"

#: python-novice-gapminder/_episodes/13-conditionals.md:277
msgid ""
">\n"
"> Fill in the blanks so that this program creates a new list\n"
"> containing zeroes where the original list's values were negative\n"
"> and ones where the original list's values were positive.\n"
">\n"
"> ~~~\n"
"> original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]\n"
"> result = ____\n"
"> for value in original:\n"
">     if ____:\n"
">         result.append(0)\n"
">     else:\n"
">         ____\n"
"> print(result)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> ~~~\n"
"> [0, 1, 1, 1, 0, 1]\n"
"> ~~~"
msgstr ""
">\n"
"> Complete los espacios en blanco para que este programa cree una nueva lista\n"
"> que contenga ceros (0) donde los valores de la lista original eran negativos\n"
"> y unos (1) donde los valores de la lista original eran positivos\n"
">\n"
"> ~~~\n"
"> original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]\n"
"> result = ____\n"
"> for value in original:\n"
">     if ____:\n"
">         result.append(0)\n"
">     else:\n"
">         ____\n"
"> print(result)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> ~~~\n"
"> [0, 1, 1, 1, 0, 1]\n"
"> ~~~"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:299
msgid "> >"
msgstr "> >"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:301
msgid "> > original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]"
msgstr "> > original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:302
msgid "> > result = []"
msgstr "> > result = []"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:303
msgid "> > for value in original:"
msgstr "> > for value in original:"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:304
msgid "> >     if value<0.0:"
msgstr "> >     if value<0.0:"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:305
msgid "> >         result.append(0)"
msgstr "> >         result.append(0)"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:306
msgid "> >     else:"
msgstr "> >     else:"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:307
msgid "> >         result.append(1)"
msgstr "> >         result.append(1)"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:308
msgid "> > print(result)"
msgstr "> > print(result)"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:310
msgid "> > {: .language-python}"
msgstr "> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:314
msgid "> ## Processing Small Files"
msgstr "> ## Procesando archivos pequeños"

#: python-novice-gapminder/_episodes/13-conditionals.md:315
msgid ""
">\n"
"> Modify this program so that it only processes files with fewer than 50 records.\n"
">\n"
"> ~~~\n"
"> import glob\n"
"> import pandas as pd\n"
"> for filename in glob.glob('data/*.csv'):\n"
">     contents = pd.read_csv(filename)\n"
">     ____:\n"
">         print(filename, len(contents))\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > import glob\n"
"> > import pandas as pd\n"
"> > for filename in glob.glob('data/*.csv'):\n"
"> >     contents = pd.read_csv(filename)\n"
"> >     if len(contents)<50:\n"
"> >         print(filename, len(contents))\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> Modifica este programa de manera que solo procese archivos con menos de 50 registros.\n"
">\n"
"> ~~~\n"
"> import glob\n"
"> import pandas as pd\n"
"> for filename in glob.glob('data/*.csv'):\n"
">     contents = pd.read_csv(filename)\n"
">     ____:\n"
">         print(filename, len(contents))\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solución\n"
"> >\n"
"> > ~~~\n"
"> > import glob\n"
"> > import pandas as pd\n"
"> > for filename in glob.glob('data/*.csv'):\n"
"> >     contents = pd.read_csv(filename)\n"
"> >     if len(contents)<50:\n"
"> >         print(filename, len(contents))\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:341
msgid "> ## Initializing"
msgstr "> ## Iniciando"

#: python-novice-gapminder/_episodes/13-conditionals.md:342
msgid ""
">\n"
"> Modify this program so that it finds the largest and smallest values in the list\n"
"> no matter what the range of values originally is.\n"
">\n"
"> ~~~\n"
"> values = [...some test data...]\n"
"> smallest, largest = None, None\n"
"> for v in values:\n"
">     if ____:\n"
">         smallest, largest = v, v\n"
">     ____:\n"
">         smallest = min(____, v)\n"
">         largest = max(____, v)\n"
"> print(smallest, largest)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> What are the advantages and disadvantages of using this method\n"
"> to find the range of the data?\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > values = [-2,1,65,78,-54,-24,100]\n"
"> > smallest, largest = None, None\n"
"> > for v in values:\n"
"> >     if smallest==None and largest==None:\n"
"> >         smallest, largest = v, v\n"
"> >     else:\n"
"> >         smallest = min(smallest, v)\n"
"> >         largest = max(largest, v)\n"
"> > print(smallest, largest)\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"Modifique este programa para que encuentre los valores más altos y más bajos en la lista \n"
"> sin importar cuál sea el rango de valores originalmente.\n"
">\n"
"> ~~~\n"
"> values = [...some test data...]\n"
"> smallest, largest = None, None\n"
"> for v in values:\n"
">     if ____:\n"
">         smallest, largest = v, v\n"
">     ____:\n"
">         smallest = min(____, v)\n"
">         largest = max(____, v)\n"
"> print(smallest, largest)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> ¿Cuáles son las ventajas y desventajas de usar este método\n"
"> para encontrar el rango de los datos?\n"
"> > ## Solución\n"
"> >\n"
"> > ~~~\n"
"> > values = [-2,1,65,78,-54,-24,100]\n"
"> > smallest, largest = None, None\n"
"> > for v in values:\n"
"> >     if smallest==None and largest==None:\n"
"> >         smallest, largest = v, v\n"
"> >     else:\n"
"> >         smallest = min(smallest, v)\n"
"> >         largest = max(largest, v)\n"
"> > print(smallest, largest)\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:378
msgid "> ## Using Functions With Conditionals in Pandas"
msgstr "> ## Uso de Funciones con Condicionales en Pandas"

#: python-novice-gapminder/_episodes/13-conditionals.md:379
msgid ""
">\n"
"> Functions will often contain conditionals.  Here is a short example that\n"
"> will indicate which quartile the argument is in based on hand-coded values\n"
"> for the quartile cut points.\n"
">\n"
"> ~~~\n"
"> def calculate_life_quartile(exp):\n"
">     if exp < 58.41:\n"
">         # This observation is in the first quartile\n"
">         return 1\n"
">     elif exp >= 58.41 and exp < 67.05:\n"
">         # This observation is in the second quartile\n"
">        return 2\n"
">     elif exp >= 67.05 and exp < 71.70:\n"
">         # This observation is in the third quartile\n"
">        return 3\n"
">     elif exp >= 71.70:\n"
">         # This observation is in the fourth quartile\n"
">        return 4\n"
">     else:\n"
">         # This observation has bad data\n"
">        return None\n"
">\n"
"> calculate_life_quartile(62.5)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> ~~~\n"
"> 2\n"
"> ~~~"
msgstr ""
">\n"
"> Las funciones a menudo contienen condicionales. Aquí hay un breve ejemplo que\n"
"> indicará en qué cuartil se encuentra el argumento basado en valores codificados a mano\n"
"> para los puntos de corte del cuartil.\n"
">\n"
"> ~~~\n"
"> def calculate_life_quartile(exp):\n"
">     if exp < 58.41:\n"
">         # This observation is in the first quartile\n"
">         return 1\n"
">     elif exp >= 58.41 and exp < 67.05:\n"
">         # This observation is in the second quartile\n"
">        return 2\n"
">     elif exp >= 67.05 and exp < 71.70:\n"
">         # This observation is in the third quartile\n"
">        return 3\n"
">     elif exp >= 71.70:\n"
">         # This observation is in the fourth quartile\n"
">        return 4\n"
">     else:\n"
">         # This observation has bad data\n"
">        return None\n"
">\n"
"> calculate_life_quartile(62.5)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> ~~~\n"
"> 2\n"
"> ~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:410
msgid ""
">\n"
"> That function would typically be used within a `for` loop, but Pandas has\n"
"> a different, more efficient way of doing the same thing, and that is by\n"
"> *applying* a function to a dataframe or a portion of a dataframe.  Here\n"
"> is an example, using the definition above.\n"
">\n"
"> ~~~\n"
"> data = pd.read_csv('Americas-data.csv')\n"
"> data['life_qrtl'] = data['lifeExp'].apply(calculate_life_quartile)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> There is a lot in that second line, so let's take it piece by piece.\n"
"> On the right side of the `=` we start with `data['lifeExp']`, which is the\n"
"> column in the dataframe called `data` labeled `lifExp`.  We use the\n"
"> `apply()` to do what it says, apply the `calculate_life_quartile` to the\n"
"> value of this column for every row in the dataframe."
msgstr ""
">\n"
"> Esa función normalmente se usaría dentro de un bucle `for`, pero Pandas tiene\n"
"> una forma diferente y más eficiente de hacer lo mismo, y eso es mediante\n"
"> *aplicando* una función a un **dataframe** o una parte de ello. El siguiente\n"
"> ejemplo, usa la definición anterior.\n"
"> ~~~\n"
"> data = pd.read_csv('Americas-data.csv')\n"
"> data['life_qrtl'] = data['lifeExp'].apply(calculate_life_quartile)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> Hay mucho en esa segunda línea, así que vamos a tomarlo pieza por pieza.\n"
"> En el lado derecho de `=` comenzamos con `data ['lifeExp']`, que es la\n"
"> columna en el **dataframe** llamado `data` con la etiqueta` lifExp`. Usamos el\n"
"> `apply()` para hacer lo que dice, aplique el 'calculate_life_quartile` al\n"
"> valor de esta columna para cada fila en el **dataframe**."
