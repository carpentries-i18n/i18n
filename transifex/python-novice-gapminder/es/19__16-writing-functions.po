# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Ariel Silvio Norberto RAMOS <asnramos@gmail.com>, 2020
# Laura Angelone <lauraangelone3@gmail.com>, 2020
# Paula <orchid00@gmail.com>, 2020
# David PS <dps.helio@gmail.com>, 2021
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2020-05-24 19:34:12+0100\n"
"PO-Revision-Date: 2020-05-24 19:14+0000\n"
"Last-Translator: David PS <dps.helio@gmail.com>, 2021\n"
"Language-Team: Spanish (https://www.transifex.com/carpentries-i18n/teams/98915/es/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

# Front Matter
#: python-novice-gapminder/_episodes/16-writing-functions.md:1
msgid ""
"---\n"
"title: \"Writing Functions\"\n"
"teaching: 10\n"
"exercises: 15\n"
"questions:\n"
"- \"How can I create my own functions?\"\n"
"objectives:\n"
"- \"Explain and identify the difference between function definition and function call.\"\n"
"- \"Write a function that takes a small, fixed number of arguments and produces a single result.\"\n"
"keypoints:\n"
"- \"Break programs down into functions to make them easier to understand.\"\n"
"- \"Define a function using `def` with a name, parameters, and a block of code.\"\n"
"- \"Defining a function does not run it.\"\n"
"- \"Arguments in call are matched to parameters in definition.\"\n"
"- \"Functions may return a result to their caller using `return`.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Escribiendo Funciones\"\n"
"teaching: 10\n"
"exercises: 15\n"
"questions:\n"
"- \"¿Cómo puedo crear mis funciones?\"\n"
"objectives:\n"
"- \"Explicar e identificar la diferencia entre definir una función y el llamado de una función.\"\n"
"- \"Escribe una función que toma un número de argumentos fijo y pequeño, y produce un sólo resultado.\"\n"
"keypoints:\n"
"- \"Divide los programas en funciones para hacerlos mas entendibles o mas fácil de interpretar.\"\n"
"- \"Define una función usando `def` con nombre, parámetros, y código en bloque.\"\n"
"- \"Defining a function does not run it.\"\n"
"- \"Los argumentos en una llamada corresponden a los parametros en la definición.\"\n"
"- \"Las funciones pueden devolver un resultado, a quienes las invocan (llaman) usando `return`.\"\n"
"---"

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:17
msgid ""
"## Break programs down into functions to make them easier to understand."
msgstr ""
"## Dividir los programas en funciones para que sean mas fácil de entender."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:19
msgid ""
"*   Human beings can only keep a few items in working memory at a time."
msgstr ""
"*    Las personas pueden mantener unos pocos elementos en la memoria de "
"trabajo, cada vez que lo hacen."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:20
msgid ""
"*   Understand larger/more complicated ideas by understanding and combining "
"pieces."
msgstr ""
"*   Comprender ideas más grandes / más complicadas y saber combinar o "
"relacionar las partes."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:21
msgid "    *   Components in a machine."
msgstr "    *   Componentes en una computadora."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:22
msgid "    *   Lemmas when proving theorems."
msgstr "    *   Ideas al probar teoremas."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:23
msgid "*   Functions serve the same purpose in programs."
msgstr "*   Las funciones tienen el mismo propósito en los programas."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:24
msgid ""
"    *   *Encapsulate* complexity so that we can treat it as a single "
"\"thing\"."
msgstr ""
"    *   *Encapsular* reducir la complejidad para que podamos tratarlo como "
"una sola \"cosa\". "

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:25
msgid "*   Also enables *re-use*."
msgstr "*   También facilita el *re-uso*."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:26
msgid "    *   Write one time, use many times."
msgstr "    *   Se escribe una vez, se usa muchas veces."

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:28
msgid ""
"## Define a function using `def` with a name, parameters, and a block of "
"code."
msgstr ""
"## Definir una función usando `def` con nombre, parámetros y bloque de "
"código."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:30
msgid "*   Begin the definition of a new function with `def`."
msgstr "*   Empieza o inicia la definición de una nueva función con`def`."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:31
msgid "*   Followed by the name of the function."
msgstr "*   Seguido por el nombre de la función."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:32
msgid "    *   Must obey the same rules as variable names."
msgstr "    *   Debe respetar las normas de los nombres de las variables."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:33
msgid "*   Then *parameters* in parentheses."
msgstr "    *     Entonces los parámetros / argumentos van entre paréntesis."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:34
msgid "    *   Empty parentheses if the function doesn't take any inputs."
msgstr "    *    Paréntesis vacíos, si la función no toma ningún argumento."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:35
msgid "    *   We will discuss this in detail in a moment."
msgstr "    *    Discutiremos en detalle en un momento"

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:36
msgid "*   Then a colon."
msgstr "    *    Después un punto y coma."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:37
msgid "*   Then an indented block of code."
msgstr "    *    Después un bloque de código identado."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:39
msgid ""
"~~~\n"
"def print_greeting():\n"
"    print('Hello!')\n"
"~~~"
msgstr ""
"~~~ \n"
"def mostrar_saludos(): \n"
"    print ('¡Hola!') \n"
"~~~"

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:45
msgid "## Defining a function does not run it."
msgstr "## Definir una función, no significa que esta se ejecuta."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:47
msgid "*   Defining a function does not run it."
msgstr "* La definición de una función no la ejecuta."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:48
msgid "    *   Like assigning a value to a variable."
msgstr "* Como asignar un valor en una variable."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:49
msgid "*   Must call the function to execute the code it contains."
msgstr "* Debes llamar a la función para ejecutar el código que contiene."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:51
msgid ""
"~~~\n"
"print_greeting()\n"
"~~~"
msgstr ""
"~~~\n"
"mostrar_saludo()\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:54
msgid ""
"{: .language-python}\n"
"~~~\n"
"Hello!\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"¡Hola!\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:60
msgid "## Arguments in call are matched to parameters in definition."
msgstr ""
"## Los argumentos en la llamada corresponden a los parámetros de la "
"definición."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:62
msgid "*   Functions are most useful when they can operate on different data."
msgstr ""
"*  Las funciones son más efectivas cuando pueden operar sobre datos "
"diferentes."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:63
msgid "*   Specify *parameters* when defining a function."
msgstr "*  Especificar *parámetros* al definir una función."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:64
msgid "    *   These become variables when the function is executed."
msgstr "*  Estos se convierten en variables cuando se ejecuta la función."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:65
msgid ""
"    *   Are assigned the arguments in the call (i.e., the values passed to "
"the function)."
msgstr ""
"* Se asignan los argumentos en la llamada (es decir, los valores se pasan "
"​​a la función)."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:66
msgid ""
"    *   If you don't name the arguments when using them in the call, the "
"arguments will be matched to"
msgstr ""
"* Si no invoca los argumentos cuando los usa en la llamada, los argumentos "
"se compararán con los"

#: python-novice-gapminder/_episodes/16-writing-functions.md:67
msgid "parameters in the order the parameters are defined in the function."
msgstr "parámetros en el orden definido en la función."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:69
msgid ""
"~~~\n"
"def print_date(year, month, day):\n"
"    joined = str(year) + '/' + str(month) + '/' + str(day)\n"
"    print(joined)\n"
"\n"
"print_date(1871, 3, 19)\n"
"~~~"
msgstr ""
"~~~ \n"
"def mostrar_fecha (year, mes, día): \n"
"    unido = str (year) + '/' + str (mes) + '/' + str (dia) \n"
"    print (unido) \n"
"\n"
"mostrar_fecha (1871, 3, 19) \n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:76
msgid ""
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:82
msgid ""
"Or, we can name the arguments when we call the function, which allows us to\n"
"specify them in any order:\n"
"~~~\n"
"print_date(month=3, day=19, year=1871)\n"
"~~~\n"
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"~~~"
msgstr ""
"O bien, podemos nombrar los argumentos cuando llamamos a la función, lo que nos permite\n"
"especificarlos en cualquier orden:\n"
"~~~\n"
"print_date(mes=3, dia=19, year=1871)\n"
"~~~\n"
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"~~~"

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:93
msgid ""
"*   Via "
"[Twitter](https://twitter.com/minisciencegirl/status/693486088963272705):"
msgstr ""
"*   Via "
"[Twitter](https://twitter.com/minisciencegirl/status/693486088963272705):"

#: python-novice-gapminder/_episodes/16-writing-functions.md:94
msgid ""
"    `()` contains the ingredients for the function\n"
"    while the body contains the recipe."
msgstr ""
"    `()` contiene las componentes de la función\n"
"    mientras el cuerpo contiene la fórmula."

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:97
msgid "## Functions may return a result to their caller using `return`."
msgstr ""
"## Las funciones pueden devolver un resultado a quien la llama usando "
"`return`."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:99
msgid "*   Use `return ...` to give a value back to the caller."
msgstr "*   Usa `return` para devolver el valor."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:100
msgid "*   May occur anywhere in the function."
msgstr "*  Puede ocurrir en cualquier parte de la función."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:101
msgid "*   But functions are easier to understand if `return` occurs:"
msgstr ""
"*   Pero las funciones son más fácil de entender si tienen un `return`:"

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:102
msgid "    *   At the start to handle special cases."
msgstr "* Al principio para manejar casos especiales."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:103
msgid "    *   At the very end, with a final result."
msgstr " * Al final, con un resultado final."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:105
msgid ""
"~~~\n"
"def average(values):\n"
"    if len(values) == 0:\n"
"        return None\n"
"    return sum(values) / len(values)\n"
"~~~"
msgstr ""
"~~~\n"
"def average(valores):\n"
"    if len(valores) == 0:\n"
"        return None\n"
"    return sum(valores) / len(valores)\n"
"~~~"

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:113
msgid ""
"~~~\n"
"a = average([1, 3, 4])\n"
"print('average of actual values:', a)\n"
"~~~"
msgstr ""
"~~~\n"
"a = average([1, 3, 4])\n"
"print('promedio de valores:', a)\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:117
msgid ""
"{: .language-python}\n"
"~~~\n"
"average of actual values: 2.6666666666666665\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"promedio de valores: 2.6666666666666665\n"
"~~~"

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:123
msgid ""
"~~~\n"
"print('average of empty list:', average([]))\n"
"~~~"
msgstr ""
"~~~\n"
"print('promedio de la lista vacía:', average([]))\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:126
msgid ""
"{: .language-python}\n"
"~~~\n"
"average of empty list: None\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"promedio de la lista vacía: None\n"
"~~~"

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:132
msgid ""
"*   Remember: [every function returns something]({{ page.root }}/04-built-"
"in/)."
msgstr ""
"*   Recuerda: [toda función devuelve algo]({{ page.root }}/04-built-in/)."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:133
msgid ""
"*   A function that doesn't explicitly `return` a value automatically "
"returns `None`."
msgstr ""
"*   Una función que no devuelve un valor explícitamente `devuelve` "
"automáticamente `None`."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:135
msgid ""
"~~~\n"
"result = print_date(1871, 3, 19)\n"
"print('result of call is:', result)\n"
"~~~"
msgstr ""
"~~~\n"
"resultado = print_date(1871, 3, 19)\n"
"print('resultado de la llamada es:', resultado)\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:139
msgid ""
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"result of call is: None\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"resultado de la llamada es: None\n"
"~~~"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:146
msgid "> ## Identifying Syntax Errors"
msgstr "> ## Identificación de errores de sintaxis"

#: python-novice-gapminder/_episodes/16-writing-functions.md:147
msgid ""
">\n"
"> 1. Read the code below and try to identify what the errors are\n"
">    *without* running it.\n"
"> 2. Run the code and read the error message.\n"
">    Is it a `SyntaxError` or an `IndentationError`?\n"
"> 3. Fix the error.\n"
"> 4. Repeat steps 2 and 3 until you have fixed all the errors.\n"
">\n"
"> ~~~\n"
"> def another_function\n"
">   print(\"Syntax errors are annoying.\")\n"
">    print(\"But at least python tells us about them!\")\n"
">   print(\"So they are usually not too hard to fix.\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > def another_function():\n"
"> >   print(\"Syntax errors are annoying.\")\n"
"> >   print(\"But at least Python tells us about them!\")\n"
"> >   print(\"So they are usually not too hard to fix.\")\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> 1. Lee el código a continuación e intente identificar cuáles son los errores\n"
">     *sin* ejecutarlo.\n"
"> 2. Corre el código y lee el mensaje de error.\n"
">    Es un `SyntaxError` o un `IndentationError`?\n"
"> 3. Corrige el error.\n"
"> 4. Repite los pasos 2 y 3 hasta que hasta que haya solucionado todos los errores.\n"
">\n"
"> ~~~\n"
"> def another_function\n"
">   print(\"Los errores de sintaxis son molestos.\")\n"
">    print(\"¡Pero al menos Python nos cuenta sobre ellos!\")\n"
">   print(\"Generalmente no son demasiado difíciles de arreglar.\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Solución\n"
"> >\n"
"> > ~~~\n"
"> > def another_function():\n"
"> >   print(\"Los errores de sintaxis son molestos.\")\n"
"> >   print(\"¡Pero al menos Python nos cuenta sobre ellos!\")\n"
"> >   print(\"Generalmente no son demasiado difíciles de arreglar.\")\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:175
msgid "> ## Definition and Use"
msgstr "> ## Definición y Uso"

#: python-novice-gapminder/_episodes/16-writing-functions.md:176
msgid ""
">\n"
"> What does the following program print?\n"
">\n"
"> ~~~\n"
"> def report(pressure):\n"
">     print('pressure is', pressure)\n"
">\n"
"> print('calling', report, 22.5)\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > calling <function report at 0x7fd128ff1bf8> 22.5\n"
"> > ~~~ \n"
"> > {: .output}\n"
"> >\n"
"> > A function call always needs parenthesis, otherwise you get memory address of the function object. So, if we wanted to call the function named report, and give it the value 22.5 to report on, we could have our function call as follows\n"
"> > ~~~\n"
"> > print(\"calling\")\n"
"> > report(22.5)\n"
"> > ~~~"
msgstr ""
">\n"
"> ¿Qué muestra el siguiente programa?\n"
">\n"
"> ~~~\n"
"> def report(presion):\n"
">     print('presion es', presion)\n"
">\n"
"> print('llamado', report, 22.5)\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solución\n"
"> >\n"
"> > ~~~\n"
"> > calling <function report at 0x7fd128ff1bf8> 22.5\n"
"> > ~~~ \n"
"> > {: .output}\n"
"> >\n"
"> > La llamada a una función siempre necesita paréntesis, de lo contrario, obtiene la dirección de memoria del objeto función. Entonces, si queremos llamar a la función de nombre report, y le damos el valor 22.5, podríamos tener la llamada a la función de la siguiente manera\n"
"> > ~~~\n"
"> > print(\"llamada\")\n"
"> > report(22.5)\n"
"> > ~~~"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:202
msgid "> ## Order of Operations"
msgstr "> ## Orden de Operaciones"

#: python-novice-gapminder/_episodes/16-writing-functions.md:203
msgid ""
">\n"
"> The example above:\n"
">\n"
"> ~~~\n"
"> result = print_date(1871, 3, 19)\n"
"> print('result of call is:', result)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> printed:\n"
"> ~~~\n"
"> 1871/3/19\n"
"> result of call is: None\n"
"> ~~~"
msgstr ""
">\n"
"> El ejemplo anterior:\n"
">\n"
"> ~~~\n"
"> resultado = print_date(1871, 3, 19)\n"
"> print('resultado de la llamada es:', resultado)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> muestra:\n"
"> ~~~\n"
"> 1871/3/19\n"
"> resultado de la llamada es: None\n"
"> ~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:218
msgid ""
">\n"
"> Explain why the two lines of output appeared in the order they did.\n"
">\n"
"> What's wrong in this example?\n"
"> ~~~\n"
"> result = print_date(1871,3,19)\n"
">\n"
"> def print_date(year, month, day):\n"
">    joined = str(year) + '/' + str(month) + '/' + str(day)\n"
">    print(joined)\n"
"> ~~~\n"
"> {: .language-python}\n"
"> \n"
"> > ## Solution\n"
"> > \n"
"> > 1. The first line of output (`1871/3/19`) is from the print function inside `print_date()`, while the second line\n"
"> > is from the print function below the function call. All of the code inside `print_date()` is executed first, and\n"
"> > the program then \"leaves\" the function and executes the rest of the code.   \n"
"> > 2. The problem with the example is that the function is defined *after* the call to the function is made. Python\n"
"> > therefore doesn't understand the function call."
msgstr ""
">\n"
"> Explica por qué las dos líneas de salida aparecieron en el orden en que lo hicieron.\n"
">\n"
"> ¿Qué hay de malo en este ejemplo?\n"
"> ~~~\n"
"> resultado = print_date(1871,3,19)\n"
">\n"
"> def print_date(year, mes, dia):\n"
">    joined = str(year) + '/' + str(mes) + '/' + str(dia)\n"
">    print(joined)\n"
"> ~~~\n"
"> {: .language-python}\n"
"> \n"
"> > ## Solution\n"
"> > \n"
"> > 1. La primer línea de salida (`1871/3/19`) es lo que muestra la función dentro de `print_date()`, mientras que la segunda línea\n"
"> > lo que muestra está debajo de la llamadaa la función. Todo el código dentro de `print_date ()` se ejecuta primero, y\n"
"> > el programa luego \"deja\" la función y ejecuta el resto del código. \n"
"> > 2. El problema con el ejemplo es que la función se define * después de * que se realiza la llamada a la función. Python\n"
"> > por lo tanto no entiende la llamada a la función."

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:241
msgid "> ## Encapsulation"
msgstr "> ## Encapsulamiento"

#: python-novice-gapminder/_episodes/16-writing-functions.md:242
msgid ""
">\n"
"> Fill in the blanks to create a function that takes a single filename as an argument,\n"
"> loads the data in the file named by the argument,\n"
"> and returns the minimum value in that data.\n"
">\n"
"> ~~~\n"
"> import pandas as pd\n"
">\n"
"> def min_in_data(____):\n"
">     data = ____\n"
">     return ____\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > import pandas as pd\n"
"> > \n"
"> > def min_in_data(filename):\n"
"> >     data = pd.read_csv(filename)\n"
"> >     return data.min()\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> Completa los espacios en blanco para crear una función que tome un nombre de archivo como argumento,\n"
"> cargue los datos de ese archivo pasado como argumento,\n"
"> y devuelva el mínimo valor de esos datos.\n"
">\n"
"> ~~~\n"
"> import pandas as pd\n"
">\n"
"> def min_in_data(____):\n"
">     data = ____\n"
">     return ____\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solución\n"
"> >\n"
"> > ~~~\n"
"> > import pandas as pd\n"
"> > \n"
"> > def min_in_data(filename):\n"
"> >     data = pd.read_csv(filename)\n"
"> >     return data.min()\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:268
msgid "> ## Find the First"
msgstr "> ## Encuentra el primero"

#: python-novice-gapminder/_episodes/16-writing-functions.md:269
msgid ""
">\n"
"> Fill in the blanks to create a function that takes a list of numbers as an argument\n"
"> and returns the first negative value in the list.\n"
"> What does your function do if the list is empty?\n"
">\n"
"> ~~~\n"
"> def first_negative(values):\n"
">     for v in ____:\n"
">         if ____:\n"
">             return ____\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > def first_negative(values):\n"
"> >     for v in values:\n"
"> >         if v<0:\n"
"> >             return v\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > If an empty list is passed to this function, it returns `None`:\n"
"> > ~~~\n"
"> > my_list = []\n"
"> > print(first_negative(my_list))\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > ~~~\n"
"> > None\n"
"> > ~~~\n"
"> > {: .output}"
msgstr ""
">\n"
"> Completa los espacios en blanco para crear una función que tome una lista de números como argumento\n"
"> y devuelva el primer valor negativo en la lista.\n"
"> ¿Qué hace su función si la lista está vacía?\n"
">\n"
"> ~~~\n"
"> def first_negative(valores):\n"
">     for v in ____:\n"
">         if ____:\n"
">             return ____\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > def first_negative(valores):\n"
"> >     for v in valores:\n"
"> >         if v<0:\n"
"> >             return v\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > Si se pasa una lista vacía a esta función, devuelve `None`:\n"
"> > ~~~\n"
"> > my_list = []\n"
"> > print(first_negative(my_list))\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > ~~~\n"
"> > None\n"
"> > ~~~\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:303
msgid "> ## Calling by Name"
msgstr "> ## Llamando por nombre"

#: python-novice-gapminder/_episodes/16-writing-functions.md:304
msgid ""
">\n"
"> Earlier we saw this function:\n"
">\n"
"> ~~~\n"
"> def print_date(year, month, day):\n"
">     joined = str(year) + '/' + str(month) + '/' + str(day)\n"
">     print(joined)\n"
"> ~~~\n"
"> We saw that we can call the function using *named arguments*, like this:\n"
"> ~~~\n"
"> print_date(day=1, month=2, year=2003)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 1.  What does `print_date(day=1, month=2, year=2003)` print?\n"
"> 2.  When have you seen a function call like this before?\n"
"> 3.  When and why is it useful to call functions this way?\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> > \n"
"> > 1. `2003/2/1`\n"
"> > 2. We saw examples of using *named arguments* when working with the pandas library. For example, when reading in a dataset \n"
"> > using `data = pd.read_csv('data/gapminder_gdp_europe.csv', index_col='country')`, the last argument `index_col` is a \n"
"> > named argument.  \n"
"> > 3. Using named arguments can make code more readable since one can see from the function call what name the different arguments \n"
"> > have inside the function. It can also reduce the chances of passing arguments in the wrong order, since by using named arguments \n"
"> > the order doesn't matter."
msgstr ""
">\n"
"> Anteriormente vimos esta función:\n"
">\n"
"> ~~~\n"
"> def print_date(year, mes, dia):\n"
">     joined = str(year) + '/' + str(mes) + '/' + str(dia)\n"
">     print(joined)\n"
"> ~~~\n"
"> Vimos que podemos llamar a la función usando *argumentos con nombres*, así:\n"
"> ~~~\n"
"> print_date(dia=1, mes=2, year=2003)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 1.  ¿Qué muestra`print_date (dia = 1, mes = 2, year = 2003)`?\n"
"> 2.  ¿Cuándo has visto una llamada a una función como esta antes?\n"
"> 3.  ¿Cuándo y por qué es útil llamar a las funciones de esta manera?\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> > \n"
"> > 1. `2003/2/1`\n"
"> > 2. Vimos ejemplos de uso de *argumentos con nombre* al trabajar con la biblioteca de Pandas. Por ejemplo, al leer en un conjunto de datos \n"
"> > using `data = pd.read_csv('data/gapminder_gdp_europe.csv', index_col='country')`, el último argumento `index_col` es un \n"
"> > nombre de argumento.  \n"
"> > 3. El uso de argumentos con nombre puede hacer que el código sea más legible ya que uno puede ver desde la llamada de función qué nombre tienen los diferentes argumentos  \n"
"> > dentro de la función. También puede reducir las posibilidades de pasar argumentos en el orden incorrecto, ya que al usar argumentos con nombre \n"
"> > el orden no importa."

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:334
msgid "> ## Encapsulate of If/Print Block"
msgstr "> ## Encapsular un bloque de If/Print"

#: python-novice-gapminder/_episodes/16-writing-functions.md:335
msgid ""
">\n"
"> The code below will run on a label-printer for chicken eggs.  A digital scale will report a chicken egg mass (in grams) to the computer and then the computer will print a label.  \n"
">\n"
"> Please re-write the code so that the if-block is folded into a function.\n"
">\n"
"> ~~~\n"
">  import random\n"
">  for i in range(10):\n"
">\n"
">     # simulating the mass of a chicken egg\n"
">     # the (random) mass will be 70 +/- 20 grams\n"
">     mass=70+20.0*(2.0*random.random()-1.0)\n"
">\n"
">     print(mass)\n"
">    \n"
">     #egg sizing machinery prints a label\n"
">     if(mass>=85):\n"
">        print(\"jumbo\")\n"
">     elif(mass>=70):\n"
">        print(\"large\")\n"
">     elif(mass<70 and mass>=55):\n"
">        print(\"medium\")\n"
">     else:\n"
">        print(\"small\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
">\n"
"> The simplified program  follows.  What function definition will make it functional?\n"
">\n"
"> ~~~\n"
">  # revised version\n"
">  import random\n"
">  for i in range(10):\n"
">\n"
">     # simulating the mass of a chicken egg\n"
">     # the (random) mass will be 70 +/- 20 grams\n"
">     mass=70+20.0*(2.0*random.random()-1.0)\n"
">\n"
">     print(mass,print_egg_label(mass))    \n"
">\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
">\n"
"> 1. Create a function definition for `print_egg_label()` that will work with the revised program above.  Note, the function's return value will be significant. Sample output might be `71.23 large`.\n"
"> 2.  A dirty egg might have a mass of more than 90 grams, and a spoiled or broken egg will probably have a mass that's less than 50 grams.  Modify your `print_egg_label()` function to account for these error conditions. Sample output could be `25 too light, probably spoiled`.\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > def print_egg_label(mass):\n"
"> >     #egg sizing machinery prints a label\n"
"> >     if(mass>=90):\n"
"> >         return(\"warning: egg might be dirty\")\n"
"> >     elif(mass>=85):\n"
"> >         return(\"jumbo\")\n"
"> >     elif(mass>=70):\n"
"> >         return(\"large\")\n"
"> >     elif(mass<70 and mass>=55):\n"
"> >         return(\"medium\")\n"
"> >     elif(mass<50):\n"
"> >         return(\"too light, probably spoiled\")\n"
"> >     else:\n"
"> >         return(\"small\")\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> El siguiente código se ejecutará en una impresora de etiquetas para huevos de gallina. Una balanza digital informará una masa de huevo de gallina (en gramos) a la computadora y luego la computadora imprimirá una etiqueta.\n"
">\n"
"> Vuelve a escribir el código para que el bloque if se despliegue en una función.\n"
">\n"
"> ~~~\n"
">  import random\n"
">  for i in range(10):\n"
">\n"
">     # simulando la masa de un huevo de gallina\n"
">     # la masa (random) será 70 +/- 20 gramos\n"
">     masa=70+20.0*(2.0*random.random()-1.0)\n"
">\n"
">     print(masa)\n"
">    \n"
">     #la maquinaria de dimensionamiento de huevos imprime una etiqueta\n"
">     if(masa>=85):\n"
">        print(\"super\")\n"
">     elif(masa>=70):\n"
">        print(\"grande\")\n"
">     elif(masa<70 and mass>=55):\n"
">        print(\"medio\")\n"
">     else:\n"
">        print(\"pequeño\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
">\n"
"> El programa sigue. ¿Qué definición de función lo hará funcional?\n"
">\n"
"> ~~~\n"
">  # versión revisada\n"
">  import random\n"
">  for i in range(10):\n"
">\n"
">     # simulando la masa de un huevo de gallina\n"
">     # la masa (random) será 70 +/- 20 gramos\n"
">     masa=70+20.0*(2.0*random.random()-1.0)\n"
">\n"
">     print(masa,print_egg_label(masa))    \n"
">\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
">\n"
"> 1. Crea una definición de función para `print_egg_label ()` que funcionará con el programa anterior. Ten en cuenta que el valor de retorno de la función sea significativo. La salida puede ser '71.23 grande'.\n"
"> 2.  Un huevo sucio puede tener una masa de más de 90 gramos, y un huevo estropeado o roto probablemente tendrá una masa de menos de 50 gramos. Modifica tu función `print_egg_label ()` para tener en cuenta estas condiciones de error. La salida podría ser '25 demasiado ligera, probablemente estropeada'.\n"
">\n"
"> > ## Solución\n"
"> >\n"
"> > ~~~\n"
"> > def print_egg_label(masa):\n"
"> >     #la maquinaria de dimensionamiento de huevos imprime una etiqueta\n"
"> >     if(masa>=90):\n"
"> >         return(\"cuidado: el huevo debe estar sucio\")\n"
"> >     elif(masa>=85):\n"
"> >         return(\"super\")\n"
"> >     elif(masa>=70):\n"
"> >         return(\"grande\")\n"
"> >     elif(masa<70 and mass>=55):\n"
"> >         return(\"mediano\")\n"
"> >     elif(masa<50):\n"
"> >         return(\"Demasiado ligero, probablemente roto\")\n"
"> >     else:\n"
"> >         return(\"pequenio\")\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:405
msgid "> ## Encapsulating Data Analysis"
msgstr "> ## Encapsulando Análisis de Datos"

#: python-novice-gapminder/_episodes/16-writing-functions.md:406
msgid ""
">\n"
"> Assume that the following code has been executed:\n"
">\n"
"> ~~~\n"
"> import pandas as pd\n"
">\n"
"> df = pd.read_csv('data/gapminder_gdp_asia.csv', index_col=0)\n"
"> japan = df.loc['Japan']\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 1.Complete the statements below to obtain the average GDP for Japan\n"
"> across the years reported for the 1980s.\n"
">\n"
"> ~~~\n"
"> year = 1983\n"
"> gdp_decade = 'gdpPercap_' + str(year // ____)\n"
"> avg = (japan.loc[gdp_decade + ___] + japan.loc[gdp_decade + ___]) / 2\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 2.Abstract the code above into a single function.\n"
">\n"
"> ~~~\n"
"> def avg_gdp_in_decade(country, continent, year):\n"
">     df = pd.read_csv('data/gapminder_gdp_'+___+'.csv',delimiter=',',index_col=0)\n"
">     ____\n"
">     ____\n"
">     ____\n"
">     return avg\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 3.How would you generalize this function\n"
">    if you did not know beforehand which specific years occurred as columns in the data?\n"
">    For instance, what if we also had data from years ending in 1 and 9 for each decade?\n"
">    (Hint: use the columns to filter out the ones that correspond to the decade,\n"
">    instead of enumerating them in the code.)\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > 1.\n"
"> >\n"
"> > ~~~\n"
"> > year = 1983\n"
"> > gdp_decade = 'gdpPercap_' + str(year // 10)\n"
"> > avg = (japan.loc[gdp_decade + '2'] + japan.loc[gdp_decade + '7']) / 2\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 2.\n"
"> >\n"
"> > ~~~\n"
"> > def avg_gdp_in_decade(country, continent, year):\n"
"> >     df = pd.read_csv('data/gapminder_gdp_' + continent + '.csv', index_col=0)\n"
"> >     c = df.loc[country]\n"
"> >     gdp_decade = 'gdpPercap_' + str(year // 10)\n"
"> >     avg = (c.loc[gdp_decade + '2'] + c.loc[gdp_decade + '7'])/2\n"
"> >     return avg\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 3.\n"
"> > \n"
"> > We need to loop over the reported years\n"
"> >    to obtain the average for the relevant ones in the data.\n"
"> >\n"
"> > ~~~\n"
"> > def avg_gdp_in_decade(country, continent, year):\n"
"> >     df = pd.read_csv('data/gapminder_gdp_' + continent + '.csv', index_col=0)\n"
"> >     c = df.loc[country]\n"
"> >     gdp_decade = 'gdpPercap_' + str(year // 10)\n"
"> >     total = 0.0\n"
"> >     num_years = 0\n"
"> >     for yr_header in c.index: # c's index contains reported years\n"
"> >         if yr_header.startswith(gdp_decade):\n"
"> >             total = total + c.loc[yr_header]\n"
"> >             num_years = num_years + 1\n"
"> >     return total/num_years\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > The function can now be called by:\n"
"> > ~~~\n"
"> > avg_gdp_in_decade('Japan','asia',1983)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > \n"
"> > ~~~\n"
"> > 20880.023800000003\n"
"> > ~~~\n"
"> > {: .output}"
msgstr ""
">\n"
"> Suponga que se ha ejecutado el siguiente código:\n"
">\n"
"> ~~~\n"
"> import pandas as pd\n"
">\n"
"> df = pd.read_csv('data/gapminder_gdp_asia.csv', index_col=0)\n"
"> japan = df.loc['Japan']\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 1. Complete las siguientes declaraciones para obtener el PIB promedio de Japón\n"
"> a través de los años reportados para la década de 1980.\n"
">\n"
"> ~~~\n"
"> year= 1983\n"
"> gdp_decada = 'gdpPercap_' + str(year // ____)\n"
"> prom = (japan.loc[gdp_decada + ___] + japan.loc[gdp_decada + ___]) / 2\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 2.Resuma el código anterior en una sola función.\n"
">\n"
"> ~~~\n"
"> def prom_gdp_in_decada(pais, continente, year):\n"
">     df = pd.read_csv('data/gapminder_gdp_'+___+'.csv',delimiter=',',index_col=0)\n"
">     ____\n"
">     ____\n"
">     ____\n"
">     return prom\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 3.¿Cómo generalizarías esta función\n"
">   si no sabes de antemano qué años específicos ocurrieron como columnas de datos?\n"
">    Por ejemplo, ¿qué pasaría si también tuviéramos datos de años que terminan en 1 y 9 para cada década?\n"
">   (Sugerencia: use las columnas para filtrar las que corresponden a la década,\n"
">    en lugar de enumerarlos en el código).\n"
">\n"
"> > ## Solución\n"
"> >\n"
"> > 1.\n"
"> >\n"
"> > ~~~\n"
"> > year= 1983\n"
"> > gdp_decada = 'gdpPercap_' + str(year// 10)\n"
"> > prom = (japan.loc[gdp_decada + '2'] + japan.loc[gdp_decada + '7']) / 2\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 2.\n"
"> >\n"
"> > ~~~\n"
"> > def prom_gdp_in_decada(pais, continente, year):\n"
"> >     df = pd.read_csv('data/gapminder_gdp_' + continente + '.csv', index_col=0)\n"
"> >     c = df.loc[pais]\n"
"> >     gdp_decada = 'gdpPercap_' + str(year// 10)\n"
"> >     prom = (c.loc[gdp_decada + '2'] + c.loc[gdp_decada + '7'])/2\n"
"> >     return prom\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 3.\n"
"> > \n"
"> > Necesitamos recorrer los años reportados\n"
"> >    para obtener el promedio de los relevantes en los datos.\n"
"> >\n"
"> > ~~~\n"
"> > def prom_gdp_in_decada(pais, continente, year):\n"
"> >     df = pd.read_csv('data/gapminder_gdp_' + continente+ '.csv', index_col=0)\n"
"> >     c = df.loc[pais]\n"
"> >     gdp_decada = 'gdpPercap_' + str(year// 10)\n"
"> >     total = 0.0\n"
"> >     num_anios = 0\n"
"> >     for yr_header in c.index: # el índice de c contiene años reportados\n"
"> >         if yr_header.startswith(gdp_decada):\n"
"> >             total = total + c.loc[yr_header]\n"
"> >             num_anios = num_year + 1\n"
"> >     return total/num_year\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > La función puede ahora llamarse asi:\n"
"> > ~~~\n"
"> > prom_gdp_in_decada('Japan','Asia',1983)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > \n"
"> > ~~~\n"
"> > 20880.023800000003\n"
"> > ~~~\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:500
msgid "> ## Simulating a dynamical system"
msgstr "> ## Simulando un sistema dinámico"

#: python-novice-gapminder/_episodes/16-writing-functions.md:501
msgid ""
">\n"
"> In mathematics, a [dynamical system](https://en.wikipedia.org/wiki/Dynamical_system) is a system in which a function describes the time dependence of a point in a geometrical space.  A canonical example of a dynamical system is a system called the [logistic map](https://en.wikipedia.org/wiki/Logistic_map).\n"
">\n"
">\n"
"> 1. Define a function called `logistic_map` that takes two inputs: `x`, representing the state of the system at time _t_, and a parameter `r`. This function should return a value representing the state of the system at time _t+1_.\n"
">\n"
"> 2. Using a `for` loop, iterate the `logistic_map` function defined in part 1 starting from an initial condition of 0.5 for `t_final=10`, `100`, and `1000` periods. Store the intermediate results in a list so that after the `for` loop terminates you have accumulated a sequence of values representing the state of the logistic map at time _t=0,1,...,t_final_.\n"
">\n"
"> 3. Encapsulate the logic of your `for` loop into a function called `iterate` that takes the initial condition as its first input, the parameter `t_final` as its second input and the parameter `r` as its third input. The function should return the list of values representing the state of the logistic map at time _t=0,1,...,t_final_.\n"
">\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > 1.\n"
"> >\n"
"> > ~~~\n"
"> > def logistic_map(x, r):\n"
"> >     return r * x * (1 - x)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 2.\n"
"> >\n"
"> > ~~~\n"
"> > initial_condition = 0.5\n"
"> > t_final = 10\n"
"> > r = 1.0\n"
"> > trajectory = [initial_condition]\n"
"> > for t in range(1, t_final):\n"
"> >     trajectory.append( logistic_map(trajectory[t-1], r) )\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 3.\n"
"> > ~~~\n"
"> > def iterate(initial_condition, t_final, r):\n"
"> >     trajectory = [initial_condition]\n"
"> >     for t in range(1, t_final):\n"
"> >         trajectory.append( logistic_map(trajectory[t-1], r) )\n"
"> >     return trajectory\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> En Matemática, un [sistema dinámico](https://en.wikipedia.org/wiki/Dynamical_system) es el sistema en el que una función describe la dependencia del tiempo de un punto en un espacio geométrico.  Un ejemplo canónico de un sistema dinámico es un sistema llamado [mapa logístico](https://en.wikipedia.org/wiki/Logistic_map).\n"
">\n"
">\n"
"> 1. Define una función llamada `logistic_map` que tome dos entradas:` x`, que representa el estado del sistema en el tiempo _t_, y un parámetro `r`. Esta función deberá devolver un valor que represente el estado del sistema en el momento _t + 1_.\n"
">\n"
"> 2. Usa un bucle `for`, itera la función `logistic_map` definida en la parte 1 a partir de una condición inicial de 0.5 para los períodos `t_final = 10`,` 100` y `1000`. Almacena los resultados intermedios en una lista para que, después de que finalice el ciclo `for`, haya acumulado una secuencia de valores que representan el estado del mapa logístico en el tiempo _t = 0,1, ..., t_final_.\n"
">\n"
"> 3. Encapsula la lógica de tu bucle `for` en una función llamada `iterar` que toma la condición inicial como su primera entrada, el parámetro `t_final` como su segunda entrada y el parámetro` r` como su tercera entrada. La función debe devolver la lista de valores que representan el estado del mapa logístico en el tiempo _t = 0,1, ..., t_final_.\n"
">\n"
">\n"
"> > ## Solución\n"
"> >\n"
"> > 1.\n"
"> >\n"
"> > ~~~\n"
"> > def logistic_map(x, r):\n"
"> >     return r * x * (1 - x)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 2.\n"
"> >\n"
"> > ~~~\n"
"> > initial_condition = 0.5\n"
"> > t_final = 10\n"
"> > r = 1.0\n"
"> > trayectoria= [initial_condition]\n"
"> > for t in range(1, t_final):\n"
"> >     trayectoria.append( logistic_map(trayectoria[t-1], r) )\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 3.\n"
"> > ~~~\n"
"> > def iterar(initial_condition, t_final, r):\n"
"> >     trayectoria = [initial_condition]\n"
"> >     for t in range(1, t_final):\n"
"> >         trayectoria.append( logistic_map(trajectory[t-1], r) )\n"
"> >     return trayectoria\n"
"> > ~~~\n"
"> > {: .language-python}"
