# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# David Ochoa <ochoadavid@gmail.com>, 2020
# Paula <orchid00@gmail.com>, 2020
# David PS <dps.helio@gmail.com>, 2021
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2020-05-24 19:34:12+0100\n"
"PO-Revision-Date: 2020-05-24 19:14+0000\n"
"Last-Translator: David PS <dps.helio@gmail.com>, 2021\n"
"Language-Team: Spanish (https://www.transifex.com/carpentries-i18n/teams/98915/es/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

# Front Matter
#: python-novice-gapminder/_episodes/18-style.md:1
msgid ""
"---\n"
"title: \"Programming Style\"\n"
"teaching: 15\n"
"exercises: 15\n"
"questions:\n"
"- \"How can I make my programs more readable?\"\n"
"- \"How do most programmers format their code?\"\n"
"- \"How can programs check their own operation?\"\n"
"objectives:\n"
"- \"Provide sound justifications for basic rules of coding style.\"\n"
"- \"Refactor one-page programs to make them more readable and justify the changes.\"\n"
"- \"Use Python community coding standards (PEP-8).\"\n"
"keypoints:\n"
"- \"Follow standard Python style in your code.\"\n"
"- \"Use docstrings to provide builtin help.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Estilo de Programación\"\n"
"teaching: 15\n"
"exercises: 15\n"
"questions:\n"
"- \"¿Cómo puedo hacer para que mis programas sean fáciles de leer?\"\n"
"- \"¿Qué formato le dan la mayoría de los programadores a su código?\"\n"
"- \"¿De qué forma los programas pueden verificar su propio funcionamiento?\"\n"
"objectives:\n"
"- \"Dar argumentos para las reglas básicas de estilo de programación.\"\n"
"- \"Re-formatear programas de una página para hacerlos más fáciles de leer y justificar los cambios.\"\n"
"- \"Seguir los estándares comunitarios de estilo de Python (PEP-8).\"\n"
"keypoints:\n"
"- \"Sigue el formato estándar de Python en tu código.\"\n"
"- \"Utiliza docstrings para proveer ayuda integrada.\"\n"
"---"

# header
#: python-novice-gapminder/_episodes/18-style.md:18
msgid "## Coding style"
msgstr "## Estilo de programación"

#: python-novice-gapminder/_episodes/18-style.md:20
msgid ""
"Coding style helps us to understand the code better. It helps to maintain and change the code.\n"
"Python relies strongly on coding style, as we may notice by the indentation we apply to lines to define different blocks of code.\n"
"Python proposes a standard style through one of its first Python Enhancement Proposals (PEP), [PEP8](https://www.python.org/dev/peps/pep-0008), and highlight the importance of readability in the [Zen of Python](https://www.python.org/dev/peps/pep-0020)."
msgstr ""
"El estilo del código nos ayuda a entender mejor el código. También ayuda a darle mantenimiento y hacer modificaciones en el código.\n"
"Python se apoya mucho en el estilo del código como se puede ver en el sangrado que aplicamos en las líneas para definir los distintos bloques de código.\n"
"Python propone un estilo estándar en una de las primeras Propuestas de Mejora de Python (PEP, por sus siglas en inglés), [PEP8](https://www.python.org/dev/peps/pep-0008), y resalta la importancia de la lectura de código en [Zen de Python](https://www.python.org/dev/peps/pep-0020). "

#: python-novice-gapminder/_episodes/18-style.md:24
msgid ""
"We may highlight some points:\n"
"*   document your code\n"
"*   use clear, meaningful variable names\n"
"*   use white-space, *not* tabs, to indent lines"
msgstr ""
"Podemos subrayar algunos puntos:\n"
"* documenta tu código\n"
"* usa nombres de variables claros y significativos\n"
"* usa espacios en blanco, *no* tabuladores, para sangrar lineas"

# header
#: python-novice-gapminder/_episodes/18-style.md:30
msgid "## Follow standard Python style in your code."
msgstr "## Sigue el estilo estándar de Python en tu código."

# unordered list
#: python-novice-gapminder/_episodes/18-style.md:32
msgid "*   [PEP8](https://www.python.org/dev/peps/pep-0008):"
msgstr "*   [PEP8](https://www.python.org/dev/peps/pep-0008):"

#: python-novice-gapminder/_episodes/18-style.md:33
msgid ""
"    a style guide for Python that discusses topics such as how you should name variables,\n"
"    how you should use indentation in your code,\n"
"    how you should structure your `import` statements,\n"
"    etc.\n"
"    Adhering to PEP8 makes it easier for other Python developers to read and understand your code,\n"
"    and to understand what their contributions should look like.\n"
"    The [PEP8 application and Python library](https://pypi.python.org/pypi/pep8)\n"
"    can check your code for compliance with PEP8.\n"
"*   [Google style guide on Python](https://google.github.io/styleguide/pyguide.html) \n"
"    supports the use of PEP8 and extend the coding style to more specific structure of \n"
"    a Python code, which may be interesting also to follow.\n"
"    Google's [formatting application is called \"yapf\"](https://github.com/google/yapf/)."
msgstr ""
"    una guía de estilo para Python que discute cómo se deben nombrar las variables,\n"
"    cómo se debe usar la el sangrado en tu código,\n"
"    cómo se deben estructural las declaraciones `import`,\n"
"    etc.\n"
"    Seguir las recomendaciones de PEP8 hace más fácil para otros desarrolladores de Python leer y entender tu código,\n"
"    y entender como deberán de ser sus contribuciones.\n"
"    La [aplicación y biblioteca de Python PEP8](https://pypi.python.org/pypi/pep8)\n"
"    puede revisar si tu código cumple con las recomendaciones de PEP8.\n"
"*   [La guía de estilo de código de Python de Google](https://google.github.io/styleguide/pyguide.html) \n"
"    da soporte al uso de PEP8 y extiende el estilo de código a una estructura más específica de \n"
"    código en Python, que puede ser también interesante de seguir.\n"
"    [\"yapf\" es el nombre de la herramienta de formato de código](https://github.com/google/yapf/)  de Google."

# header
#: python-novice-gapminder/_episodes/18-style.md:46
msgid "## Use assertions to check for internal errors."
msgstr "## Usa aserciones para verificar errores internos."

#: python-novice-gapminder/_episodes/18-style.md:48
msgid ""
"Assertions are a simple, but powerful method for making sure that the "
"context in which your code is executing is as you expect."
msgstr ""
"Las aserciones son un método simple pero poderoso para asegurarnos de que el"
" contexto en el que tu código se ejecuta coincida con lo que esperas."

# code block
#: python-novice-gapminder/_episodes/18-style.md:50
msgid ""
"~~~\n"
"def calc_bulk_density(mass, volume):\n"
"    '''Return dry bulk density = powder mass / powder volume.'''\n"
"    assert volume > 0\n"
"    return mass / volume\n"
"~~~"
msgstr ""
"~~~\n"
"def calc_densidad(masa, volumen):\n"
"    '''Regresa la densidad media = masa / volumen.'''\n"
"    assert volumen > 0\n"
"    return masa / volumen\n"
"~~~"

#: python-novice-gapminder/_episodes/18-style.md:58
msgid ""
"If the assertion is `False`, the Python interpreter raises an "
"`AssertionError` runtime exception. The source code for the expression that "
"failed will be displayed as part of the error message. To ignore assertions "
"in your code run the interpreter with the '-O' (optimize) switch. Assertions"
" should contain only simple checks and never change the state of the "
"program. For example, an assertion should never contain an assignment."
msgstr ""
"Si la aserción es 'False', el interprete de Python llamará una excepción "
"`AssertionError`. El código de la expresión que falló sera mostrada como "
"parte del mensaje de error. Para ignorar todas las aserciones en tu código "
"debes de ejecutar el interprete con la bandera '-O' (optimize). Las "
"aserciones sólo deben contener pruebas simples y nunca cambiar el estado del"
" programa. Por ejemplo, una aserción nunca debe contener una asignación."

# header
#: python-novice-gapminder/_episodes/18-style.md:60
msgid "## Use docstrings to provide builtin help."
msgstr "## Utiliza docstrings para proporcionar ayuda."

# unordered list
#: python-novice-gapminder/_episodes/18-style.md:62
msgid "*   If the first thing in a function is a character string"
msgstr "*   Si la primera cosa en una función es una sequencia de caracteres"

#: python-novice-gapminder/_episodes/18-style.md:63
msgid ""
"    that is not assigned directly to a variable,\n"
"    Python attaches it to the function as the builtin help variable.\n"
"*   Called a *docstring* (short for \"documentation string\")."
msgstr ""
" que no está asignada directamente a una variable,\n"
" Python la agrega a la función como una variable de ayuda integrada.\n"
"* Se le conoce como *docstring* (abreviatura de \"cadena de documentación\")"

# code block
#: python-novice-gapminder/_episodes/18-style.md:67
msgid ""
"~~~\n"
"def average(values):\n"
"    \"Return average of values, or None if no values are supplied.\"\n"
"\n"
"    if len(values) == 0:\n"
"        return None\n"
"    return sum(values) / len(values)\n"
"\n"
"help(average)\n"
"~~~"
msgstr ""
"~~~\n"
"def average(valores):\n"
"    \"Regresa el promedio de valores, o None si no se proporcionan valores.\"\n"
"\n"
"    if len(valores) == 0:\n"
"        return None\n"
"    return sum(valores) / len(valores)\n"
"\n"
"help(average)\n"
"~~~"

#: python-novice-gapminder/_episodes/18-style.md:77
msgid ""
"{: .language-python}\n"
"~~~\n"
"Help on function average in module __main__:"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"Ayuda de la función `average` en el módulo __main__:"

#: python-novice-gapminder/_episodes/18-style.md:81
msgid ""
"average(values)\n"
"    Return average of values, or None if no values are supplied.\n"
"~~~"
msgstr ""
"average(valores)\n"
"    Regresa el promedio de valores, o None si no se proporcionan valores.\n"
"~~~"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/18-style.md:86
msgid "> ## Multiline Strings"
msgstr "## Cadenas con múltiples líneas"

#: python-novice-gapminder/_episodes/18-style.md:87
msgid ""
">\n"
"> Often use *multiline strings* for documentation.\n"
"> These start and end with three quote characters (either single or double)\n"
"> and end with three matching characters.\n"
">\n"
"> ~~~\n"
"> \"\"\"This string spans\n"
"> multiple lines.\n"
">\n"
"> Blank lines are allowed.\"\"\"\n"
"> ~~~\n"
"> {: .language-python}"
msgstr ""
">\n"
"> Utiliza *sequencias multilínea* para documentar tu código.\n"
"> Estas inician y terminan con tres comillas (ya sean sencillas o dobles).\n"
">\n"
">~~~\n"
"> \"\"\"Esta cadena se extiende\n"
"> varias líneas.\n"
">\n"
"> Son permitidas líneas en blanco.\"\"\"\n"
"> ~~~\n"
"> {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/18-style.md:101
msgid "> ## What Will Be Shown?"
msgstr "> ## ¿Qué será mostrado?"

#: python-novice-gapminder/_episodes/18-style.md:102
msgid ""
">\n"
"> Highlight the lines in the code below that will be available as online help.\n"
"> Are there lines that should be made available, but won't be?\n"
"> Will any lines produce a syntax error or a runtime error?\n"
">\n"
"> ~~~\n"
"> \"Find maximum edit distance between multiple sequences.\"\n"
"> # This finds the maximum distance between all sequences.\n"
">\n"
"> def overall_max(sequences):\n"
">     '''Determine overall maximum edit distance.'''\n"
"> \n"
">     highest = 0\n"
">     for left in sequences:\n"
">         for right in sequences:\n"
">             '''Avoid checking sequence against itself.'''\n"
">             if left != right:\n"
">                 this = edit_distance(left, right)\n"
">                 highest = max(highest, this)\n"
"> \n"
">     # Report.\n"
">     return highest\n"
"> ~~~\n"
"> {: .language-python}"
msgstr ""
">\n"
"> Subraya las líneas del código de abajo que estarán disponibles como ayuda en línea.\n"
"> ¿Hay alguna línea que debería estar disponible pero no está?\n"
"> ¿Alguna línea producirá un error de sintaxis o un runtime error?\n"
">\n"
"> ~~~\n"
"> \"Encuentra la máxima distancia entre varias secuencias\"\n"
"> # Este código encuentra la máxima distancia entre todas las secuencias.\n"
">\n"
"> def maximo_general(sequencias):\n"
">     '''Determina la distancia máxima.'''\n"
"> \n"
">     mas_alta = 0\n"
">     for izquierda in sequencias:\n"
">         for derecha in sequencias:\n"
">             '''Evita revisar una secuencia con ella misma.'''\n"
">             if izquierda != derecha:\n"
">                 actual = edit_distance(izquierda, derecha)\n"
">                 mas_alta = max(mas_alta, actual)\n"
"> \n"
">     # Reporta.\n"
">     return mas_alta\n"
"> ~~~\n"
"> {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/18-style.md:128
msgid "> ## Document This"
msgstr "> ## Documenta Este Código"

#: python-novice-gapminder/_episodes/18-style.md:129
msgid ""
">\n"
"> Turn the comment on the following function into a docstring\n"
"> and check that `help` displays it properly.\n"
">\n"
"> ~~~\n"
"> def middle(a, b, c):\n"
">     # Return the middle value of three.\n"
">     # Assumes the values can actually be compared.\n"
">     values = [a, b, c]\n"
">     values.sort()\n"
">     return values[1]\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > def middle(a, b, c):\n"
"> >     '''Return the middle value of three.\n"
"> >     Assumes the values can actually be compared.'''\n"
"> >     values = [a, b, c]\n"
"> >     values.sort()\n"
"> >     return values[1]\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> Convierte el comentario de la siguiente función a un docstring\n"
"> y verifica que `help` lo muestre correctamente.\n"
">\n"
"> ~~~\n"
"> def medio(a, b, c):\n"
">     # Regresa el valor que se encuentre en medio de los tres.\n"
">     # Asume que los valores pueden ser comparados.\n"
">     valores = [a, b, c]\n"
">     valores.sort()\n"
">     return valores[1]\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solución\n"
"> >\n"
"> > ~~~\n"
"> > def medio(a, b, c):\n"
"> >     '''Regresa el valor que se encuentre en medio de los tres.\n"
"> >     Asume que los valores pueden ser comparados.'''\n"
"> >     valores = [a, b, c]\n"
"> >     valores.sort()\n"
"> >     return valores[1]\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/18-style.md:156
msgid "> ## Clean Up This Code"
msgstr "> ## Limpia Este Código"

#: python-novice-gapminder/_episodes/18-style.md:157
msgid ""
">\n"
"> 1. Read this short program and try to predict what it does.\n"
"> 2. Run it: how accurate was your prediction?\n"
"> 3. Refactor the program to make it more readable.\n"
">    Remember to run it after each change to ensure its behavior hasn't changed.\n"
"> 4. Compare your rewrite with your neighbor's.\n"
">    What did you do the same?\n"
">    What did you do differently, and why?\n"
">\n"
"> ~~~\n"
"> n = 10\n"
"> s = 'et cetera'\n"
"> print(s)\n"
"> i = 0\n"
"> while i < n:\n"
">     # print('at', j)\n"
">     new = ''\n"
">     for j in range(len(s)):\n"
">         left = j-1\n"
">         right = (j+1)%len(s)\n"
">         if s[left]==s[right]: new += '-'\n"
">         else: new += '*'\n"
">     s=''.join(new)\n"
">     print(s)\n"
">     i += 1\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > Here's one solution.\n"
"> >\n"
"> > ~~~\n"
"> > def string_machine(input_string, iterations):\n"
"> >     \"\"\"\n"
"> >     Takes input_string and generates a new string with -'s and *'s\n"
"> >     corresponding to characters that have identical adjacent characters\n"
"> >     or not, respectively.  Iterates through this procedure with the resultant\n"
"> >     strings for the supplied number of iterations.\n"
"> >     \"\"\"\n"
"> >     print(input_string)\n"
"> >     input_string_length = len(input_string)\n"
"> >     old = input_string\n"
"> >     for i in range(iterations):\n"
"> >         new = ''\n"
"> >         # iterate through characters in previous string\n"
"> >         for j in range(input_string_length):\n"
"> >             left = j-1\n"
"> >             right = (j+1) % input_string_length  # ensure right index wraps around\n"
"> >             if old[left] == old[right]:\n"
"> >                 new += '-'\n"
"> >             else:\n"
"> >                 new += '*'\n"
"> >         print(new)\n"
"> >         # store new string as old\n"
"> >         old = new     \n"
"> >\n"
"> > string_machine('et cetera', 10)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > \n"
"> > ~~~\n"
"> > et cetera\n"
"> > *****-***\n"
"> > ----*-*--\n"
"> > ---*---*-\n"
"> > --*-*-*-*\n"
"> > **-------\n"
"> > ***-----*\n"
"> > --**---**\n"
"> > *****-***\n"
"> > ----*-*--\n"
"> > ---*---*-\n"
"> > ~~~\n"
"> > {: .output}"
msgstr ""
">\n"
"> 1. Lee este programa e intenta predecir lo que hace.\n"
"> 2. Ejecútalo: ¿qué tan acertada fué tu predicción?\n"
"> 3. Modifica el programa para hacerlo más legible.\n"
">    Recuerda de ejecutarlo después de cada cambio para asegurarte que su comportamiento no cambie.\n"
"> 4. Compara tu nueva versión con la de tu vecino.\n"
">    ¿Qué hicieron igual?\n"
">    ¿Qué hicieron diferente? y ¿porqué?\n"
">\n"
"> ~~~\n"
"> n = 10\n"
"> s = 'etcetera'\n"
"> print(s)\n"
"> i = 0\n"
"> while i < n:\n"
">     # print('en', j)\n"
">     nuevo = ''\n"
">     for j in range(len(s)):\n"
">         left = j-1\n"
">         right = (j+1)%len(s)\n"
">         if s[left]==s[right]: nuevo += '-'\n"
">         else: nuevo += '*'\n"
">     s=''.join(nuevo)\n"
">     print(s)\n"
">     i += 1\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Solución\n"
"> >\n"
"> > Aquí hay una posible solución.\n"
"> >\n"
"> > ~~~\n"
"> > def procesa_cadena(cadena_entrada, iteraciones):\n"
"> >     \"\"\"\n"
"> >     Toma una cadena_entrada y genera una nueva cadena con - y *\n"
"> >     que corresponde a caracteres que tienen caracteres idénticos\n"
"> >     adyacentes o no, respectivamente. Itera sobre este procedimiento\n"
"> >     con la cadena resultante el número indicado de iteraciones\n"
"> >     \"\"\"\n"
"> >     print(cadena_entrada)\n"
"> >     longitud_cadena_entrada = len(cadena_entrada)\n"
"> >     anterior = cadena_entrada\n"
"> >     for i in range(iteraciones):\n"
"> >         nueva = ''\n"
"> >         # itera sobre los caracteres de la cadena anterior\n"
"> >         for j in range(longitud_cadena_entrada):\n"
"> >             izquireda = j-1\n"
"> >             derecha = (j+1) % longitud_cadena_entrada  # la última deberá tomar el primer elemento\n"
"> >             if anterior[izquierda] == anterior[derecha]:\n"
"> >                 nueva += '-'\n"
"> >             else:\n"
"> >                 nueva += '*'\n"
"> >         print(nueva)\n"
"> >         # guarda la nueva cadena como la anterior\n"
"> >         anterior = nueva   \n"
"> >\n"
"> > procesa_cadena('et cetera', 10)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > \n"
"> > ~~~\n"
"> > etcetera\n"
"> > *****-***\n"
"> > ----*-*--\n"
"> > ---*---*-\n"
"> > --*-*-*-*\n"
"> > **-------\n"
"> > ***-----*\n"
"> > --**---**\n"
"> > *****-***\n"
"> > ----*-*--\n"
"> > ---*---*-\n"
"> > ~~~\n"
"> > {: .output}"
