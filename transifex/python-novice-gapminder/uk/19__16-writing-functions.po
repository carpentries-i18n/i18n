# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Марина Новожилова, 2022
# Olexandr Konovalov, 2022
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2020-05-24 19:34:12+0100\n"
"PO-Revision-Date: 2020-05-24 19:14+0000\n"
"Last-Translator: Olexandr Konovalov, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/carpentries-i18n/teams/98915/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

# Front Matter
#: python-novice-gapminder/_episodes/16-writing-functions.md:1
msgid ""
"---\n"
"title: \"Writing Functions\"\n"
"teaching: 10\n"
"exercises: 15\n"
"questions:\n"
"- \"How can I create my own functions?\"\n"
"objectives:\n"
"- \"Explain and identify the difference between function definition and function call.\"\n"
"- \"Write a function that takes a small, fixed number of arguments and produces a single result.\"\n"
"keypoints:\n"
"- \"Break programs down into functions to make them easier to understand.\"\n"
"- \"Define a function using `def` with a name, parameters, and a block of code.\"\n"
"- \"Defining a function does not run it.\"\n"
"- \"Arguments in call are matched to parameters in definition.\"\n"
"- \"Functions may return a result to their caller using `return`.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Написання функцій\"\n"
"teaching: 10\n"
"exercises: 15\n"
"questions:\n"
"- \"Як я можу створити власні функції?\"\n"
"objectives:\n"
"- \"Пояснити і визначитие різницю між визначенням функції та викликом функції.\"\n"
"- \"Написати функцію, яка приймає невелику фіксовану кількість аргументів і видає єдиний результат.\"\n"
"keypoints:\n"
"- \"Розбийте програми на функції, щоб їх було легше зрозуміти.\"\n"
"- \"Визначте функцію за допомогою `def` з назвою, параметрами та блоком коду.\"\n"
"- \"Визначення функції не запускає її.\"\n"
"- \"Аргументи у виклику зіставляються з параметрами у визначенні.\"\n"
"- \"Функції можуть повертати результат своєго виклику за допомогою `return`.\"\n"
"---"

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:17
msgid ""
"## Break programs down into functions to make them easier to understand."
msgstr "## Розбийте програми на функції, щоб їх було легше зрозуміти."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:19
msgid ""
"*   Human beings can only keep a few items in working memory at a time."
msgstr ""
"*  Людина може одночасно зберігати лише кілька елементів у робочій пам’яті. "

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:20
msgid ""
"*   Understand larger/more complicated ideas by understanding and combining "
"pieces."
msgstr ""
"*   Розуміти великі/складніші ідеї, розуміючи та комбінуючи їх частини."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:21
msgid "    *   Components in a machine."
msgstr "    *   Компоненти в машині."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:22
msgid "    *   Lemmas when proving theorems."
msgstr "    *   Леми при доведенні теорем."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:23
msgid "*   Functions serve the same purpose in programs."
msgstr "*   Функції служать тій же меті в програмах."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:24
msgid ""
"    *   *Encapsulate* complexity so that we can treat it as a single "
"\"thing\"."
msgstr ""
"    *   *Інкапсулю.nm* складність, щоб ми могли розглядати їх як одну «річ»."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:25
msgid "*   Also enables *re-use*."
msgstr "*   Також уможливлюють *повторне використання*."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:26
msgid "    *   Write one time, use many times."
msgstr "    *   Пишемо один раз, використовуємо багато разів.."

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:28
msgid ""
"## Define a function using `def` with a name, parameters, and a block of "
"code."
msgstr ""
"## Визначте функцію за допомогою `def` з назвою, параметрами та блоком "
"коду.\""

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:30
msgid "*   Begin the definition of a new function with `def`."
msgstr "*   Почніть визначення нової функції з `def`."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:31
msgid "*   Followed by the name of the function."
msgstr "*  Далі йде назва функції."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:32
msgid "    *   Must obey the same rules as variable names."
msgstr ""
"    *   Назви функцій мають відповідати тим самим правилам, що й імена "
"змінних."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:33
msgid "*   Then *parameters* in parentheses."
msgstr "*   Потім *параметри* в дужках."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:34
msgid "    *   Empty parentheses if the function doesn't take any inputs."
msgstr "    *   Порожні дужки, якщо функція не приймає жодних вхідних даних."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:35
msgid "    *   We will discuss this in detail in a moment."
msgstr "    *   Ми наразі обговоримо це детально."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:36
msgid "*   Then a colon."
msgstr "*   Потім двокрапка."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:37
msgid "*   Then an indented block of code."
msgstr "*   Потім блок коду з відступом."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:39
msgid ""
"~~~\n"
"def print_greeting():\n"
"    print('Hello!')\n"
"~~~"
msgstr ""
"~~~\n"
"def print_greeting():\n"
"    print('Hello!')\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:45
msgid "## Defining a function does not run it."
msgstr "## Визначення функції не запускає її."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:47
msgid "*   Defining a function does not run it."
msgstr "*   Визначення функції не запускає її."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:48
msgid "    *   Like assigning a value to a variable."
msgstr "    *   Як присвоєння значення змінній."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:49
msgid "*   Must call the function to execute the code it contains."
msgstr "*   Необхідно викликати функцію, щоб виконати код, який вона містить."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:51
msgid ""
"~~~\n"
"print_greeting()\n"
"~~~"
msgstr ""
"~~~\n"
"print_greeting()\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:54
msgid ""
"{: .language-python}\n"
"~~~\n"
"Hello!\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"Hello!\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:60
msgid "## Arguments in call are matched to parameters in definition."
msgstr "## Аргументи у виклику зіставляються з параметрами у визначенні."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:62
msgid "*   Functions are most useful when they can operate on different data."
msgstr ""
"*   Функції найбільш корисні, коли вони можуть працювати з різними даними."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:63
msgid "*   Specify *parameters* when defining a function."
msgstr "*   Укажіть *параметри* під час визначення функції."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:64
msgid "    *   These become variables when the function is executed."
msgstr "    *   Вони стають змінними під час виконання функції."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:65
msgid ""
"    *   Are assigned the arguments in the call (i.e., the values passed to "
"the function)."
msgstr ""
"    *   Праметрам присвоюються аргументи виклику (тобто значення, передані у"
" функцію)"

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:66
msgid ""
"    *   If you don't name the arguments when using them in the call, the "
"arguments will be matched to"
msgstr ""
"    *   Якщо ви не називаєте аргументи під час їх використання у виклику, "
"аргументи будуть зіставлені з"

#: python-novice-gapminder/_episodes/16-writing-functions.md:67
msgid "parameters in the order the parameters are defined in the function."
msgstr "параметрами в тому порядку, у якому вони визначені у функції."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:69
msgid ""
"~~~\n"
"def print_date(year, month, day):\n"
"    joined = str(year) + '/' + str(month) + '/' + str(day)\n"
"    print(joined)\n"
"\n"
"print_date(1871, 3, 19)\n"
"~~~"
msgstr ""
"~~~\n"
"def print_date(year, month, day):\n"
"    joined = str(year) + '/' + str(month) + '/' + str(day)\n"
"    print(joined)\n"
"\n"
"print_date(1871, 3, 19)\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:76
msgid ""
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:82
msgid ""
"Or, we can name the arguments when we call the function, which allows us to\n"
"specify them in any order:\n"
"~~~\n"
"print_date(month=3, day=19, year=1871)\n"
"~~~\n"
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"~~~"
msgstr ""
"Або ми можемо назвати аргументи під час виклику функції, що дозволяє нам це зробити\n"
"вказати їх у довільному порядку:\n"
"~~~\n"
"print_date(month=3, day=19, year=1871)\n"
"~~~\n"
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"~~~"

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:93
msgid ""
"*   Via "
"[Twitter](https://twitter.com/minisciencegirl/status/693486088963272705):"
msgstr ""
"*   Згідно "
"[Twitter](https://twitter.com/minisciencegirl/status/693486088963272705):"

#: python-novice-gapminder/_episodes/16-writing-functions.md:94
msgid ""
"    `()` contains the ingredients for the function\n"
"    while the body contains the recipe."
msgstr ""
"    `()` містить інгредієнти для функції\n"
"    тоді як тіло містить рецепт."

# header
#: python-novice-gapminder/_episodes/16-writing-functions.md:97
msgid "## Functions may return a result to their caller using `return`."
msgstr ""
"## Функції можуть повертати результат до свого виклику за допомогою "
"`return`."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:99
msgid "*   Use `return ...` to give a value back to the caller."
msgstr ""
"*   Використовуте `return ...` щоб повернути значення у місце виклику."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:100
msgid "*   May occur anywhere in the function."
msgstr "*   Може виникнути будь-де у функції."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:101
msgid "*   But functions are easier to understand if `return` occurs:"
msgstr "*   Але функції легше зрозуміти, якщо реалізовано функцію `return`:"

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:102
msgid "    *   At the start to handle special cases."
msgstr "    *   На початку функції для обробки особливих випадків."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:103
msgid "    *   At the very end, with a final result."
msgstr "    *   У самому кінці з остаточним результатом."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:105
msgid ""
"~~~\n"
"def average(values):\n"
"    if len(values) == 0:\n"
"        return None\n"
"    return sum(values) / len(values)\n"
"~~~"
msgstr ""
"~~~\n"
"def average(values):\n"
"    if len(values) == 0:\n"
"        return None\n"
"    return sum(values) / len(values)\n"
"~~~"

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:113
msgid ""
"~~~\n"
"a = average([1, 3, 4])\n"
"print('average of actual values:', a)\n"
"~~~"
msgstr ""
"~~~\n"
"a = average([1, 3, 4])\n"
"print('середнє фактичних значень:', a)\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:117
msgid ""
"{: .language-python}\n"
"~~~\n"
"average of actual values: 2.6666666666666665\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"середнє фактичних значень: 2.6666666666666665\n"
"~~~"

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:123
msgid ""
"~~~\n"
"print('average of empty list:', average([]))\n"
"~~~"
msgstr ""
"~~~\n"
"print('середнє порожнього списку:', average([]))\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:126
msgid ""
"{: .language-python}\n"
"~~~\n"
"average of empty list: None\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"середнє порожнього списку: None\n"
"~~~"

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:132
msgid ""
"*   Remember: [every function returns something]({{ page.root }}/04-built-"
"in/)."
msgstr ""
"*   Пам'ятайте: [кожна функція щось повертає]({{ page.root }}/04-built-in/)."

# unordered list
#: python-novice-gapminder/_episodes/16-writing-functions.md:133
msgid ""
"*   A function that doesn't explicitly `return` a value automatically "
"returns `None`."
msgstr ""
"*   Функція, яка явно не містить `return` , автоматично повертає `None`."

# code block
#: python-novice-gapminder/_episodes/16-writing-functions.md:135
msgid ""
"~~~\n"
"result = print_date(1871, 3, 19)\n"
"print('result of call is:', result)\n"
"~~~"
msgstr ""
"~~~\n"
"result = print_date(1871, 3, 19)\n"
"print('результат виклику є таким:', result)\n"
"~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:139
msgid ""
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"result of call is: None\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"1871/3/19\n"
"результат виклику є таким: None\n"
"~~~"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:146
msgid "> ## Identifying Syntax Errors"
msgstr "> ## Виявлення синтаксичних помилок"

#: python-novice-gapminder/_episodes/16-writing-functions.md:147
msgid ""
">\n"
"> 1. Read the code below and try to identify what the errors are\n"
">    *without* running it.\n"
"> 2. Run the code and read the error message.\n"
">    Is it a `SyntaxError` or an `IndentationError`?\n"
"> 3. Fix the error.\n"
"> 4. Repeat steps 2 and 3 until you have fixed all the errors.\n"
">\n"
"> ~~~\n"
"> def another_function\n"
">   print(\"Syntax errors are annoying.\")\n"
">    print(\"But at least python tells us about them!\")\n"
">   print(\"So they are usually not too hard to fix.\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > def another_function():\n"
"> >   print(\"Syntax errors are annoying.\")\n"
"> >   print(\"But at least Python tells us about them!\")\n"
"> >   print(\"So they are usually not too hard to fix.\")\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> 1. Прочитайте наведений нижче код і спробуйте визначити, у чому полягають помилки\n"
"> *без* запуску.\n"
"> 2. Запустіть код і прочитайте повідомлення про помилку.\n"
"> Це `SyntaxError` чи `IndentationError`?\n"
"> 3. Виправте помилку.\n"
"> 4. Повторюйте кроки 2 та 3 доки не виправите всі помилки.\n"
">\n"
"> ~~~\n"
"> def another_function\n"
"> print(\"Syntax errors are annoying.\")\n"
"> print(\"But at least python tells us about them!\")\n"
"> print(\"So they are usually not too hard to fix.\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Рішення\n"
"> >\n"
"> > ~~~\n"
"> > def another_function():\n"
"> > print(\"Синтаксичні помилки дратують.\")\n"
"> > print(\"Але принаймні Python розповідає нам про них!\")\n"
"> > print(\"Тож їх зазвичай не надто важко виправити.\")\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:175
msgid "> ## Definition and Use"
msgstr "> ## Визначення та використання"

#: python-novice-gapminder/_episodes/16-writing-functions.md:176
msgid ""
">\n"
"> What does the following program print?\n"
">\n"
"> ~~~\n"
"> def report(pressure):\n"
">     print('pressure is', pressure)\n"
">\n"
"> print('calling', report, 22.5)\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > calling <function report at 0x7fd128ff1bf8> 22.5\n"
"> > ~~~ \n"
"> > {: .output}\n"
"> >\n"
"> > A function call always needs parenthesis, otherwise you get memory address of the function object. So, if we wanted to call the function named report, and give it the value 22.5 to report on, we could have our function call as follows\n"
"> > ~~~\n"
"> > print(\"calling\")\n"
"> > report(22.5)\n"
"> > ~~~"
msgstr ""
">\n"
"> Що друкує наступна програма?\n"
">\n"
"> ~~~\n"
"> def report(pressure):\n"
">     print('тиск', pressure)\n"
">\n"
"> print('виклик', report, 22.5)\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Рішення\n"
"> >\n"
"> > ~~~\n"
"> > calling <function report at 0x7fd128ff1bf8> 22.5\n"
"> > ~~~ \n"
"> > {: .output}\n"
"> >\n"
"> > Для виклику функції завжди потрібні круглі дужки, інакше ви отримаєте адресу пам’яті об’єкта функції. Отже, якщо ми хочемо викликати функцію під назвою report і надати їй значення 22,5 для звіту, ми могли б викликати нашу функцію так\n"
"> > ~~~\n"
"> > print(\"виклик\")\n"
"> > report(22.5)\n"
"> > ~~~"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:202
msgid "> ## Order of Operations"
msgstr "> ## Порядок виконання операцій"

#: python-novice-gapminder/_episodes/16-writing-functions.md:203
msgid ""
">\n"
"> The example above:\n"
">\n"
"> ~~~\n"
"> result = print_date(1871, 3, 19)\n"
"> print('result of call is:', result)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> printed:\n"
"> ~~~\n"
"> 1871/3/19\n"
"> result of call is: None\n"
"> ~~~"
msgstr ""
">\n"
"> Приклад вище:\n"
">\n"
"> ~~~\n"
"> result = print_date(1871, 3, 19)\n"
"> print('результат виклику:', result)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> надруковано:\n"
"> ~~~\n"
"> 1871/3/19\n"
"> результат виклику: None\n"
"> ~~~"

#: python-novice-gapminder/_episodes/16-writing-functions.md:218
msgid ""
">\n"
"> Explain why the two lines of output appeared in the order they did.\n"
">\n"
"> What's wrong in this example?\n"
"> ~~~\n"
"> result = print_date(1871,3,19)\n"
">\n"
"> def print_date(year, month, day):\n"
">    joined = str(year) + '/' + str(month) + '/' + str(day)\n"
">    print(joined)\n"
"> ~~~\n"
"> {: .language-python}\n"
"> \n"
"> > ## Solution\n"
"> > \n"
"> > 1. The first line of output (`1871/3/19`) is from the print function inside `print_date()`, while the second line\n"
"> > is from the print function below the function call. All of the code inside `print_date()` is executed first, and\n"
"> > the program then \"leaves\" the function and executes the rest of the code.   \n"
"> > 2. The problem with the example is that the function is defined *after* the call to the function is made. Python\n"
"> > therefore doesn't understand the function call."
msgstr ""
">\n"
"> Поясніть, чому два рядки виводу з’явилися в такому порядку.\n"
">\n"
"> Що не так у цьому прикладі?\n"
"> ~~~\n"
"> result = print_date(1871,3,19)\n"
">\n"
"> def print_date(year, month, day):\n"
">    joined = str(year) + '/' + str(month) + '/' + str(day)\n"
">    print(joined)\n"
"> ~~~\n"
"> {: .language-python}\n"
"> \n"
"> > ## Рішення\n"
"> > \n"
"> > 1. Перший рядок виводу (`1871/3/19`) є результатом функції друку всередині `print_date()`, тоді як другий рядок\n"
"> > з функції друку під викликом функції. Весь код всередині `print_date()` виконується спочатку, а потім\n"
"> > програма \"залишає\" функцію та виконує решту коду.   \n"
"> > 2. Проблема з прикладом полягає в тому, що функція визначається *після* виклику функції. Тому Python\n"
"> > не розуміє виклик функції."

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:241
msgid "> ## Encapsulation"
msgstr "> ## Інкапсуляція"

#: python-novice-gapminder/_episodes/16-writing-functions.md:242
msgid ""
">\n"
"> Fill in the blanks to create a function that takes a single filename as an argument,\n"
"> loads the data in the file named by the argument,\n"
"> and returns the minimum value in that data.\n"
">\n"
"> ~~~\n"
"> import pandas as pd\n"
">\n"
"> def min_in_data(____):\n"
">     data = ____\n"
">     return ____\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > import pandas as pd\n"
"> > \n"
"> > def min_in_data(filename):\n"
"> >     data = pd.read_csv(filename)\n"
"> >     return data.min()\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> Заповніть порожні поля, щоб створити функцію, яка приймає одне ім’я файлу як аргумент,\n"
"> завантажує дані у файл, названий аргументом,\n"
"> і повертає мінімальне значення цих даних.\n"
">\n"
"> ~~~\n"
"> import pandas as pd\n"
">\n"
"> def min_in_data(____):\n"
">     data = ____\n"
">     return ____\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Рішення\n"
"> >\n"
"> > ~~~\n"
"> > import pandas as pd\n"
"> > \n"
"> > def min_in_data(filename):\n"
"> >     data = pd.read_csv(filename)\n"
"> >     return data.min()\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:268
msgid "> ## Find the First"
msgstr "> ## Знайди Перший"

#: python-novice-gapminder/_episodes/16-writing-functions.md:269
msgid ""
">\n"
"> Fill in the blanks to create a function that takes a list of numbers as an argument\n"
"> and returns the first negative value in the list.\n"
"> What does your function do if the list is empty?\n"
">\n"
"> ~~~\n"
"> def first_negative(values):\n"
">     for v in ____:\n"
">         if ____:\n"
">             return ____\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > def first_negative(values):\n"
"> >     for v in values:\n"
"> >         if v<0:\n"
"> >             return v\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > If an empty list is passed to this function, it returns `None`:\n"
"> > ~~~\n"
"> > my_list = []\n"
"> > print(first_negative(my_list))\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > ~~~\n"
"> > None\n"
"> > ~~~\n"
"> > {: .output}"
msgstr ""
">\n"
"> Заповніть порожні поля, щоб створити функцію, яка приймає список чисел як аргумент\n"
"> і повертає перше від’ємне значення в списку.\n"
"> Що робить ваша функція, якщо список порожній?\n"
">\n"
"> ~~~\n"
"> def first_negative(values):\n"
">     for v in ____:\n"
">         if ____:\n"
">             return ____\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Рішення\n"
"> >\n"
"> > ~~~\n"
"> > def first_negative(values):\n"
"> >     for v in values:\n"
"> >         if v<0:\n"
"> >             return v\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > Якщо цій функції передається порожній список, вона повертає `None`:\n"
"> > ~~~\n"
"> > my_list = []\n"
"> > print(first_negative(my_list))\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > ~~~\n"
"> > None\n"
"> > ~~~\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:303
msgid "> ## Calling by Name"
msgstr "> ## Виклик по імені"

#: python-novice-gapminder/_episodes/16-writing-functions.md:304
msgid ""
">\n"
"> Earlier we saw this function:\n"
">\n"
"> ~~~\n"
"> def print_date(year, month, day):\n"
">     joined = str(year) + '/' + str(month) + '/' + str(day)\n"
">     print(joined)\n"
"> ~~~\n"
"> We saw that we can call the function using *named arguments*, like this:\n"
"> ~~~\n"
"> print_date(day=1, month=2, year=2003)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 1.  What does `print_date(day=1, month=2, year=2003)` print?\n"
"> 2.  When have you seen a function call like this before?\n"
"> 3.  When and why is it useful to call functions this way?\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> > \n"
"> > 1. `2003/2/1`\n"
"> > 2. We saw examples of using *named arguments* when working with the pandas library. For example, when reading in a dataset \n"
"> > using `data = pd.read_csv('data/gapminder_gdp_europe.csv', index_col='country')`, the last argument `index_col` is a \n"
"> > named argument.  \n"
"> > 3. Using named arguments can make code more readable since one can see from the function call what name the different arguments \n"
"> > have inside the function. It can also reduce the chances of passing arguments in the wrong order, since by using named arguments \n"
"> > the order doesn't matter."
msgstr ""
">\n"
"> Раніше ми розглядали таку функцію:\n"
">\n"
"> ~~~\n"
"> def print_date(year, month, day):\n"
">     joined = str(year) + '/' + str(month) + '/' + str(day)\n"
">     print(joined)\n"
"> ~~~\n"
"> Ми побачили, що можна викликати функцію за допомогою *іменованих аргументів*, наприклад:\n"
"> ~~~\n"
"> print_date(day=1, month=2, year=2003)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 1. Що друкує `print_date(day=1, month=2, year=2003)`?\n"
"> 2. Коли ви раніше бачили подібний виклик функції?\n"
"> 3. Коли і чому корисно викликати функції таким чином?\n"
"> {: .language-python}\n"
"> > ## Рішення\n"
"> > \n"
"> > 1. `2003/2/1`\n"
"> > 2. Ми бачили приклади використання *іменованих аргументів* під час роботи з бібліотекою pandas. Наприклад, під час читання в наборі даних \n"
"> > using `data = pd.read_csv('data/gapminder_gdp_europe.csv', index_col='country')`, останній аргумент `index_col` є \n"
"> > іменованим аргументом.  \n"
"> > 3. Використання іменованих аргументів може зробити код більш читабельним, оскільки з виклику функції можна побачити, які імена мають різні аргументи\n"
"> > всередині функції. Це також може зменшити ймовірність передачі аргументів у неправильному порядку, оскільки за допомогою іменованих аргументів \n"
"> > порядок не має значення."

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:334
msgid "> ## Encapsulate of If/Print Block"
msgstr "> ## Інкапсуляція блоку If/Print"

#: python-novice-gapminder/_episodes/16-writing-functions.md:335
msgid ""
">\n"
"> The code below will run on a label-printer for chicken eggs.  A digital scale will report a chicken egg mass (in grams) to the computer and then the computer will print a label.  \n"
">\n"
"> Please re-write the code so that the if-block is folded into a function.\n"
">\n"
"> ~~~\n"
">  import random\n"
">  for i in range(10):\n"
">\n"
">     # simulating the mass of a chicken egg\n"
">     # the (random) mass will be 70 +/- 20 grams\n"
">     mass=70+20.0*(2.0*random.random()-1.0)\n"
">\n"
">     print(mass)\n"
">    \n"
">     #egg sizing machinery prints a label\n"
">     if(mass>=85):\n"
">        print(\"jumbo\")\n"
">     elif(mass>=70):\n"
">        print(\"large\")\n"
">     elif(mass<70 and mass>=55):\n"
">        print(\"medium\")\n"
">     else:\n"
">        print(\"small\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
">\n"
"> The simplified program  follows.  What function definition will make it functional?\n"
">\n"
"> ~~~\n"
">  # revised version\n"
">  import random\n"
">  for i in range(10):\n"
">\n"
">     # simulating the mass of a chicken egg\n"
">     # the (random) mass will be 70 +/- 20 grams\n"
">     mass=70+20.0*(2.0*random.random()-1.0)\n"
">\n"
">     print(mass,print_egg_label(mass))    \n"
">\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
">\n"
"> 1. Create a function definition for `print_egg_label()` that will work with the revised program above.  Note, the function's return value will be significant. Sample output might be `71.23 large`.\n"
"> 2.  A dirty egg might have a mass of more than 90 grams, and a spoiled or broken egg will probably have a mass that's less than 50 grams.  Modify your `print_egg_label()` function to account for these error conditions. Sample output could be `25 too light, probably spoiled`.\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > def print_egg_label(mass):\n"
"> >     #egg sizing machinery prints a label\n"
"> >     if(mass>=90):\n"
"> >         return(\"warning: egg might be dirty\")\n"
"> >     elif(mass>=85):\n"
"> >         return(\"jumbo\")\n"
"> >     elif(mass>=70):\n"
"> >         return(\"large\")\n"
"> >     elif(mass<70 and mass>=55):\n"
"> >         return(\"medium\")\n"
"> >     elif(mass<50):\n"
"> >         return(\"too light, probably spoiled\")\n"
"> >     else:\n"
"> >         return(\"small\")\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> Наведений нижче код запускатиметься на принтері етикеток для курячих яєць. Цифрові ваги повідомлять комп’ютеру про масу курячого яйця (у грамах), а потім комп’ютер друкує етикетку.  \n"
">\n"
"> Будь ласка, перепишіть код так, щоб if-блок був вкладений у функцію.\n"
">\n"
"> ~~~\n"
">  import random\n"
">  for i in range(10):\n"
">\n"
">     # імітація маси курячого яйця\n"
">     # (випадкова) маса становитиме 70 +/- 20 грамів\n"
">     mass=70+20.0*(2.0*random.random()-1.0)\n"
">\n"
">     print(mass)\n"
">    \n"
">     #машини для сортування яєць друкують етикетку\n"
">     if(mass>=85):\n"
">        print(\"джамбо\")\n"
">     elif(mass>=70):\n"
">        print(\"велике\")\n"
">     elif(mass<70 and mass>=55):\n"
">        print(\"середнє\")\n"
">     else:\n"
">        print(\"мале\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
">\n"
"> Далі спрощена програма. Яке визначення функції зробить його функціональним?\n"
">\n"
"> ~~~\n"
">  # Адаптована версія\n"
">  import random\n"
">  for i in range(10):\n"
">\n"
">     # імітація маси курячого яйця\n"
">     # (випадкова) маса становитиме 70 +/- 20 грамів\n"
">     mass=70+20.0*(2.0*random.random()-1.0)\n"
">\n"
">     print(mass,print_egg_label(mass))    \n"
">\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
">\n"
"> 1. Створіть визначення функції для `print_egg_label()`, яка працюватиме з адаптованою програмою вище. Зверніть увагу, що чисельне значення, яке повертає функція, буде важливим. Зразок оформлення результату може мати вигляд `71.23 large`.\n"
"> 2.  Брудне яйце може мати масу понад 90 грамів, а зіпсоване чи розбите яйце, ймовірно, матиме масу менше 50 грамів. Змініть свою функцію `print_egg_label()` для врахування цих умов помилки. Вихідний зразок може бути `25 занадто легке, можливо, зіпсоване`. \n"
">\n"
"> > ## Рішення\n"
"> >\n"
"> > ~~~\n"
"> > def print_egg_label(mass):\n"
"> >     #egg sizing machinery prints a label\n"
"> >     if(mass>=90):\n"
"> >         return(\"попередження: яйце може бути брудним\")\n"
"> >     elif(mass>=85):\n"
"> >         return(\"джамбо\")\n"
"> >     elif(mass>=70):\n"
"> >         return(\"велике\")\n"
"> >     elif(mass<70 and mass>=55):\n"
"> >         return(\"середнє\")\n"
"> >     elif(mass<50):\n"
"> >         return(\"занадто легке, можливо, зіпсоване\")\n"
"> >     else:\n"
"> >         return(\"мале\")\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:405
msgid "> ## Encapsulating Data Analysis"
msgstr "> ## Інкапсуляція аналізу даних"

#: python-novice-gapminder/_episodes/16-writing-functions.md:406
msgid ""
">\n"
"> Assume that the following code has been executed:\n"
">\n"
"> ~~~\n"
"> import pandas as pd\n"
">\n"
"> df = pd.read_csv('data/gapminder_gdp_asia.csv', index_col=0)\n"
"> japan = df.loc['Japan']\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 1.Complete the statements below to obtain the average GDP for Japan\n"
"> across the years reported for the 1980s.\n"
">\n"
"> ~~~\n"
"> year = 1983\n"
"> gdp_decade = 'gdpPercap_' + str(year // ____)\n"
"> avg = (japan.loc[gdp_decade + ___] + japan.loc[gdp_decade + ___]) / 2\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 2.Abstract the code above into a single function.\n"
">\n"
"> ~~~\n"
"> def avg_gdp_in_decade(country, continent, year):\n"
">     df = pd.read_csv('data/gapminder_gdp_'+___+'.csv',delimiter=',',index_col=0)\n"
">     ____\n"
">     ____\n"
">     ____\n"
">     return avg\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 3.How would you generalize this function\n"
">    if you did not know beforehand which specific years occurred as columns in the data?\n"
">    For instance, what if we also had data from years ending in 1 and 9 for each decade?\n"
">    (Hint: use the columns to filter out the ones that correspond to the decade,\n"
">    instead of enumerating them in the code.)\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > 1.\n"
"> >\n"
"> > ~~~\n"
"> > year = 1983\n"
"> > gdp_decade = 'gdpPercap_' + str(year // 10)\n"
"> > avg = (japan.loc[gdp_decade + '2'] + japan.loc[gdp_decade + '7']) / 2\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 2.\n"
"> >\n"
"> > ~~~\n"
"> > def avg_gdp_in_decade(country, continent, year):\n"
"> >     df = pd.read_csv('data/gapminder_gdp_' + continent + '.csv', index_col=0)\n"
"> >     c = df.loc[country]\n"
"> >     gdp_decade = 'gdpPercap_' + str(year // 10)\n"
"> >     avg = (c.loc[gdp_decade + '2'] + c.loc[gdp_decade + '7'])/2\n"
"> >     return avg\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 3.\n"
"> > \n"
"> > We need to loop over the reported years\n"
"> >    to obtain the average for the relevant ones in the data.\n"
"> >\n"
"> > ~~~\n"
"> > def avg_gdp_in_decade(country, continent, year):\n"
"> >     df = pd.read_csv('data/gapminder_gdp_' + continent + '.csv', index_col=0)\n"
"> >     c = df.loc[country]\n"
"> >     gdp_decade = 'gdpPercap_' + str(year // 10)\n"
"> >     total = 0.0\n"
"> >     num_years = 0\n"
"> >     for yr_header in c.index: # c's index contains reported years\n"
"> >         if yr_header.startswith(gdp_decade):\n"
"> >             total = total + c.loc[yr_header]\n"
"> >             num_years = num_years + 1\n"
"> >     return total/num_years\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > The function can now be called by:\n"
"> > ~~~\n"
"> > avg_gdp_in_decade('Japan','asia',1983)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > \n"
"> > ~~~\n"
"> > 20880.023800000003\n"
"> > ~~~\n"
"> > {: .output}"
msgstr ""
">\n"
"> Припустімо, що наступний код було виконано:\n"
">\n"
"> ~~~\n"
"> import pandas as pd\n"
">\n"
"> df = pd.read_csv('data/gapminder_gdp_asia.csv', index_col=0)\n"
"> japan = df.loc['Japan']\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 1.Заповніть наведені нижче твердження, щоб отримати середній ВВП Японії\n"
"> за роками, зазначеними у 1980-х роках.\n"
">\n"
"> ~~~\n"
"> year = 1983\n"
"> gdp_decade = 'gdpPercap_' + str(year // ____)\n"
"> avg = (japan.loc[gdp_decade + ___] + japan.loc[gdp_decade + ___]) / 2\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 2.Абстрагуйте код вище в одну функцію.\n"
">\n"
"> ~~~\n"
"> def avg_gdp_in_decade(country, continent, year):\n"
">     df = pd.read_csv('data/gapminder_gdp_'+___+'.csv',delimiter=',',index_col=0)\n"
">     ____\n"
">     ____\n"
">     ____\n"
">     return avg\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> 3.Як би ви узагальнили цю функцію\n"
">    якщо ви не знали заздалегідь, які конкретні роки зустрічаються як стовпці в даних?\n"
">   Наприклад, що, якби ми також мали дані за роки, що закінчуються на 1 і 9 для кожного десятиліття?\n"
">    (Підказка: використовуйте стовпці, щоб відфільтрувати ті, що відповідають десятиліттям,\n"
">    замість того, щоб перелічувати їх у коді.)\n"
">\n"
"> > ## Рішення\n"
"> >\n"
"> > 1.\n"
"> >\n"
"> > ~~~\n"
"> > year = 1983\n"
"> > gdp_decade = 'gdpPercap_' + str(year // 10)\n"
"> > avg = (japan.loc[gdp_decade + '2'] + japan.loc[gdp_decade + '7']) / 2\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 2.\n"
"> >\n"
"> > ~~~\n"
"> > def avg_gdp_in_decade(country, continent, year):\n"
"> >     df = pd.read_csv('data/gapminder_gdp_' + continent + '.csv', index_col=0)\n"
"> >     c = df.loc[country]\n"
"> >     gdp_decade = 'gdpPercap_' + str(year // 10)\n"
"> >     avg = (c.loc[gdp_decade + '2'] + c.loc[gdp_decade + '7'])/2\n"
"> >     return avg\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 3.\n"
"> > \n"
"> > Нам потрібно переглянути звітні роки\n"
"> >  для отримання середнього значення для відповідних у даних.\n"
"> >\n"
"> > ~~~\n"
"> > def avg_gdp_in_decade(country, continent, year):\n"
"> >     df = pd.read_csv('data/gapminder_gdp_' + continent + '.csv', index_col=0)\n"
"> >     c = df.loc[country]\n"
"> >     gdp_decade = 'gdpPercap_' + str(year // 10)\n"
"> >     total = 0.0\n"
"> >     num_years = 0\n"
"> >     for yr_header in c.index: # c's index contains reported years\n"
"> >         if yr_header.startswith(gdp_decade):\n"
"> >             total = total + c.loc[yr_header]\n"
"> >             num_years = num_years + 1\n"
"> >     return total/num_years\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > Функцію тепер можна викликати:\n"
"> > ~~~\n"
"> > avg_gdp_in_decade('Japan','asia',1983)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> > \n"
"> > ~~~\n"
"> > 20880.023800000003\n"
"> > ~~~\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/16-writing-functions.md:500
msgid "> ## Simulating a dynamical system"
msgstr "> ## Моделювання динамічної системи"

#: python-novice-gapminder/_episodes/16-writing-functions.md:501
msgid ""
">\n"
"> In mathematics, a [dynamical system](https://en.wikipedia.org/wiki/Dynamical_system) is a system in which a function describes the time dependence of a point in a geometrical space.  A canonical example of a dynamical system is a system called the [logistic map](https://en.wikipedia.org/wiki/Logistic_map).\n"
">\n"
">\n"
"> 1. Define a function called `logistic_map` that takes two inputs: `x`, representing the state of the system at time _t_, and a parameter `r`. This function should return a value representing the state of the system at time _t+1_.\n"
">\n"
"> 2. Using a `for` loop, iterate the `logistic_map` function defined in part 1 starting from an initial condition of 0.5 for `t_final=10`, `100`, and `1000` periods. Store the intermediate results in a list so that after the `for` loop terminates you have accumulated a sequence of values representing the state of the logistic map at time _t=0,1,...,t_final_.\n"
">\n"
"> 3. Encapsulate the logic of your `for` loop into a function called `iterate` that takes the initial condition as its first input, the parameter `t_final` as its second input and the parameter `r` as its third input. The function should return the list of values representing the state of the logistic map at time _t=0,1,...,t_final_.\n"
">\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > 1.\n"
"> >\n"
"> > ~~~\n"
"> > def logistic_map(x, r):\n"
"> >     return r * x * (1 - x)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 2.\n"
"> >\n"
"> > ~~~\n"
"> > initial_condition = 0.5\n"
"> > t_final = 10\n"
"> > r = 1.0\n"
"> > trajectory = [initial_condition]\n"
"> > for t in range(1, t_final):\n"
"> >     trajectory.append( logistic_map(trajectory[t-1], r) )\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 3.\n"
"> > ~~~\n"
"> > def iterate(initial_condition, t_final, r):\n"
"> >     trajectory = [initial_condition]\n"
"> >     for t in range(1, t_final):\n"
"> >         trajectory.append( logistic_map(trajectory[t-1], r) )\n"
"> >     return trajectory\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> У математиці [динамічна система](https://en.wikipedia.org/wiki/Dynamical_system) це система, у якій функція описує залежність точки в геометричному просторі від часу. Канонічним прикладом динамічної системи є система під назвою [логістичне відображення] (https://en.wikipedia.org/wiki/Logistic_map).\n"
">\n"
">\n"
"> 1. Визначте функцію під назвою `logistic_map`, яка приймає два входи: `x`, що представляє стан системи в момент часу _t_, і параметр `r`. Ця функція має повертати значення, що представляє стан системи в момент часу _t+1_.\n"
">\n"
"> 2. Використовуючи цикл `for`, повторіть функцію `logistic_map`, визначену в частині 1, починаючи з початкової умови 0,5 для періодів`t_final=10`, `100`, і `1000`. Зберігайте проміжні результати в списку, щоб після завершення циклу `for` ви накопичили послідовність значень, що представляють стан `logistic_map` в моменти часу _t=0,1,...,t_final_.\n"
">\n"
"> 3. Інкапсулюйте логіку вашого циклу `for` у функцію під назвою `iterate`, яка приймає початкову умову як перший вхід, параметр `t_final` як другий вхід і параметр `r` як третій вхід. Функція має повертати список значень, що представляють стан логістичної карти в момент часу _t=0,1,...,t_final_.\n"
">\n"
">\n"
"> > ## Рішення\n"
"> >\n"
"> > 1.\n"
"> >\n"
"> > ~~~\n"
"> > def logistic_map(x, r):\n"
"> >     return r * x * (1 - x)\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 2.\n"
"> >\n"
"> > ~~~\n"
"> > initial_condition = 0.5\n"
"> > t_final = 10\n"
"> > r = 1.0\n"
"> > trajectory = [initial_condition]\n"
"> > for t in range(1, t_final):\n"
"> >     trajectory.append( logistic_map(trajectory[t-1], r) )\n"
"> > ~~~\n"
"> > {: .language-python}\n"
"> >\n"
"> > 3.\n"
"> > ~~~\n"
"> > def iterate(initial_condition, t_final, r):\n"
"> >     trajectory = [initial_condition]\n"
"> >     for t in range(1, t_final):\n"
"> >         trajectory.append( logistic_map(trajectory[t-1], r) )\n"
"> >     return trajectory\n"
"> > ~~~\n"
"> > {: .language-python}"
