# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Maryna Novozhylova, 2022
# David PS <dps.helio@gmail.com>, 2022
# Mariya Spatar, 2023
# 
msgid ""
msgstr ""
"Project-Id-Version: i18n\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2020-05-24 19:34:12+0100\n"
"PO-Revision-Date: 2020-05-24 19:14+0000\n"
"Last-Translator: Mariya Spatar, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/carpentries-i18n/teams/98915/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

# Front Matter
#: python-novice-gapminder/_episodes/13-conditionals.md:1
msgid ""
"---\n"
"title: \"Conditionals\"\n"
"teaching: 10\n"
"exercises: 15\n"
"questions:\n"
"- \"How can programs do different things for different data?\"\n"
"objectives:\n"
"- \"Correctly write programs that use if and else statements and simple Boolean expressions (without logical operators).\"\n"
"- \"Trace the execution of unnested conditionals and conditionals inside loops.\"\n"
"keypoints:\n"
"- \"Use `if` statements to control whether or not a block of code is executed.\"\n"
"- \"Conditionals are often used inside loops.\"\n"
"- \"Use `else` to execute a block of code when an `if` condition is *not* true.\"\n"
"- \"Use `elif` to specify additional tests.\"\n"
"- \"Conditions are tested once, in order.\"\n"
"- \"Create a table showing variables' values to trace a program's execution.\"\n"
"---"
msgstr ""
"---\n"
"title: \"Умовні оператори\"\n"
"teaching: 10\n"
"exercises: 15\n"
"questions:\n"
"- \"Як програми можуть робити різні речі для різних даних?\"\n"
"objectives:\n"
"- \"Правильно писати програми, які використовують оператори if та else та прості логічні вирази (без логічних операторів).\"\n"
"- \"Відстежувати виконання невкладених умовних операторів і умовних операторів усередині циклів.\"\n"
"keypoints:\n"
"- \"Використовуйте оператори if, щоб контролювати виконання блоку коду.\"\n"
"- \"Умовні оператори часто використовуються всередині циклів.\"\n"
"- \"Використовуйте `else` для виконання блоку коду, коли умова `if` є *не* істинною.\"\n"
"- \"Використовуйте `elif` для визначення додаткових перевірок.\"\n"
"- \"Умови перевіряються один раз, по порядку.\"\n"
"- \"Створіть таблицю зі значеннями змінних для відстеження виконання програми\"\n"
"---"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:18
msgid ""
"## Use `if` statements to control whether or not a block of code is "
"executed."
msgstr ""
"## Використовуйте оператори if, щоб контролювати виконання блоку коду.."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:20
msgid "*   An `if` statement (more properly called a *conditional* statement)"
msgstr "*   Оператор if (точніше його називають *умовним* оператором)"

#: python-novice-gapminder/_episodes/13-conditionals.md:21
msgid ""
"    controls whether some block of code is executed or not.\n"
"*   Structure is similar to a `for` statement:\n"
"    *   First line opens with `if` and ends with a colon\n"
"    *   Body containing one or more statements is indented (usually by 4 spaces)"
msgstr ""
"    контролює виконання певного блоку коду.\n"
"*   Структура подібна до оператора `for`:\n"
"    *   Перший рядок починається з `if` і закінчується двокрапкою\n"
"    *   Тіло оператору, що містить одне або кілька тверджень, має відступ (зазвичай на 4 пробіли)"

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:26
msgid ""
"~~~\n"
"mass = 3.54\n"
"if mass > 3.0:\n"
"    print(mass, 'is large')\n"
"\n"
"mass = 2.07\n"
"if mass > 3.0:\n"
"    print (mass, 'is large')\n"
"~~~"
msgstr ""
"~~~\n"
"mass = 3.54\n"
"if mass > 3.0:\n"
"    print(mass, 'є великим')\n"
"\n"
"mass = 2.07\n"
"if mass > 3.0:\n"
"    print (mass, 'є великим')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:35
msgid ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"3.54 є великим\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:41
msgid "## Conditionals are often used inside loops."
msgstr "## Умовні оператори часто використовуються всередині циклів."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:43
msgid ""
"*   Not much point using a conditional when we know the value (as above)."
msgstr ""
"*   Немає особливого сенсу використовувати умовний оператор, коли ми знаємо "
"значення (як вище)."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:44
msgid "*   But useful when we have a collection to process."
msgstr "*   Але корисно, коли у нас є колекція для обробки."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:46
msgid ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 3.0:\n"
"        print(m, 'is large')\n"
"~~~"
msgstr ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 3.0:\n"
"        print(m, 'є великим')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:52
msgid ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"9.22 is large\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"3.54 є великим\n"
"9.22 є великим\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:59
msgid ""
"## Use `else` to execute a block of code when an `if` condition is *not* "
"true."
msgstr ""
"## Використовуйте `else` для виконання блоку коду, коли умова `if` є *не* "
"істинною."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:61
msgid "*   `else` can be used following an `if`."
msgstr "*   `else` можна використовувати після `if`."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:62
msgid ""
"*   Allows us to specify an alternative to execute when the `if` *branch* "
"isn't taken."
msgstr ""
"*   Дозволяє нам вказати альтернативу для виконання, коли умова *гілки* `if`"
" не виконується."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:64
msgid ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 3.0:\n"
"        print(m, 'is large')\n"
"    else:\n"
"        print(m, 'is small')\n"
"~~~"
msgstr ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 3.0:\n"
"        print(m, 'є великим')\n"
"    else:\n"
"        print(m, 'є малим')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:72
msgid ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"2.07 is small\n"
"9.22 is large\n"
"1.86 is small\n"
"1.71 is small\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"3.54 є великим\n"
"2.07 є малим\n"
"9.22 є великим\n"
"1.86 є малим\n"
"1.71 є малим\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:82
msgid "## Use `elif` to specify additional tests."
msgstr "## Використовуйте `elif` для визначення додаткових перевірок."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:84
msgid ""
"*   May want to provide several alternative choices, each with its own test."
msgstr ""
"*   Може знадобитися надати кілька альтернативних варіантів, кожен з яких "
"має своєю перевірку."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:85
msgid "*   Use `elif` (short for \"else if\") and a condition to specify these."
msgstr ""
"*   Використовуйте `elif` (скорочення від \"else if\") та умову, перевірки. "

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:86
msgid "*   Always associated with an `if`."
msgstr "*   Завжди асоціюється з `if`."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:87
msgid "*   Must come before the `else` (which is the \"catch all\")."
msgstr ""
"*   Має бути перед `else` (що слугує для того, щоб \"підібрати все інше\")."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:89
msgid ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 9.0:\n"
"        print(m, 'is HUGE')\n"
"    elif m > 3.0:\n"
"        print(m, 'is large')\n"
"    else:\n"
"        print(m, 'is small')\n"
"~~~"
msgstr ""
"~~~\n"
"masses = [3.54, 2.07, 9.22, 1.86, 1.71]\n"
"for m in masses:\n"
"    if m > 9.0:\n"
"        print(m, 'є ВЕЛИЧЕЗНИМ')\n"
"    elif m > 3.0:\n"
"        print(m, 'є великим')\n"
"    else:\n"
"        print(m, 'є малим')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:99
msgid ""
"{: .language-python}\n"
"~~~\n"
"3.54 is large\n"
"2.07 is small\n"
"9.22 is HUGE\n"
"1.86 is small\n"
"1.71 is small\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"3.54 є великим\n"
"2.07 є малим\n"
"9.22 є ВЕЛИЧЕЗНИМ\n"
"1.86 є малим\n"
"1.71 є малим\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:109
msgid "## Conditions are tested once, in order."
msgstr "## Умови перевіряються один раз, по порядку."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:111
msgid ""
"*   Python steps through the branches of the conditional in order, testing "
"each in turn."
msgstr ""
"*   Python послідовно проходить гілки умовного оператора, перевіряючи кожну "
"по черзі."

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:112
msgid "*   So ordering matters."
msgstr "*   Отже, порядок має значення."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:114
msgid ""
"~~~\n"
"grade = 85\n"
"if grade >= 70:\n"
"    print('grade is C')\n"
"elif grade >= 80:\n"
"    print('grade is B')\n"
"elif grade >= 90:\n"
"    print('grade is A')\n"
"~~~"
msgstr ""
"~~~\n"
"grade = 85\n"
"if grade >= 70:\n"
"    print('grade is C')\n"
"elif grade >= 80:\n"
"    print('grade is B')\n"
"elif grade >= 90:\n"
"    print('grade is A')\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:123
msgid ""
"{: .language-python}\n"
"~~~\n"
"grade is C\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"grade is C\n"
"~~~"

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:129
msgid "*   Does *not* automatically go back and re-evaluate if values change."
msgstr ""
"*   Автоматично *не* повертається назад і не  оцінює повторно, якщо значення"
" змінюються."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:131
msgid ""
"~~~\n"
"velocity = 10.0\n"
"if velocity > 20.0:\n"
"    print('moving too fast')\n"
"else:\n"
"    print('adjusting velocity')\n"
"    velocity = 50.0\n"
"~~~"
msgstr ""
"~~~\n"
"velocity = 10.0\n"
"if velocity > 20.0:\n"
"    print('рухається занадто швидко')\n"
"else:\n"
"    print('регулювання швидкості')\n"
"    velocity = 50.0\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:139
msgid ""
"{: .language-python}\n"
"~~~\n"
"adjusting velocity\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"регулювання швидкості\n"
"~~~"

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:145
msgid ""
"*   Often use conditionals in a loop to \"evolve\" the values of variables."
msgstr ""
"*   Умовні оператори часто використовуються  в циклі, щоб «розвинути» "
"значення змінних."

# code block
#: python-novice-gapminder/_episodes/13-conditionals.md:147
msgid ""
"~~~\n"
"velocity = 10.0\n"
"for i in range(5): # execute the loop 5 times\n"
"    print(i, ':', velocity)\n"
"    if velocity > 20.0:\n"
"        print('moving too fast')\n"
"        velocity = velocity - 5.0\n"
"    else:\n"
"        print('moving too slow')\n"
"        velocity = velocity + 10.0\n"
"print('final velocity:', velocity)\n"
"~~~"
msgstr ""
"~~~\n"
"velocity = 10.0\n"
"for i in range(5): # виконати цикл 5 разів\n"
"    print(i, ':', velocity)\n"
"    if velocity > 20.0:\n"
"        print('рухається занадто швидко')\n"
"        velocity = velocity - 5.0\n"
"    else:\n"
"        print('рухається надто повільно')\n"
"        velocity = velocity + 10.0\n"
"print('кінцева швидкість:', velocity)\n"
"~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:159
msgid ""
"{: .language-python}\n"
"~~~\n"
"0 : 10.0\n"
"moving too slow\n"
"1 : 20.0\n"
"moving too slow\n"
"2 : 30.0\n"
"moving too fast\n"
"3 : 25.0\n"
"moving too fast\n"
"4 : 20.0\n"
"moving too slow\n"
"final velocity: 30.0\n"
"~~~"
msgstr ""
"{: .language-python}\n"
"~~~\n"
"0 : 10.0\n"
"рухається занадто повільно\n"
"1 : 20.0\n"
"рухається занадто повільно\n"
"2 : 30.0\n"
"рухається занадто швидко\n"
"3 : 25.0\n"
"рухається занадто швидко\n"
"4 : 20.0\n"
"рухається занадто повільно\n"
"кінцева швидкість: 30.0\n"
"~~~"

# header
#: python-novice-gapminder/_episodes/13-conditionals.md:175
msgid ""
"## Create a table showing variables' values to trace a program's execution."
msgstr ""
"## Створіть таблицю зі значеннями змінних для відстеження виконання "
"програми."

# inline html
#: python-novice-gapminder/_episodes/13-conditionals.md:177
msgid ""
"<table>\n"
"  <tr>\n"
"    <td><strong>i</strong></td>\n"
"    <td>0</td>\n"
"    <td>.</td>\n"
"    <td>1</td>\n"
"    <td>.</td>\n"
"    <td>2</td>\n"
"    <td>.</td>\n"
"    <td>3</td>\n"
"    <td>.</td>\n"
"    <td>4</td>\n"
"    <td>.</td>\n"
"  </tr>\n"
"  <tr>\n"
"    <td><strong>velocity</strong></td>\n"
"    <td>10.0</td>\n"
"    <td>20.0</td>\n"
"    <td>.</td>\n"
"    <td>30.0</td>\n"
"    <td>.</td>\n"
"    <td>25.0</td>\n"
"    <td>.</td>\n"
"    <td>20.0</td>\n"
"    <td>.</td>\n"
"    <td>30.0</td>\n"
"  </tr>\n"
"</table>"
msgstr ""
"<table>\n"
"  <tr>\n"
"    <td><strong>i</strong></td>\n"
"    <td>0</td>\n"
"    <td>.</td>\n"
"    <td>1</td>\n"
"    <td>.</td>\n"
"    <td>2</td>\n"
"    <td>.</td>\n"
"    <td>3</td>\n"
"    <td>.</td>\n"
"    <td>4</td>\n"
"    <td>.</td>\n"
"  </tr>\n"
"  <tr>\n"
"    <td><strong>швидкість</strong></td>\n"
"    <td>10.0</td>\n"
"    <td>20.0</td>\n"
"    <td>.</td>\n"
"    <td>30.0</td>\n"
"    <td>.</td>\n"
"    <td>25.0</td>\n"
"    <td>.</td>\n"
"    <td>20.0</td>\n"
"    <td>.</td>\n"
"    <td>30.0</td>\n"
"  </tr>\n"
"</table>"

# unordered list
#: python-novice-gapminder/_episodes/13-conditionals.md:206
msgid ""
"*   The program must have a `print` statement *outside* the body of the loop"
msgstr "*   Програма повинна мати оператор `print` *поза* тілом циклу,"

#: python-novice-gapminder/_episodes/13-conditionals.md:207
msgid ""
"    to show the final value of `velocity`,\n"
"    since its value is updated by the last iteration of the loop."
msgstr ""
"    щоб показати остаточне значення змінної `velocity`,\n"
"    оскільки її значення оновлюється останньою ітерацією циклу."

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:210
msgid "> ## Compound Relations Using `and`, `or`, and Parentheses"
msgstr "> ## Комбінація відношень з використанням «і», «або» та круглих дужок"

#: python-novice-gapminder/_episodes/13-conditionals.md:211
msgid ""
">\n"
"> Often, you want some combination of things to be true.  You can combine\n"
"> relations within a conditional using `and` and `or`.  Continuing the example\n"
"> above, suppose you have\n"
">\n"
"> ~~~\n"
"> mass     = [ 3.54,  2.07,  9.22,  1.86,  1.71]\n"
"> velocity = [10.00, 20.00, 30.00, 25.00, 20.00]\n"
">\n"
"> i = 0\n"
"> for i in range(5):\n"
">     if mass[i] > 5 and velocity[i] > 20:\n"
">         print(\"Fast heavy object.  Duck!\")\n"
">     elif mass[i] > 2 and mass[i] <= 5 and velocity[i] <= 20:\n"
">         print(\"Normal traffic\")\n"
">     elif mass[i] <= 2 and velocity[i] <= 20:\n"
">         print(\"Slow light object.  Ignore it\")\n"
">     else:\n"
">         print(\"Whoa!  Something is up with the data.  Check it\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> Just like with arithmetic, you can and should use parentheses whenever there\n"
"> is possible ambiguity.  A good general rule is to *always* use parentheses\n"
"> when mixing `and` and `or` in the same condition.  That is, instead of:\n"
">\n"
"> ~~~\n"
"> if mass[i] <= 2 or mass[i] >= 5 and velocity[i] > 20:\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> write one of these:\n"
">\n"
"> ~~~\n"
"> if (mass[i] <= 2 or mass[i] >= 5) and velocity[i] > 20:\n"
"> if mass[i] <= 2 or (mass[i] >= 5 and velocity[i] > 20):\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> so it is perfectly clear to a reader (and to Python) what you really mean."
msgstr ""
">\n"
"> Часто потрібно, щоб певна комбінація речей була правдою. Можна комбінувати\n"
"> відносини в умовному операторі з використанням «і» та «або». Продовжуючи приклад,\n"
"> наведений вище, припустімо, що у вас є>\n"
"> ~~~\n"
"> mass     = [ 3.54,  2.07,  9.22,  1.86,  1.71]\n"
"> velocity = [10.00, 20.00, 30.00, 25.00, 20.00]\n"
">\n"
"> i = 0\n"
"> for i in range(5):\n"
">     if mass[i] > 5 and velocity[i] > 20:\n"
">         print(\"Швидкий важкий предмет. Качка!\")\n"
">     elif mass[i] > 2 and mass[i] <= 5 and velocity[i] <= 20:\n"
">         print(\"Нормальний трафік\")\n"
">     elif mass[i] <= 2 and velocity[i] <= 20:\n"
">         print(\"Повільний, легкий предмет. Ігноруйте це\")\n"
">     else:\n"
">         print(\"ой! Щось сталося з даними. Перевірте це\")\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> Так само, як і в арифметиці, ви можете і маєте використовувати круглі дужки,\n"
"> якщо у виразі можлива двозначність. Хорошим загальним правилом є використання круглих дужок *завжди*\n"
"> при одночасному використанні `і` та `або` в однакових умовах. Тобто замість:\n"
">\n"
"> ~~~\n"
"> if mass[i] <= 2 or mass[i] >= 5 and velocity[i] > 20:\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> напишіть одну умов нижче:\n"
">\n"
"> ~~~\n"
"> if (mass[i] <= 2 or mass[i] >= 5) and velocity[i] > 20:\n"
"> if mass[i] <= 2 or (mass[i] >= 5 and velocity[i] > 20):\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> і тоді читачеві (і Python) цілком зрозуміло, що ви насправді маєте на увазі."

#: python-novice-gapminder/_episodes/13-conditionals.md:254
msgid ""
">\n"
"> What does this program print?\n"
">\n"
"> ~~~\n"
"> pressure = 71.9\n"
"> if pressure > 50.0:\n"
">     pressure = 25.0\n"
"> elif pressure <= 50.0:\n"
">     pressure = 0.0\n"
"> print(pressure)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > 25.0\n"
"> > ~~~\n"
"> > {: .output}"
msgstr ""
">\n"
"> Що надрукує ця програма?\n"
">\n"
"> ~~~\n"
"> pressure = 71.9\n"
"> if pressure > 50.0:\n"
">     pressure = 25.0\n"
"> elif pressure <= 50.0:\n"
">     pressure = 0.0\n"
"> print(pressure)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> > ## Рішення\n"
"> >\n"
"> > ~~~\n"
"> > 25.0\n"
"> > ~~~\n"
"> > {: .output}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:276
msgid "> ## Trimming Values"
msgstr "> ## Обрізання значень"

#: python-novice-gapminder/_episodes/13-conditionals.md:277
msgid ""
">\n"
"> Fill in the blanks so that this program creates a new list\n"
"> containing zeroes where the original list's values were negative\n"
"> and ones where the original list's values were positive.\n"
">\n"
"> ~~~\n"
"> original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]\n"
"> result = ____\n"
"> for value in original:\n"
">     if ____:\n"
">         result.append(0)\n"
">     else:\n"
">         ____\n"
"> print(result)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> ~~~\n"
"> [0, 1, 1, 1, 0, 1]\n"
"> ~~~"
msgstr ""
">\n"
"> Заповніть порожні поля, щоб програма створила новий список,\n"
"> що містить нулі, якщо початкові значення списку були від’ємними\n"
"> та одиниці, де початкові значення списку були додатними.\n"
">\n"
"> ~~~\n"
"> original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]\n"
"> result = ____\n"
"> for value in original:\n"
">     if ____:\n"
">         result.append(0)\n"
">     else:\n"
">         ____\n"
"> print(result)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> ~~~\n"
"> [0, 1, 1, 1, 0, 1]\n"
"> ~~~"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:299
msgid "> >"
msgstr "> >"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:301
msgid "> > original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]"
msgstr "> > original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:302
msgid "> > result = []"
msgstr "> > result = []"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:303
msgid "> > for value in original:"
msgstr "> > for value in original:"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:304
msgid "> >     if value<0.0:"
msgstr "> >     if value<0.0:"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:305
msgid "> >         result.append(0)"
msgstr "> >         result.append(0)"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:306
msgid "> >     else:"
msgstr "> >     else:"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:307
msgid "> >         result.append(1)"
msgstr "> >         result.append(1)"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:308
msgid "> > print(result)"
msgstr "> > print(result)"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:310
msgid "> > {: .language-python}"
msgstr "> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:314
msgid "> ## Processing Small Files"
msgstr "> ## Обробка малих файлів"

#: python-novice-gapminder/_episodes/13-conditionals.md:315
msgid ""
">\n"
"> Modify this program so that it only processes files with fewer than 50 records.\n"
">\n"
"> ~~~\n"
"> import glob\n"
"> import pandas as pd\n"
"> for filename in glob.glob('data/*.csv'):\n"
">     contents = pd.read_csv(filename)\n"
">     ____:\n"
">         print(filename, len(contents))\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > import glob\n"
"> > import pandas as pd\n"
"> > for filename in glob.glob('data/*.csv'):\n"
"> >     contents = pd.read_csv(filename)\n"
"> >     if len(contents)<50:\n"
"> >         print(filename, len(contents))\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> Змініть цю програму так, щоб вона обробляла лише файли з менш ніж 50 записами.\n"
">\n"
"> ~~~\n"
"> import glob\n"
"> import pandas as pd\n"
"> for filename in glob.glob('data/*.csv'):\n"
">     contents = pd.read_csv(filename)\n"
">     ____:\n"
">         print(filename, len(contents))\n"
"> ~~~\n"
"> {: .language-python}\n"
"> > ## Рішення\n"
"> >\n"
"> > ~~~\n"
"> > import glob\n"
"> > import pandas as pd\n"
"> > for filename in glob.glob('data/*.csv'):\n"
"> >     contents = pd.read_csv(filename)\n"
"> >     if len(contents)<50:\n"
"> >         print(filename, len(contents))\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:341
msgid "> ## Initializing"
msgstr "> ## Ініціалізація"

#: python-novice-gapminder/_episodes/13-conditionals.md:342
msgid ""
">\n"
"> Modify this program so that it finds the largest and smallest values in the list\n"
"> no matter what the range of values originally is.\n"
">\n"
"> ~~~\n"
"> values = [...some test data...]\n"
"> smallest, largest = None, None\n"
"> for v in values:\n"
">     if ____:\n"
">         smallest, largest = v, v\n"
">     ____:\n"
">         smallest = min(____, v)\n"
">         largest = max(____, v)\n"
"> print(smallest, largest)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> What are the advantages and disadvantages of using this method\n"
"> to find the range of the data?\n"
"> > ## Solution\n"
"> >\n"
"> > ~~~\n"
"> > values = [-2,1,65,78,-54,-24,100]\n"
"> > smallest, largest = None, None\n"
"> > for v in values:\n"
"> >     if smallest==None and largest==None:\n"
"> >         smallest, largest = v, v\n"
"> >     else:\n"
"> >         smallest = min(smallest, v)\n"
"> >         largest = max(largest, v)\n"
"> > print(smallest, largest)\n"
"> > ~~~\n"
"> > {: .language-python}"
msgstr ""
">\n"
"> Змініть цю програму так, щоб вона знаходила найбільше та найменше значення у списку\n"
"> незалежно від початкового діапазону значень.\n"
">\n"
"> ~~~\n"
"> values = [...деякі тестові дані...]\n"
"> smallest, largest = None, None\n"
"> for v in values:\n"
">     if ____:\n"
">         smallest, largest = v, v\n"
">     ____:\n"
">         smallest = min(____, v)\n"
">         largest = max(____, v)\n"
"> print(smallest, largest)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> Які переваги та недоліки використання цього методу\n"
"> для визначення діапазону даних?\n"
"> > ## Рішення\n"
"> >\n"
"> > ~~~\n"
"> > values = [-2,1,65,78,-54,-24,100]\n"
"> > smallest, largest = None, None\n"
"> > for v in values:\n"
"> >     if smallest==None and largest==None:\n"
"> >         smallest, largest = v, v\n"
"> >     else:\n"
"> >         smallest = min(smallest, v)\n"
"> >         largest = max(largest, v)\n"
"> > print(smallest, largest)\n"
"> > ~~~\n"
"> > {: .language-python}"

# blockquote, which can be cascaded
#: python-novice-gapminder/_episodes/13-conditionals.md:378
msgid "> ## Using Functions With Conditionals in Pandas"
msgstr "> ## Використання функцій з умовними операторами в Pandas"

#: python-novice-gapminder/_episodes/13-conditionals.md:379
msgid ""
">\n"
"> Functions will often contain conditionals.  Here is a short example that\n"
"> will indicate which quartile the argument is in based on hand-coded values\n"
"> for the quartile cut points.\n"
">\n"
"> ~~~\n"
"> def calculate_life_quartile(exp):\n"
">     if exp < 58.41:\n"
">         # This observation is in the first quartile\n"
">         return 1\n"
">     elif exp >= 58.41 and exp < 67.05:\n"
">         # This observation is in the second quartile\n"
">        return 2\n"
">     elif exp >= 67.05 and exp < 71.70:\n"
">         # This observation is in the third quartile\n"
">        return 3\n"
">     elif exp >= 71.70:\n"
">         # This observation is in the fourth quartile\n"
">        return 4\n"
">     else:\n"
">         # This observation has bad data\n"
">        return None\n"
">\n"
"> calculate_life_quartile(62.5)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> ~~~\n"
"> 2\n"
"> ~~~"
msgstr ""
">\n"
"> Функції часто містять умови. Ось короткий приклад, в якому \n"
"> на основі закодованих вручну значень визначається, у якому квартилі знаходиться аргумент,\n"
"> з урахуванням квартильних точок розрізу.\n"
">\n"
"> ~~~\n"
"> def calculate_life_quartile(exp):\n"
">     if exp < 58.41:\n"
">         # Це спостереження належить першому квартилю\n"
">         return 1\n"
">     elif exp >= 58.41 and exp < 67.05:\n"
">         # Це спостереження належить другому квартилю\n"
">        return 2\n"
">     elif exp >= 67.05 and exp < 71.70:\n"
">         # Це спостереження належить третьому квартилю\n"
">        return 3\n"
">     elif exp >= 71.70:\n"
">         # Це спостереження належить четвертому квартилю\n"
">        return 4\n"
">     else:\n"
">         # Це спостереження має погані дані\n"
">        return None\n"
">\n"
"> calculate_life_quartile(62.5)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> ~~~\n"
"> 2\n"
"> ~~~"

#: python-novice-gapminder/_episodes/13-conditionals.md:410
msgid ""
">\n"
"> That function would typically be used within a `for` loop, but Pandas has\n"
"> a different, more efficient way of doing the same thing, and that is by\n"
"> *applying* a function to a dataframe or a portion of a dataframe.  Here\n"
"> is an example, using the definition above.\n"
">\n"
"> ~~~\n"
"> data = pd.read_csv('Americas-data.csv')\n"
"> data['life_qrtl'] = data['lifeExp'].apply(calculate_life_quartile)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> There is a lot in that second line, so let's take it piece by piece.\n"
"> On the right side of the `=` we start with `data['lifeExp']`, which is the\n"
"> column in the dataframe called `data` labeled `lifExp`.  We use the\n"
"> `apply()` to do what it says, apply the `calculate_life_quartile` to the\n"
"> value of this column for every row in the dataframe."
msgstr ""
">\n"
"> Ця функція зазвичай використовується в циклі for, але Pandas має\n"
"> інший, більш ефективний спосіб робити те саме шляхом\n"
"> *застосування* функції до фрейму даних або частини фрейму даних. Розглянемо\n"
"> приклад, використовуючи наведене вище визначення функції.\n"
">\n"
"> ~~~\n"
"> data = pd.read_csv('Americas-data.csv')\n"
"> data['life_qrtl'] = data['lifeExp'].apply(calculate_life_quartile)\n"
"> ~~~\n"
"> {: .language-python}\n"
">\n"
"> У другому рядку є багато цікавого, тому давайте розглянемо це по частинах.\n"
"> Праворуч від `=` ми починаємо з `data['lifeExp']`, який є \n"
"> стовпцем з позначкою `lifExp` у фреймі даних `data` .  Ми використовуємо засіб\n"
"> `apply()`, щоб виконати функцію `calculate_life_quartile` для\n"
"> визначення значень стовпця  'life_qrtl' для кожного рядку фрему даних `data`"
